#!/bin/sh
set -u
rm -fR -- ./tools/testing/selftests/zram ./tools/testing/selftests/x86/bugs ./tools/testing/selftests/x86 ./tools/testing/selftests/wireguard/qemu/arch ./tools/testing/selftests/wireguard/qemu ./tools/testing/selftests/wireguard ./tools/testing/selftests/watchdog ./tools/testing/selftests/vsock ./tools/testing/selftests/vfio/lib/include ./tools/testing/selftests/vfio/lib/drivers/ioat ./tools/testing/selftests/vfio/lib/drivers/dsa ./tools/testing/selftests/vfio/lib/drivers ./tools/testing/selftests/vfio/lib ./tools/testing/selftests/vfio ./tools/testing/selftests/vDSO ./tools/testing/selftests/user_events ./tools/testing/selftests/uevent ./tools/testing/selftests/ublk/trace ./tools/testing/selftests/ublk ./tools/testing/selftests/turbostat ./tools/testing/selftests/tty ./tools/testing/selftests/tpm2 ./tools/testing/selftests/tmpfs ./tools/testing/selftests/timers ./tools/testing/selftests/timens ./tools/testing/selftests/thermal/intel/workload_hint ./tools/testing/selftests/thermal/intel/power_floor ./tools/testing/selftests/thermal/intel ./tools/testing/selftests/thermal ./tools/testing/selftests/tdx ./tools/testing/selftests/tc-testing/tc-tests/qdiscs ./tools/testing/selftests/tc-testing/tc-tests/infra ./tools/testing/selftests/tc-testing/tc-tests/filters ./tools/testing/selftests/tc-testing/tc-tests/actions ./tools/testing/selftests/tc-testing/tc-tests ./tools/testing/selftests/tc-testing/scripts ./tools/testing/selftests/tc-testing/plugins ./tools/testing/selftests/tc-testing/plugin-lib ./tools/testing/selftests/tc-testing/creating-testcases ./tools/testing/selftests/tc-testing/creating-plugins ./tools/testing/selftests/tc-testing ./tools/testing/selftests/sysctl ./tools/testing/selftests/syscall_user_dispatch ./tools/testing/selftests/sync ./tools/testing/selftests/static_keys ./tools/testing/selftests/splice ./tools/testing/selftests/sparc64/drivers ./tools/testing/selftests/sparc64 ./tools/testing/selftests/size ./tools/testing/selftests/signal ./tools/testing/selftests/sgx ./tools/testing/selftests/seccomp ./tools/testing/selftests/sched_ext ./tools/testing/selftests/sched ./tools/testing/selftests/safesetid ./tools/testing/selftests/rust ./tools/testing/selftests/rtc ./tools/testing/selftests/rseq ./tools/testing/selftests/rlimits ./tools/testing/selftests/riscv/vector ./tools/testing/selftests/riscv/sigreturn ./tools/testing/selftests/riscv/mm ./tools/testing/selftests/riscv/hwprobe ./tools/testing/selftests/riscv/abi ./tools/testing/selftests/riscv ./tools/testing/selftests/ring-buffer ./tools/testing/selftests/resctrl ./tools/testing/selftests/rcutorture/doc ./tools/testing/selftests/rcutorture/configs/scf ./tools/testing/selftests/rcutorture/configs/refscale ./tools/testing/selftests/rcutorture/configs/rcuscale ./tools/testing/selftests/rcutorture/configs/rcu ./tools/testing/selftests/rcutorture/configs/lock ./tools/testing/selftests/rcutorture/configs ./tools/testing/selftests/rcutorture/bin ./tools/testing/selftests/rcutorture ./tools/testing/selftests/ptrace ./tools/testing/selftests/ptp ./tools/testing/selftests/pstore ./tools/testing/selftests/proc ./tools/testing/selftests/prctl ./tools/testing/selftests/power_supply ./tools/testing/selftests/powerpc/vphn/asm ./tools/testing/selftests/powerpc/vphn ./tools/testing/selftests/powerpc/tm ./tools/testing/selftests/powerpc/syscalls ./tools/testing/selftests/powerpc/switch_endian ./tools/testing/selftests/powerpc/stringloops/linux ./tools/testing/selftests/powerpc/stringloops/asm ./tools/testing/selftests/powerpc/stringloops ./tools/testing/selftests/powerpc/signal ./tools/testing/selftests/powerpc/security ./tools/testing/selftests/powerpc/scripts ./tools/testing/selftests/powerpc/ptrace ./tools/testing/selftests/powerpc/primitives/linux ./tools/testing/selftests/powerpc/primitives/asm ./tools/testing/selftests/powerpc/primitives ./tools/testing/selftests/powerpc/pmu/sampling_tests ./tools/testing/selftests/powerpc/pmu/event_code_tests ./tools/testing/selftests/powerpc/pmu/ebb ./tools/testing/selftests/powerpc/pmu ./tools/testing/selftests/powerpc/papr_vpd ./tools/testing/selftests/powerpc/papr_sysparm ./tools/testing/selftests/powerpc/papr_attributes ./tools/testing/selftests/powerpc/nx-gzip/include ./tools/testing/selftests/powerpc/nx-gzip ./tools/testing/selftests/powerpc/mm ./tools/testing/selftests/powerpc/mce ./tools/testing/selftests/powerpc/math ./tools/testing/selftests/powerpc/lib ./tools/testing/selftests/powerpc/include ./tools/testing/selftests/powerpc/eeh ./tools/testing/selftests/powerpc/dscr ./tools/testing/selftests/powerpc/dexcr ./tools/testing/selftests/powerpc/copyloops/linux ./tools/testing/selftests/powerpc/copyloops/asm ./tools/testing/selftests/powerpc/copyloops ./tools/testing/selftests/powerpc/cache_shape ./tools/testing/selftests/powerpc/benchmarks ./tools/testing/selftests/powerpc/alignment ./tools/testing/selftests/powerpc ./tools/testing/selftests/pid_namespace ./tools/testing/selftests/pidfd ./tools/testing/selftests/perf_events ./tools/testing/selftests/pci_endpoint ./tools/testing/selftests/pcie_bwctrl ./tools/testing/selftests/openat2 ./tools/testing/selftests/ntb ./tools/testing/selftests/nolibc ./tools/testing/selftests/net/tcp_ao/lib ./tools/testing/selftests/net/tcp_ao ./tools/testing/selftests/net/rds ./tools/testing/selftests/net/packetdrill ./tools/testing/selftests/net/ovpn ./tools/testing/selftests/net/openvswitch ./tools/testing/selftests/net/netfilter/packetdrill ./tools/testing/selftests/net/netfilter ./tools/testing/selftests/net/mptcp ./tools/testing/selftests/net/lib/sh ./tools/testing/selftests/net/lib/py ./tools/testing/selftests/net/lib ./tools/testing/selftests/net/hsr ./tools/testing/selftests/net/forwarding ./tools/testing/selftests/net/can ./tools/testing/selftests/net/bench/page_pool ./tools/testing/selftests/net/bench ./tools/testing/selftests/net/af_unix ./tools/testing/selftests/net ./tools/testing/selftests/nci ./tools/testing/selftests/namespaces ./tools/testing/selftests/mseal_system_mappings ./tools/testing/selftests/mqueue ./tools/testing/selftests/move_mount_set_group ./tools/testing/selftests/mount_setattr ./tools/testing/selftests/mount ./tools/testing/selftests/module ./tools/testing/selftests/mm/page_frag ./tools/testing/selftests/mm ./tools/testing/selftests/mincore ./tools/testing/selftests/memory-hotplug ./tools/testing/selftests/memfd ./tools/testing/selftests/membarrier ./tools/testing/selftests/media_tests ./tools/testing/selftests/lsm ./tools/testing/selftests/locking ./tools/testing/selftests/lkdtm ./tools/testing/selftests/livepatch/test_modules ./tools/testing/selftests/livepatch ./tools/testing/selftests/lib ./tools/testing/selftests/landlock ./tools/testing/selftests/kvm/x86 ./tools/testing/selftests/kvm/s390 ./tools/testing/selftests/kvm/riscv ./tools/testing/selftests/kvm/lib/x86 ./tools/testing/selftests/kvm/lib/s390 ./tools/testing/selftests/kvm/lib/riscv ./tools/testing/selftests/kvm/lib/loongarch ./tools/testing/selftests/kvm/lib/arm64 ./tools/testing/selftests/kvm/lib ./tools/testing/selftests/kvm/include/x86 ./tools/testing/selftests/kvm/include/s390 ./tools/testing/selftests/kvm/include/riscv ./tools/testing/selftests/kvm/include/loongarch ./tools/testing/selftests/kvm/include/arm64 ./tools/testing/selftests/kvm/include ./tools/testing/selftests/kvm/arm64 ./tools/testing/selftests/kvm ./tools/testing/selftests/kselftest_harness ./tools/testing/selftests/kselftest ./tools/testing/selftests/kmod ./tools/testing/selftests/kho ./tools/testing/selftests/kexec ./tools/testing/selftests/kcmp ./tools/testing/selftests/ir ./tools/testing/selftests/ipc ./tools/testing/selftests/iommu ./tools/testing/selftests/intel_pstate ./tools/testing/selftests/ia64 ./tools/testing/selftests/hid/tests ./tools/testing/selftests/hid/progs ./tools/testing/selftests/hid ./tools/testing/selftests/gpio ./tools/testing/selftests/futex/include ./tools/testing/selftests/futex/functional ./tools/testing/selftests/futex ./tools/testing/selftests/ftrace/test.d/trigger/inter-event ./tools/testing/selftests/ftrace/test.d/trigger ./tools/testing/selftests/ftrace/test.d/tracer ./tools/testing/selftests/ftrace/test.d/selftest ./tools/testing/selftests/ftrace/test.d/preemptirq ./tools/testing/selftests/ftrace/test.d/kprobe ./tools/testing/selftests/ftrace/test.d/instances ./tools/testing/selftests/ftrace/test.d/ftrace ./tools/testing/selftests/ftrace/test.d/filter ./tools/testing/selftests/ftrace/test.d/event ./tools/testing/selftests/ftrace/test.d/dynevent ./tools/testing/selftests/ftrace/test.d/direct ./tools/testing/selftests/ftrace/test.d/00basic ./tools/testing/selftests/ftrace/test.d ./tools/testing/selftests/ftrace/samples ./tools/testing/selftests/ftrace ./tools/testing/selftests/fpu ./tools/testing/selftests/firmware ./tools/testing/selftests/filesystems/statmount ./tools/testing/selftests/filesystems/overlayfs ./tools/testing/selftests/filesystems/nsfs ./tools/testing/selftests/filesystems/mount-notify ./tools/testing/selftests/filesystems/fuse ./tools/testing/selftests/filesystems/fat ./tools/testing/selftests/filesystems/eventfd ./tools/testing/selftests/filesystems/epoll ./tools/testing/selftests/filesystems/binderfs ./tools/testing/selftests/filesystems ./tools/testing/selftests/filelock ./tools/testing/selftests/fchmodat2 ./tools/testing/selftests/exec ./tools/testing/selftests/efivarfs ./tools/testing/selftests/dt ./tools/testing/selftests/drivers/usb/usbip ./tools/testing/selftests/drivers/usb ./tools/testing/selftests/drivers/sdsi ./tools/testing/selftests/drivers/s390x/uvdevice ./tools/testing/selftests/drivers/s390x ./tools/testing/selftests/drivers/platform/x86/intel/ifs ./tools/testing/selftests/drivers/platform/x86/intel ./tools/testing/selftests/drivers/platform/x86 ./tools/testing/selftests/drivers/platform ./tools/testing/selftests/drivers/ntsync ./tools/testing/selftests/drivers/net/virtio_net ./tools/testing/selftests/drivers/net/team ./tools/testing/selftests/drivers/net/ocelot ./tools/testing/selftests/drivers/net/netdevsim ./tools/testing/selftests/drivers/net/mlxsw/spectrum-2 ./tools/testing/selftests/drivers/net/mlxsw/spectrum ./tools/testing/selftests/drivers/net/mlxsw ./tools/testing/selftests/drivers/net/microchip ./tools/testing/selftests/drivers/net/lib/sh ./tools/testing/selftests/drivers/net/lib/py ./tools/testing/selftests/drivers/net/lib ./tools/testing/selftests/drivers/net/hw/lib/py ./tools/testing/selftests/drivers/net/hw/lib ./tools/testing/selftests/drivers/net/hw ./tools/testing/selftests/drivers/net/dsa ./tools/testing/selftests/drivers/net/bonding ./tools/testing/selftests/drivers/net ./tools/testing/selftests/drivers/gpu ./tools/testing/selftests/drivers/dma-buf ./tools/testing/selftests/drivers ./tools/testing/selftests/dmabuf-heaps ./tools/testing/selftests/dma ./tools/testing/selftests/devices/probe/boards ./tools/testing/selftests/devices/probe ./tools/testing/selftests/devices/error_logs ./tools/testing/selftests/devices ./tools/testing/selftests/damon ./tools/testing/selftests/cpu-hotplug ./tools/testing/selftests/cpufreq ./tools/testing/selftests/coredump ./tools/testing/selftests/core ./tools/testing/selftests/connector ./tools/testing/selftests/clone3 ./tools/testing/selftests/cgroup/lib/include ./tools/testing/selftests/cgroup/lib ./tools/testing/selftests/cgroup ./tools/testing/selftests/capabilities ./tools/testing/selftests/cachestat ./tools/testing/selftests/breakpoints ./tools/testing/selftests/bpf/verifier ./tools/testing/selftests/bpf/test_kmods ./tools/testing/selftests/bpf/prog_tests ./tools/testing/selftests/bpf/progs ./tools/testing/selftests/bpf/map_tests ./tools/testing/selftests/bpf/gnu ./tools/testing/selftests/bpf/benchs ./tools/testing/selftests/bpf ./tools/testing/selftests/arm64/tags ./tools/testing/selftests/arm64/signal/testcases ./tools/testing/selftests/arm64/signal ./tools/testing/selftests/arm64/pauth ./tools/testing/selftests/arm64/mte ./tools/testing/selftests/arm64/gcs ./tools/testing/selftests/arm64/fp ./tools/testing/selftests/arm64/bti ./tools/testing/selftests/arm64/abi ./tools/testing/selftests/arm64 ./tools/testing/selftests/amd-pstate ./tools/testing/selftests/alsa/conf.d ./tools/testing/selftests/alsa ./tools/testing/selftests/acct ./tools/testing/selftests ./tools/testing/crypto/chacha20-s390 ./tools/testing/crypto ./tools/perf/pmu-events/arch/s390/cf_zec12 ./tools/perf/pmu-events/arch/s390/cf_z196 ./tools/perf/pmu-events/arch/s390/cf_z17 ./tools/perf/pmu-events/arch/s390/cf_z16 ./tools/perf/pmu-events/arch/s390/cf_z15 ./tools/perf/pmu-events/arch/s390/cf_z14 ./tools/perf/pmu-events/arch/s390/cf_z13 ./tools/perf/pmu-events/arch/s390/cf_z10 ./tools/perf/pmu-events/arch/s390 ./tools/perf/pmu-events/arch/powerpc/power9 ./tools/perf/pmu-events/arch/powerpc/power8 ./tools/perf/pmu-events/arch/powerpc/power10 ./tools/perf/pmu-events/arch/powerpc/compat ./tools/perf/pmu-events/arch/powerpc ./tools/perf/arch/xtensa/include ./tools/perf/arch/xtensa/entry/syscalls ./tools/perf/arch/xtensa/entry ./tools/perf/arch/xtensa ./tools/perf/arch/sparc/include ./tools/perf/arch/sparc/entry/syscalls ./tools/perf/arch/sparc/entry ./tools/perf/arch/sparc/annotate ./tools/perf/arch/sparc ./tools/perf/arch/s390/util ./tools/perf/arch/s390/include ./tools/perf/arch/s390/entry/syscalls ./tools/perf/arch/s390/entry ./tools/perf/arch/s390/annotate ./tools/perf/arch/s390 ./tools/perf/arch/powerpc/util ./tools/perf/arch/powerpc/tests ./tools/perf/arch/powerpc/include ./tools/perf/arch/powerpc/entry/syscalls ./tools/perf/arch/powerpc/entry ./tools/perf/arch/powerpc/annotate ./tools/perf/arch/powerpc ./tools/perf/arch/parisc/entry/syscalls ./tools/perf/arch/parisc/entry ./tools/perf/arch/parisc ./tools/perf/arch/alpha/entry/syscalls ./tools/perf/arch/alpha/entry ./tools/perf/arch/alpha ./tools/objtool/arch/powerpc/include/arch ./tools/objtool/arch/powerpc/include ./tools/objtool/arch/powerpc ./tools/firewire ./tools/arch/xtensa/include/uapi/asm ./tools/arch/xtensa/include/uapi ./tools/arch/xtensa/include/asm ./tools/arch/xtensa/include ./tools/arch/xtensa ./tools/arch/sparc/include/uapi/asm ./tools/arch/sparc/include/uapi ./tools/arch/sparc/include/asm ./tools/arch/sparc/include ./tools/arch/sparc ./tools/arch/sh/include/uapi/asm ./tools/arch/sh/include/uapi ./tools/arch/sh/include/asm ./tools/arch/sh/include ./tools/arch/sh ./tools/arch/s390/include/uapi/asm ./tools/arch/s390/include/uapi ./tools/arch/s390/include/asm ./tools/arch/s390/include ./tools/arch/s390 ./tools/arch/powerpc/include/uapi/asm ./tools/arch/powerpc/include/uapi ./tools/arch/powerpc/include/asm ./tools/arch/powerpc/include ./tools/arch/powerpc ./tools/arch/parisc/include/uapi/asm ./tools/arch/parisc/include/uapi ./tools/arch/parisc/include ./tools/arch/parisc ./tools/arch/microblaze/include/uapi/asm ./tools/arch/microblaze/include/uapi ./tools/arch/microblaze/include ./tools/arch/microblaze ./tools/arch/hexagon/include/uapi/asm ./tools/arch/hexagon/include/uapi ./tools/arch/hexagon/include ./tools/arch/hexagon ./tools/arch/csky/include/uapi/asm ./tools/arch/csky/include/uapi ./tools/arch/csky/include ./tools/arch/csky ./tools/arch/arc/include/uapi/asm ./tools/arch/arc/include/uapi ./tools/arch/arc/include ./tools/arch/arc ./tools/arch/alpha/include/uapi/asm ./tools/arch/alpha/include/uapi ./tools/arch/alpha/include/asm ./tools/arch/alpha/include ./tools/arch/alpha ./sound/sparc ./sound/sh ./sound/ppc ./sound/pcmcia/vx ./sound/pcmcia/pdaudiocf ./sound/pcmcia ./sound/parisc ./sound/firewire/tascam ./sound/firewire/oxfw ./sound/firewire/motu ./sound/firewire/fireworks ./sound/firewire/fireface ./sound/firewire/digi00x ./sound/firewire/dice ./sound/firewire/bebob ./sound/firewire ./net/openvswitch ./net/mptcp ./lib/zlib_dfltcc ./lib/crypto/sparc ./lib/crypto/s390 ./lib/crypto/powerpc ./lib/crc/sparc ./lib/crc/s390 ./lib/crc/powerpc ./fs/ocfs2/dlmfs ./fs/ocfs2/dlm ./fs/ocfs2/cluster ./fs/ocfs2 ./fs/nilfs2 ./fs/jfs ./fs/hfsplus ./fs/hfs ./fs/gfs2 ./drivers/s390/virtio ./drivers/s390/scsi ./drivers/s390/net ./drivers/s390/crypto ./drivers/s390/cio ./drivers/s390/char ./drivers/s390/block ./drivers/s390 ./drivers/net/xgw ./drivers/net/ethernet/netronome/nfp/nic ./drivers/net/ethernet/netronome/nfp/nfpcore/nfp6000 ./drivers/net/ethernet/netronome/nfp/nfpcore ./drivers/net/ethernet/netronome/nfp/nfdk ./drivers/net/ethernet/netronome/nfp/nfd3 ./drivers/net/ethernet/netronome/nfp/flower ./drivers/net/ethernet/netronome/nfp/crypto ./drivers/net/ethernet/netronome/nfp/bpf ./drivers/net/ethernet/netronome/nfp/abm ./drivers/net/ethernet/netronome/nfp ./drivers/net/ethernet/netronome ./drivers/net/ethernet/neterion ./drivers/net/ethernet/natsemi ./drivers/net/ethernet/chelsio/libcxgb ./drivers/net/ethernet/chelsio/inline_crypto/chtls ./drivers/net/ethernet/chelsio/inline_crypto/ch_ktls ./drivers/net/ethernet/chelsio/inline_crypto/ch_ipsec ./drivers/net/ethernet/chelsio/inline_crypto ./drivers/net/ethernet/chelsio/cxgb4vf ./drivers/net/ethernet/chelsio/cxgb4 ./drivers/net/ethernet/chelsio/cxgb3 ./drivers/net/ethernet/chelsio/cxgb ./drivers/net/ethernet/chelsio ./drivers/net/clf ./drivers/media/firewire ./drivers/infiniband/ulp/srpt ./drivers/infiniband/ulp/srp ./drivers/infiniband/ulp/rtrs ./drivers/infiniband/ulp/opa_vnic ./drivers/infiniband/ulp/isert ./drivers/infiniband/ulp/iser ./drivers/infiniband/ulp/ipoib ./drivers/infiniband/ulp ./drivers/infiniband/sw/siw ./drivers/infiniband/sw/rxe ./drivers/infiniband/sw/rdmavt ./drivers/infiniband/sw ./drivers/infiniband/hw/vmw_pvrdma ./drivers/infiniband/hw/usnic ./drivers/infiniband/hw/qedr ./drivers/infiniband/hw/ocrdma ./drivers/infiniband/hw/mthca ./drivers/infiniband/hw/mlx5 ./drivers/infiniband/hw/mlx4 ./drivers/infiniband/hw/mana ./drivers/infiniband/hw/irdma ./drivers/infiniband/hw/ionic ./drivers/infiniband/hw/hns ./drivers/infiniband/hw/hfi1 ./drivers/infiniband/hw/erdma ./drivers/infiniband/hw/efa ./drivers/infiniband/hw/cxgb4 ./drivers/infiniband/hw/bnxt_re ./drivers/infiniband/hw ./drivers/infiniband/core ./drivers/infiniband ./drivers/firewire ./Documentation/wmi/devices ./Documentation/wmi ./Documentation/watchdog ./Documentation/w1/slaves ./Documentation/w1/masters ./Documentation/w1 ./Documentation/virt/uml ./Documentation/virt/kvm/x86 ./Documentation/virt/kvm/s390 ./Documentation/virt/kvm/loongarch ./Documentation/virt/kvm/devices ./Documentation/virt/kvm/arm ./Documentation/virt/kvm ./Documentation/virt/hyperv ./Documentation/virt/coco ./Documentation/virt/acrn ./Documentation/virt ./Documentation/userspace-api/netlink ./Documentation/userspace-api/media/v4l ./Documentation/userspace-api/media/rc ./Documentation/userspace-api/media/mediactl ./Documentation/userspace-api/media/dvb ./Documentation/userspace-api/media/drivers ./Documentation/userspace-api/media/cec ./Documentation/userspace-api/media ./Documentation/userspace-api/ioctl ./Documentation/userspace-api/gpio ./Documentation/userspace-api/fwctl ./Documentation/userspace-api/ebpf ./Documentation/userspace-api/accelerators ./Documentation/userspace-api ./Documentation/usb ./Documentation/translations/zh_TW/process ./Documentation/translations/zh_TW/filesystems ./Documentation/translations/zh_TW/dev-tools ./Documentation/translations/zh_TW/cpu-freq ./Documentation/translations/zh_TW/arch/parisc ./Documentation/translations/zh_TW/arch/openrisc ./Documentation/translations/zh_TW/arch/mips ./Documentation/translations/zh_TW/arch/loongarch ./Documentation/translations/zh_TW/arch/arm64 ./Documentation/translations/zh_TW/arch/arm ./Documentation/translations/zh_TW/arch ./Documentation/translations/zh_TW/admin-guide/mm/damon ./Documentation/translations/zh_TW/admin-guide/mm ./Documentation/translations/zh_TW/admin-guide ./Documentation/translations/zh_TW ./Documentation/translations/zh_CN/virt/acrn ./Documentation/translations/zh_CN/virt ./Documentation/translations/zh_CN/video4linux ./Documentation/translations/zh_CN/userspace-api/ebpf ./Documentation/translations/zh_CN/userspace-api/accelerators ./Documentation/translations/zh_CN/userspace-api ./Documentation/translations/zh_CN/staging ./Documentation/translations/zh_CN/sound/hd-audio ./Documentation/translations/zh_CN/sound ./Documentation/translations/zh_CN/security/tpm ./Documentation/translations/zh_CN/security/secrets ./Documentation/translations/zh_CN/security/keys ./Documentation/translations/zh_CN/security ./Documentation/translations/zh_CN/scheduler ./Documentation/translations/zh_CN/rust ./Documentation/translations/zh_CN/process ./Documentation/translations/zh_CN/power ./Documentation/translations/zh_CN/peci ./Documentation/translations/zh_CN/PCI ./Documentation/translations/zh_CN/networking ./Documentation/translations/zh_CN/mm/damon ./Documentation/translations/zh_CN/mm ./Documentation/translations/zh_CN/maintainer ./Documentation/translations/zh_CN/locking ./Documentation/translations/zh_CN/kernel-hacking ./Documentation/translations/zh_CN/kbuild ./Documentation/translations/zh_CN/infiniband ./Documentation/translations/zh_CN/iio ./Documentation/translations/zh_CN/filesystems ./Documentation/translations/zh_CN/driver-api/phy ./Documentation/translations/zh_CN/driver-api/gpio ./Documentation/translations/zh_CN/driver-api ./Documentation/translations/zh_CN/doc-guide ./Documentation/translations/zh_CN/dev-tools ./Documentation/translations/zh_CN/devicetree ./Documentation/translations/zh_CN/cpu-freq ./Documentation/translations/zh_CN/core-api/irq ./Documentation/translations/zh_CN/core-api ./Documentation/translations/zh_CN/arch/riscv ./Documentation/translations/zh_CN/arch/parisc ./Documentation/translations/zh_CN/arch/openrisc ./Documentation/translations/zh_CN/arch/mips ./Documentation/translations/zh_CN/arch/loongarch ./Documentation/translations/zh_CN/arch/arm64 ./Documentation/translations/zh_CN/arch/arm ./Documentation/translations/zh_CN/arch ./Documentation/translations/zh_CN/admin-guide/mm/damon ./Documentation/translations/zh_CN/admin-guide/mm ./Documentation/translations/zh_CN/admin-guide ./Documentation/translations/zh_CN/accounting ./Documentation/translations/zh_CN ./Documentation/translations/sp_SP/wrappers ./Documentation/translations/sp_SP/scheduler ./Documentation/translations/sp_SP/process ./Documentation/translations/sp_SP ./Documentation/translations/ko_KR/process ./Documentation/translations/ko_KR/core-api/wrappers ./Documentation/translations/ko_KR/core-api ./Documentation/translations/ko_KR ./Documentation/translations/ja_JP/process ./Documentation/translations/ja_JP ./Documentation/translations/it_IT/staging ./Documentation/translations/it_IT/RCU ./Documentation/translations/it_IT/process ./Documentation/translations/it_IT/maintainer ./Documentation/translations/it_IT/locking ./Documentation/translations/it_IT/kernel-hacking ./Documentation/translations/it_IT/i2c ./Documentation/translations/it_IT/doc-guide ./Documentation/translations/it_IT/dev-tools ./Documentation/translations/it_IT/devicetree/bindings ./Documentation/translations/it_IT/devicetree ./Documentation/translations/it_IT/core-api ./Documentation/translations/it_IT/arch/riscv ./Documentation/translations/it_IT/arch ./Documentation/translations/it_IT/admin-guide ./Documentation/translations/it_IT ./Documentation/translations ./Documentation/trace/rv ./Documentation/trace/postprocess ./Documentation/trace/coresight ./Documentation/trace ./Documentation/tools/rv ./Documentation/tools/rtla ./Documentation/tools ./Documentation/timers ./Documentation/tee ./Documentation/target ./Documentation/sunrpc/xdr ./Documentation/sunrpc ./Documentation/staging ./Documentation/spi ./Documentation/sphinx/templates ./Documentation/sphinx-static ./Documentation/sphinx ./Documentation/sound/soc ./Documentation/sound/kernel-api ./Documentation/sound/hd-audio ./Documentation/sound/designs ./Documentation/sound/codecs ./Documentation/sound/cards ./Documentation/sound ./Documentation/security/tpm ./Documentation/security/secrets ./Documentation/security/keys ./Documentation/security ./Documentation/scsi/scsi_transport_srp ./Documentation/scsi ./Documentation/scheduler ./Documentation/rust ./Documentation/RCU/Design/Requirements ./Documentation/RCU/Design/Memory-Ordering ./Documentation/RCU/Design/Expedited-Grace-Periods ./Documentation/RCU/Design/Data-Structures ./Documentation/RCU/Design ./Documentation/RCU ./Documentation/process/debugging ./Documentation/process ./Documentation/power/regulator ./Documentation/power/powercap ./Documentation/power ./Documentation/peci ./Documentation/pcmcia ./Documentation/PCI/endpoint/function/binding ./Documentation/PCI/endpoint/function ./Documentation/PCI/endpoint ./Documentation/PCI/controller ./Documentation/PCI ./Documentation/nvme ./Documentation/nvdimm ./Documentation/networking/pse-pd ./Documentation/networking/net_cachelines ./Documentation/networking/mac80211_hwsim ./Documentation/networking/dsa ./Documentation/networking/diagnostic ./Documentation/networking/devlink ./Documentation/networking/device_drivers/wwan ./Documentation/networking/device_drivers/wifi/intel ./Documentation/networking/device_drivers/wifi ./Documentation/networking/device_drivers/hamradio ./Documentation/networking/device_drivers/fddi ./Documentation/networking/device_drivers/ethernet/wangxun ./Documentation/networking/device_drivers/ethernet/ti ./Documentation/networking/device_drivers/ethernet/stmicro ./Documentation/networking/device_drivers/ethernet/smsc ./Documentation/networking/device_drivers/ethernet/qualcomm/ppe ./Documentation/networking/device_drivers/ethernet/qualcomm ./Documentation/networking/device_drivers/ethernet/pensando ./Documentation/networking/device_drivers/ethernet/netronome ./Documentation/networking/device_drivers/ethernet/neterion ./Documentation/networking/device_drivers/ethernet/microsoft ./Documentation/networking/device_drivers/ethernet/meta ./Documentation/networking/device_drivers/ethernet/mellanox/mlx5 ./Documentation/networking/device_drivers/ethernet/mellanox ./Documentation/networking/device_drivers/ethernet/marvell ./Documentation/networking/device_drivers/ethernet/intel ./Documentation/networking/device_drivers/ethernet/huawei ./Documentation/networking/device_drivers/ethernet/google ./Documentation/networking/device_drivers/ethernet/freescale/dpaa2 ./Documentation/networking/device_drivers/ethernet/freescale ./Documentation/networking/device_drivers/ethernet/dlink ./Documentation/networking/device_drivers/ethernet/dec ./Documentation/networking/device_drivers/ethernet/davicom ./Documentation/networking/device_drivers/ethernet/cirrus ./Documentation/networking/device_drivers/ethernet/chelsio ./Documentation/networking/device_drivers/ethernet/aquantia ./Documentation/networking/device_drivers/ethernet/amd ./Documentation/networking/device_drivers/ethernet/amazon ./Documentation/networking/device_drivers/ethernet/altera ./Documentation/networking/device_drivers/ethernet/3com ./Documentation/networking/device_drivers/ethernet ./Documentation/networking/device_drivers/cellular/qualcomm ./Documentation/networking/device_drivers/cellular ./Documentation/networking/device_drivers/can/freescale ./Documentation/networking/device_drivers/can/ctu ./Documentation/networking/device_drivers/can ./Documentation/networking/device_drivers/atm ./Documentation/networking/device_drivers ./Documentation/networking/caif ./Documentation/networking ./Documentation/netlink/specs ./Documentation/netlink ./Documentation/netlabel ./Documentation/mm/damon ./Documentation/mm ./Documentation/misc-devices ./Documentation/mhi ./Documentation/maintainer ./Documentation/locking ./Documentation/livepatch ./Documentation/litmus-tests/rcu ./Documentation/litmus-tests/locking ./Documentation/litmus-tests/atomic ./Documentation/litmus-tests ./Documentation/leds ./Documentation/kernel-hacking ./Documentation/kbuild ./Documentation/isdn ./Documentation/input/joydev ./Documentation/input/devices ./Documentation/input ./Documentation/infiniband ./Documentation/images ./Documentation/iio ./Documentation/i2c/muxes ./Documentation/i2c/busses ./Documentation/i2c ./Documentation/hwmon ./Documentation/hid ./Documentation/gpu/xe ./Documentation/gpu/rfc ./Documentation/gpu/nova/core ./Documentation/gpu/nova ./Documentation/gpu/imagination ./Documentation/gpu/dp-mst ./Documentation/gpu/bridge ./Documentation/gpu/amdgpu/gc ./Documentation/gpu/amdgpu/display ./Documentation/gpu/amdgpu ./Documentation/gpu ./Documentation/fpga ./Documentation/firmware-guide/acpi/dsd ./Documentation/firmware-guide/acpi/apei ./Documentation/firmware-guide/acpi ./Documentation/firmware-guide ./Documentation/firmware_class ./Documentation/filesystems/xfs ./Documentation/filesystems/spufs ./Documentation/filesystems/smb ./Documentation/filesystems/nfs ./Documentation/filesystems/iomap ./Documentation/filesystems/fuse ./Documentation/filesystems/ext4 ./Documentation/filesystems/caching ./Documentation/filesystems ./Documentation/features/vm/TLB ./Documentation/features/vm/THP ./Documentation/features/vm/pte_special ./Documentation/features/vm/ioremap_prot ./Documentation/features/vm/huge-vmap ./Documentation/features/vm/ELF-ASLR ./Documentation/features/vm ./Documentation/features/time/virt-cpuacct ./Documentation/features/time/irq-time-acct ./Documentation/features/time/context-tracking ./Documentation/features/time/clockevents ./Documentation/features/time/arch-tick-broadcast ./Documentation/features/time ./Documentation/features/seccomp/seccomp-filter ./Documentation/features/seccomp ./Documentation/features/scripts ./Documentation/features/sched/numa-balancing ./Documentation/features/sched/membarrier-sync-core ./Documentation/features/sched ./Documentation/features/perf/perf-stackdump ./Documentation/features/perf/perf-regs ./Documentation/features/perf/kprobes-event ./Documentation/features/perf ./Documentation/features/locking/queued-spinlocks ./Documentation/features/locking/queued-rwlocks ./Documentation/features/locking/lockdep ./Documentation/features/locking/cmpxchg-local ./Documentation/features/locking ./Documentation/features/io/dma-contiguous ./Documentation/features/io ./Documentation/features/debug/user-ret-profiler ./Documentation/features/debug/uprobes ./Documentation/features/debug/stackprotector ./Documentation/features/debug/optprobes ./Documentation/features/debug/kretprobes ./Documentation/features/debug/kprobes-on-ftrace ./Documentation/features/debug/kprobes ./Documentation/features/debug/kmemleak ./Documentation/features/debug/kgdb ./Documentation/features/debug/kcov ./Documentation/features/debug/KASAN ./Documentation/features/debug/gcov-profile-all ./Documentation/features/debug/debug-vm-pgtable ./Documentation/features/debug ./Documentation/features/core/tracehook ./Documentation/features/core/thread-info-in-task ./Documentation/features/core/mseal_sys_mappings ./Documentation/features/core/jump-labels ./Documentation/features/core/generic-idle-thread ./Documentation/features/core/eBPF-JIT ./Documentation/features/core/cBPF-JIT ./Documentation/features/core ./Documentation/features ./Documentation/fb ./Documentation/fault-injection ./Documentation/edac ./Documentation/driver-api/xilinx ./Documentation/driver-api/virtio ./Documentation/driver-api/usb ./Documentation/driver-api/tty ./Documentation/driver-api/thermal ./Documentation/driver-api/surface_aggregator/clients ./Documentation/driver-api/surface_aggregator ./Documentation/driver-api/soundwire ./Documentation/driver-api/serial ./Documentation/driver-api/rapidio ./Documentation/driver-api/pm ./Documentation/driver-api/pldmfw ./Documentation/driver-api/phy ./Documentation/driver-api/pci ./Documentation/driver-api/nvdimm ./Documentation/driver-api/nfc ./Documentation/driver-api/mtd ./Documentation/driver-api/mmc ./Documentation/driver-api/memory-devices ./Documentation/driver-api/mei ./Documentation/driver-api/media/drivers/ccs ./Documentation/driver-api/media/drivers ./Documentation/driver-api/media ./Documentation/driver-api/md ./Documentation/driver-api/iio ./Documentation/driver-api/i3c ./Documentation/driver-api/hte ./Documentation/driver-api/gpio ./Documentation/driver-api/fpga ./Documentation/driver-api/firmware/efi ./Documentation/driver-api/firmware ./Documentation/driver-api/early-userspace ./Documentation/driver-api/driver-model ./Documentation/driver-api/dmaengine ./Documentation/driver-api/cxl/platform/example-configurations ./Documentation/driver-api/cxl/platform/acpi ./Documentation/driver-api/cxl/platform ./Documentation/driver-api/cxl/linux/example-configurations ./Documentation/driver-api/cxl/linux ./Documentation/driver-api/cxl/devices ./Documentation/driver-api/cxl/allocation ./Documentation/driver-api/cxl ./Documentation/driver-api/crypto/iaa ./Documentation/driver-api/crypto ./Documentation/driver-api/coco ./Documentation/driver-api/backlight ./Documentation/driver-api/acpi ./Documentation/driver-api/80211 ./Documentation/driver-api ./Documentation/doc-guide ./Documentation/dev-tools/lkmm/docs ./Documentation/dev-tools/lkmm ./Documentation/dev-tools/kunit/api ./Documentation/dev-tools/kunit ./Documentation/dev-tools ./Documentation/devicetree/bindings/xillybus ./Documentation/devicetree/bindings/x86 ./Documentation/devicetree/bindings/watchdog ./Documentation/devicetree/bindings/w1 ./Documentation/devicetree/bindings/virtio ./Documentation/devicetree/bindings/usb ./Documentation/devicetree/bindings/ufs ./Documentation/devicetree/bindings/trigger-source ./Documentation/devicetree/bindings/tpm ./Documentation/devicetree/bindings/timestamp ./Documentation/devicetree/bindings/timer ./Documentation/devicetree/bindings/thermal ./Documentation/devicetree/bindings/sram ./Documentation/devicetree/bindings/spmi ./Documentation/devicetree/bindings/spi ./Documentation/devicetree/bindings/soundwire ./Documentation/devicetree/bindings/sound ./Documentation/devicetree/bindings/soc/xilinx ./Documentation/devicetree/bindings/soc/ti ./Documentation/devicetree/bindings/soc/tegra ./Documentation/devicetree/bindings/soc/sti ./Documentation/devicetree/bindings/soc/starfive ./Documentation/devicetree/bindings/soc/sprd ./Documentation/devicetree/bindings/soc/spacemit ./Documentation/devicetree/bindings/soc/sophgo ./Documentation/devicetree/bindings/soc/socionext ./Documentation/devicetree/bindings/soc/samsung ./Documentation/devicetree/bindings/soc/rockchip ./Documentation/devicetree/bindings/soc/renesas ./Documentation/devicetree/bindings/soc/qcom ./Documentation/devicetree/bindings/soc/nuvoton ./Documentation/devicetree/bindings/soc/mobileye ./Documentation/devicetree/bindings/soc/microchip ./Documentation/devicetree/bindings/soc/mediatek ./Documentation/devicetree/bindings/soc/loongson ./Documentation/devicetree/bindings/soc/litex ./Documentation/devicetree/bindings/soc/intel ./Documentation/devicetree/bindings/soc/imx ./Documentation/devicetree/bindings/soc/hisilicon ./Documentation/devicetree/bindings/soc/google ./Documentation/devicetree/bindings/soc/fsl/cpm_qe/qe ./Documentation/devicetree/bindings/soc/fsl/cpm_qe/cpm ./Documentation/devicetree/bindings/soc/fsl/cpm_qe ./Documentation/devicetree/bindings/soc/fsl ./Documentation/devicetree/bindings/soc/dove ./Documentation/devicetree/bindings/soc/cirrus ./Documentation/devicetree/bindings/soc/bcm ./Documentation/devicetree/bindings/soc/aspeed ./Documentation/devicetree/bindings/soc/amlogic ./Documentation/devicetree/bindings/soc/altera ./Documentation/devicetree/bindings/soc ./Documentation/devicetree/bindings/slimbus ./Documentation/devicetree/bindings/siox ./Documentation/devicetree/bindings/sifive ./Documentation/devicetree/bindings/serio ./Documentation/devicetree/bindings/serial ./Documentation/devicetree/bindings/scsi ./Documentation/devicetree/bindings/rtc ./Documentation/devicetree/bindings/rng ./Documentation/devicetree/bindings/riscv ./Documentation/devicetree/bindings/reset ./Documentation/devicetree/bindings/reserved-memory ./Documentation/devicetree/bindings/remoteproc ./Documentation/devicetree/bindings/regulator ./Documentation/devicetree/bindings/regmap ./Documentation/devicetree/bindings/pwm ./Documentation/devicetree/bindings/ptp ./Documentation/devicetree/bindings/pps ./Documentation/devicetree/bindings/power/supply ./Documentation/devicetree/bindings/power/reset ./Documentation/devicetree/bindings/powerpc/opal ./Documentation/devicetree/bindings/powerpc/nintendo ./Documentation/devicetree/bindings/powerpc/fsl ./Documentation/devicetree/bindings/powerpc/4xx ./Documentation/devicetree/bindings/powerpc ./Documentation/devicetree/bindings/power/avs ./Documentation/devicetree/bindings/power ./Documentation/devicetree/bindings/pmem ./Documentation/devicetree/bindings/pinctrl ./Documentation/devicetree/bindings/phy ./Documentation/devicetree/bindings/perf ./Documentation/devicetree/bindings/peci ./Documentation/devicetree/bindings/pci ./Documentation/devicetree/bindings/opp ./Documentation/devicetree/bindings/openrisc/opencores ./Documentation/devicetree/bindings/openrisc ./Documentation/devicetree/bindings/nvmem/layouts ./Documentation/devicetree/bindings/nvmem ./Documentation/devicetree/bindings/nvme ./Documentation/devicetree/bindings/npu ./Documentation/devicetree/bindings/nios2 ./Documentation/devicetree/bindings/net/wireless ./Documentation/devicetree/bindings/net/pse-pd ./Documentation/devicetree/bindings/net/pcs ./Documentation/devicetree/bindings/net/nfc ./Documentation/devicetree/bindings/net/ieee802154 ./Documentation/devicetree/bindings/net/dsa ./Documentation/devicetree/bindings/net/can ./Documentation/devicetree/bindings/net/bluetooth ./Documentation/devicetree/bindings/net ./Documentation/devicetree/bindings/mux ./Documentation/devicetree/bindings/mtd/partitions ./Documentation/devicetree/bindings/mtd ./Documentation/devicetree/bindings/mmc ./Documentation/devicetree/bindings/misc ./Documentation/devicetree/bindings/mips/pic32 ./Documentation/devicetree/bindings/mips/loongson ./Documentation/devicetree/bindings/mips/lantiq ./Documentation/devicetree/bindings/mips/ingenic ./Documentation/devicetree/bindings/mips/img ./Documentation/devicetree/bindings/mips/cavium ./Documentation/devicetree/bindings/mips/brcm ./Documentation/devicetree/bindings/mips ./Documentation/devicetree/bindings/mfd ./Documentation/devicetree/bindings/memory-controllers/ti ./Documentation/devicetree/bindings/memory-controllers/fsl ./Documentation/devicetree/bindings/memory-controllers/ddr ./Documentation/devicetree/bindings/memory-controllers ./Documentation/devicetree/bindings/media/xilinx ./Documentation/devicetree/bindings/media/spi ./Documentation/devicetree/bindings/media/i2c ./Documentation/devicetree/bindings/media/cec ./Documentation/devicetree/bindings/media ./Documentation/devicetree/bindings/mailbox ./Documentation/devicetree/bindings/loongarch ./Documentation/devicetree/bindings/leds/irled ./Documentation/devicetree/bindings/leds/backlight ./Documentation/devicetree/bindings/leds ./Documentation/devicetree/bindings/ipmi ./Documentation/devicetree/bindings/iommu ./Documentation/devicetree/bindings/interrupt-controller ./Documentation/devicetree/bindings/interconnect ./Documentation/devicetree/bindings/input/touchscreen ./Documentation/devicetree/bindings/input ./Documentation/devicetree/bindings/infiniband ./Documentation/devicetree/bindings/iio/temperature ./Documentation/devicetree/bindings/iio/resolver ./Documentation/devicetree/bindings/iio/proximity ./Documentation/devicetree/bindings/iio/pressure ./Documentation/devicetree/bindings/iio/potentiostat ./Documentation/devicetree/bindings/iio/potentiometer ./Documentation/devicetree/bindings/iio/multiplexer ./Documentation/devicetree/bindings/iio/magnetometer ./Documentation/devicetree/bindings/iio/light ./Documentation/devicetree/bindings/iio/imu ./Documentation/devicetree/bindings/iio/impedance-analyzer ./Documentation/devicetree/bindings/iio/humidity ./Documentation/devicetree/bindings/iio/health ./Documentation/devicetree/bindings/iio/gyroscope ./Documentation/devicetree/bindings/iio/frequency ./Documentation/devicetree/bindings/iio/filter ./Documentation/devicetree/bindings/iio/dac ./Documentation/devicetree/bindings/iio/chemical ./Documentation/devicetree/bindings/iio/cdc ./Documentation/devicetree/bindings/iio/amplifiers ./Documentation/devicetree/bindings/iio/afe ./Documentation/devicetree/bindings/iio/addac ./Documentation/devicetree/bindings/iio/adc ./Documentation/devicetree/bindings/iio/accel ./Documentation/devicetree/bindings/iio ./Documentation/devicetree/bindings/i3c ./Documentation/devicetree/bindings/i2c ./Documentation/devicetree/bindings/hwmon/pmbus ./Documentation/devicetree/bindings/hwmon ./Documentation/devicetree/bindings/hwlock ./Documentation/devicetree/bindings/hwinfo ./Documentation/devicetree/bindings/hsi ./Documentation/devicetree/bindings/gpu/host1x ./Documentation/devicetree/bindings/gpu ./Documentation/devicetree/bindings/gpio ./Documentation/devicetree/bindings/goldfish ./Documentation/devicetree/bindings/gnss ./Documentation/devicetree/bindings/fuse ./Documentation/devicetree/bindings/fsi ./Documentation/devicetree/bindings/fpga ./Documentation/devicetree/bindings/firmware/xilinx ./Documentation/devicetree/bindings/firmware ./Documentation/devicetree/bindings/extcon ./Documentation/devicetree/bindings/embedded-controller ./Documentation/devicetree/bindings/eeprom ./Documentation/devicetree/bindings/edac ./Documentation/devicetree/bindings/dvfs ./Documentation/devicetree/bindings/dsp ./Documentation/devicetree/bindings/dpll ./Documentation/devicetree/bindings/dma/xilinx ./Documentation/devicetree/bindings/dma/ti ./Documentation/devicetree/bindings/dma/stm32 ./Documentation/devicetree/bindings/dma ./Documentation/devicetree/bindings/display/xlnx ./Documentation/devicetree/bindings/display/tilcdc ./Documentation/devicetree/bindings/display/ti ./Documentation/devicetree/bindings/display/tegra ./Documentation/devicetree/bindings/display/sprd ./Documentation/devicetree/bindings/display/samsung ./Documentation/devicetree/bindings/display/rockchip ./Documentation/devicetree/bindings/display/panel ./Documentation/devicetree/bindings/display/msm ./Documentation/devicetree/bindings/display/mediatek ./Documentation/devicetree/bindings/display/imx ./Documentation/devicetree/bindings/display/hisilicon ./Documentation/devicetree/bindings/display/connector ./Documentation/devicetree/bindings/display/bridge ./Documentation/devicetree/bindings/display/atmel ./Documentation/devicetree/bindings/display/armada ./Documentation/devicetree/bindings/display ./Documentation/devicetree/bindings/devfreq/event ./Documentation/devicetree/bindings/devfreq ./Documentation/devicetree/bindings/csky ./Documentation/devicetree/bindings/crypto ./Documentation/devicetree/bindings/cpufreq ./Documentation/devicetree/bindings/cpu ./Documentation/devicetree/bindings/counter ./Documentation/devicetree/bindings/connector ./Documentation/devicetree/bindings/clock/ti/davinci ./Documentation/devicetree/bindings/clock/ti ./Documentation/devicetree/bindings/clock/st ./Documentation/devicetree/bindings/clock/sifive ./Documentation/devicetree/bindings/clock ./Documentation/devicetree/bindings/chrome ./Documentation/devicetree/bindings/cache ./Documentation/devicetree/bindings/bus ./Documentation/devicetree/bindings/board ./Documentation/devicetree/bindings/auxdisplay ./Documentation/devicetree/bindings/ata ./Documentation/devicetree/bindings/arm/vt8500 ./Documentation/devicetree/bindings/arm/ux500 ./Documentation/devicetree/bindings/arm/ti ./Documentation/devicetree/bindings/arm/tegra ./Documentation/devicetree/bindings/arm/sunxi ./Documentation/devicetree/bindings/arm/stm32 ./Documentation/devicetree/bindings/arm/sprd ./Documentation/devicetree/bindings/arm/socionext ./Documentation/devicetree/bindings/arm/samsung ./Documentation/devicetree/bindings/arm/rockchip ./Documentation/devicetree/bindings/arm/omap ./Documentation/devicetree/bindings/arm/nxp ./Documentation/devicetree/bindings/arm/nuvoton ./Documentation/devicetree/bindings/arm/mstar ./Documentation/devicetree/bindings/arm/mrvl ./Documentation/devicetree/bindings/arm/mediatek ./Documentation/devicetree/bindings/arm/marvell ./Documentation/devicetree/bindings/arm/keystone ./Documentation/devicetree/bindings/arm/hisilicon/controller ./Documentation/devicetree/bindings/arm/hisilicon ./Documentation/devicetree/bindings/arm/freescale ./Documentation/devicetree/bindings/arm/firmware ./Documentation/devicetree/bindings/arm/cpu-enable-method ./Documentation/devicetree/bindings/arm/cirrus ./Documentation/devicetree/bindings/arm/calxeda ./Documentation/devicetree/bindings/arm/bcm ./Documentation/devicetree/bindings/arm/aspeed ./Documentation/devicetree/bindings/arm/apple ./Documentation/devicetree/bindings/arm/amlogic ./Documentation/devicetree/bindings/arm/altera ./Documentation/devicetree/bindings/arm ./Documentation/devicetree/bindings/arc ./Documentation/devicetree/bindings/access-controllers ./Documentation/devicetree/bindings ./Documentation/devicetree ./Documentation/crypto/device_drivers ./Documentation/crypto ./Documentation/cpu-freq ./Documentation/core-api/wrappers ./Documentation/core-api/real-time ./Documentation/core-api/kho/bindings/memblock ./Documentation/core-api/kho/bindings ./Documentation/core-api/kho ./Documentation/core-api/irq ./Documentation/core-api ./Documentation/cdrom ./Documentation/bpf/standardization ./Documentation/bpf/libbpf ./Documentation/bpf ./Documentation/block ./Documentation/arch/xtensa ./Documentation/arch/x86/x86_64 ./Documentation/arch/x86/i386 ./Documentation/arch/x86 ./Documentation/arch/sparc/oradax ./Documentation/arch/sparc ./Documentation/arch/sh ./Documentation/arch/s390 ./Documentation/arch/riscv ./Documentation/arch/powerpc ./Documentation/arch/parisc ./Documentation/arch/openrisc ./Documentation/arch/nios2 ./Documentation/arch/mips ./Documentation/arch/m68k ./Documentation/arch/loongarch ./Documentation/arch/arm/vfp ./Documentation/arch/arm/sunxi ./Documentation/arch/arm/stm32 ./Documentation/arch/arm/sti ./Documentation/arch/arm/spear ./Documentation/arch/arm/samsung ./Documentation/arch/arm/sa1100 ./Documentation/arch/arm/pxa ./Documentation/arch/arm/omap ./Documentation/arch/arm/nwfpe ./Documentation/arch/arm/keystone ./Documentation/arch/arm/google ./Documentation/arch/arm64 ./Documentation/arch/arm ./Documentation/arch/arc ./Documentation/arch ./Documentation/admin-guide/thermal ./Documentation/admin-guide/sysctl ./Documentation/admin-guide/RAS ./Documentation/admin-guide/pm ./Documentation/admin-guide/perf ./Documentation/admin-guide/nfs ./Documentation/admin-guide/namespaces ./Documentation/admin-guide/mm/damon ./Documentation/admin-guide/mm ./Documentation/admin-guide/media ./Documentation/admin-guide/LSM ./Documentation/admin-guide/laptops ./Documentation/admin-guide/kdump ./Documentation/admin-guide/hw-vuln ./Documentation/admin-guide/gpio ./Documentation/admin-guide/device-mapper ./Documentation/admin-guide/cifs ./Documentation/admin-guide/cgroup-v1 ./Documentation/admin-guide/blockdev/drbd ./Documentation/admin-guide/blockdev ./Documentation/admin-guide/auxdisplay ./Documentation/admin-guide/aoe ./Documentation/admin-guide/acpi ./Documentation/admin-guide ./Documentation/accounting ./Documentation/accel/rocket ./Documentation/accel/qaic ./Documentation/accel/amdxdna ./Documentation/accel ./Documentation/ABI/testing ./Documentation/ABI/stable ./Documentation/ABI/removed ./Documentation/ABI/obsolete ./Documentation/ABI ./Documentation ./arch/xtensa/variants/test_mmuhifi_c3/include/variant ./arch/xtensa/variants/test_mmuhifi_c3/include ./arch/xtensa/variants/test_mmuhifi_c3 ./arch/xtensa/variants/test_kc705_hifi/include/variant ./arch/xtensa/variants/test_kc705_hifi/include ./arch/xtensa/variants/test_kc705_hifi ./arch/xtensa/variants/test_kc705_be/include/variant ./arch/xtensa/variants/test_kc705_be/include ./arch/xtensa/variants/test_kc705_be ./arch/xtensa/variants/fsf/include/variant ./arch/xtensa/variants/fsf/include ./arch/xtensa/variants/fsf ./arch/xtensa/variants/de212/include/variant ./arch/xtensa/variants/de212/include ./arch/xtensa/variants/de212 ./arch/xtensa/variants/dc233c/include/variant ./arch/xtensa/variants/dc233c/include ./arch/xtensa/variants/dc233c ./arch/xtensa/variants/dc232b/include/variant ./arch/xtensa/variants/dc232b/include ./arch/xtensa/variants/dc232b ./arch/xtensa/variants/csp/include/variant ./arch/xtensa/variants/csp/include ./arch/xtensa/variants/csp ./arch/xtensa/variants ./arch/xtensa/platforms/xtfpga/include/platform ./arch/xtensa/platforms/xtfpga/include ./arch/xtensa/platforms/xtfpga ./arch/xtensa/platforms/xt2000/include/platform ./arch/xtensa/platforms/xt2000/include ./arch/xtensa/platforms/xt2000 ./arch/xtensa/platforms/iss/include/platform ./arch/xtensa/platforms/iss/include ./arch/xtensa/platforms/iss ./arch/xtensa/platforms ./arch/xtensa/mm ./arch/xtensa/lib ./arch/xtensa/kernel/syscalls ./arch/xtensa/kernel ./arch/xtensa/include/uapi/asm ./arch/xtensa/include/uapi ./arch/xtensa/include/asm ./arch/xtensa/include ./arch/xtensa/configs ./arch/xtensa/boot/lib ./arch/xtensa/boot/dts ./arch/xtensa/boot/boot-redboot ./arch/xtensa/boot/boot-elf ./arch/xtensa/boot ./arch/xtensa ./arch/sparc/video ./arch/sparc/vdso/vdso32 ./arch/sparc/vdso ./arch/sparc/prom ./arch/sparc/power ./arch/sparc/net ./arch/sparc/mm ./arch/sparc/math-emu ./arch/sparc/lib ./arch/sparc/kernel/syscalls ./arch/sparc/kernel ./arch/sparc/include/uapi/asm ./arch/sparc/include/uapi ./arch/sparc/include/asm ./arch/sparc/include ./arch/sparc/crypto ./arch/sparc/configs ./arch/sparc/boot ./arch/sparc ./arch/sh/tools ./arch/sh/mm ./arch/sh/math-emu ./arch/sh/lib ./arch/sh/kernel/vsyscall ./arch/sh/kernel/syscalls ./arch/sh/kernel/cpu/shmobile ./arch/sh/kernel/cpu/sh4a ./arch/sh/kernel/cpu/sh4 ./arch/sh/kernel/cpu/sh3 ./arch/sh/kernel/cpu/sh2a ./arch/sh/kernel/cpu/sh2 ./arch/sh/kernel/cpu/irq ./arch/sh/kernel/cpu ./arch/sh/kernel ./arch/sh/include/uapi/asm ./arch/sh/include/uapi ./arch/sh/include/mach-x3proto/mach ./arch/sh/include/mach-x3proto ./arch/sh/include/mach-sh03/mach ./arch/sh/include/mach-sh03 ./arch/sh/include/mach-se/mach ./arch/sh/include/mach-se ./arch/sh/include/mach-sdk7786/mach ./arch/sh/include/mach-sdk7786 ./arch/sh/include/mach-migor/mach ./arch/sh/include/mach-migor ./arch/sh/include/mach-landisk/mach ./arch/sh/include/mach-landisk ./arch/sh/include/mach-kfr2r09/mach ./arch/sh/include/mach-kfr2r09 ./arch/sh/include/mach-ecovec24/mach ./arch/sh/include/mach-ecovec24 ./arch/sh/include/mach-dreamcast/mach ./arch/sh/include/mach-dreamcast ./arch/sh/include/mach-common/mach ./arch/sh/include/mach-common ./arch/sh/include/cpu-sh4/cpu ./arch/sh/include/cpu-sh4a/cpu ./arch/sh/include/cpu-sh4a ./arch/sh/include/cpu-sh4 ./arch/sh/include/cpu-sh3/cpu ./arch/sh/include/cpu-sh3 ./arch/sh/include/cpu-sh2/cpu ./arch/sh/include/cpu-sh2a/cpu ./arch/sh/include/cpu-sh2a ./arch/sh/include/cpu-sh2 ./arch/sh/include/cpu-common/cpu ./arch/sh/include/cpu-common ./arch/sh/include/asm ./arch/sh/include ./arch/sh/drivers/pci ./arch/sh/drivers/dma ./arch/sh/drivers ./arch/sh/configs ./arch/sh/cchips/hd6446x ./arch/sh/cchips ./arch/sh/boot/romimage ./arch/sh/boot/dts ./arch/sh/boot/compressed ./arch/sh/boot ./arch/sh/boards/mach-x3proto ./arch/sh/boards/mach-sh7763rdp ./arch/sh/boards/mach-sh03 ./arch/sh/boards/mach-se/7780 ./arch/sh/boards/mach-se/7751 ./arch/sh/boards/mach-se/7724 ./arch/sh/boards/mach-se/7722 ./arch/sh/boards/mach-se/7721 ./arch/sh/boards/mach-se/770x ./arch/sh/boards/mach-se/7343 ./arch/sh/boards/mach-se/7206 ./arch/sh/boards/mach-se ./arch/sh/boards/mach-sdk7786 ./arch/sh/boards/mach-sdk7780 ./arch/sh/boards/mach-rsk ./arch/sh/boards/mach-r2d ./arch/sh/boards/mach-migor ./arch/sh/boards/mach-lboxre2 ./arch/sh/boards/mach-landisk ./arch/sh/boards/mach-kfr2r09 ./arch/sh/boards/mach-hp6xx ./arch/sh/boards/mach-highlander ./arch/sh/boards/mach-ecovec24 ./arch/sh/boards/mach-dreamcast ./arch/sh/boards/mach-ap325rxa ./arch/sh/boards ./arch/sh ./arch/s390/tools ./arch/s390/purgatory ./arch/s390/pci ./arch/s390/net ./arch/s390/mm ./arch/s390/lib ./arch/s390/kvm ./arch/s390/kernel/vdso64 ./arch/s390/kernel/vdso32 ./arch/s390/kernel/syscalls ./arch/s390/kernel/diag ./arch/s390/kernel ./arch/s390/include/uapi/asm ./arch/s390/include/uapi ./arch/s390/include/asm/vdso ./arch/s390/include/asm/trace ./arch/s390/include/asm ./arch/s390/include ./arch/s390/hypfs ./arch/s390/crypto ./arch/s390/configs ./arch/s390/boot ./arch/s390/appldata ./arch/s390 ./arch/powerpc/xmon ./arch/powerpc/tools ./arch/powerpc/sysdev/xive ./arch/powerpc/sysdev/xics ./arch/powerpc/sysdev/ge ./arch/powerpc/sysdev ./arch/powerpc/purgatory ./arch/powerpc/platforms/pseries ./arch/powerpc/platforms/ps3 ./arch/powerpc/platforms/powernv ./arch/powerpc/platforms/powermac ./arch/powerpc/platforms/pasemi ./arch/powerpc/platforms/microwatt ./arch/powerpc/platforms/embedded6xx ./arch/powerpc/platforms/chrp ./arch/powerpc/platforms/cell/spufs ./arch/powerpc/platforms/cell ./arch/powerpc/platforms/book3s ./arch/powerpc/platforms/amigaone ./arch/powerpc/platforms/8xx ./arch/powerpc/platforms/86xx ./arch/powerpc/platforms/85xx ./arch/powerpc/platforms/83xx ./arch/powerpc/platforms/82xx ./arch/powerpc/platforms/52xx ./arch/powerpc/platforms/512x ./arch/powerpc/platforms/44x ./arch/powerpc/platforms ./arch/powerpc/perf/req-gen ./arch/powerpc/perf ./arch/powerpc/net ./arch/powerpc/mm/ptdump ./arch/powerpc/mm/nohash ./arch/powerpc/mm/kasan ./arch/powerpc/mm/book3s64 ./arch/powerpc/mm/book3s32 ./arch/powerpc/mm ./arch/powerpc/math-emu ./arch/powerpc/lib ./arch/powerpc/kvm ./arch/powerpc/kexec ./arch/powerpc/kernel/vdso ./arch/powerpc/kernel/trace ./arch/powerpc/kernel/syscalls ./arch/powerpc/kernel/ptrace ./arch/powerpc/kernel ./arch/powerpc/include/uapi/asm ./arch/powerpc/include/uapi ./arch/powerpc/include/asm/vdso ./arch/powerpc/include/asm/nohash/64 ./arch/powerpc/include/asm/nohash/32 ./arch/powerpc/include/asm/nohash ./arch/powerpc/include/asm/book3s/64 ./arch/powerpc/include/asm/book3s/32 ./arch/powerpc/include/asm/book3s ./arch/powerpc/include/asm ./arch/powerpc/include ./arch/powerpc/crypto ./arch/powerpc/configs/85xx ./arch/powerpc/configs/83xx ./arch/powerpc/configs/52xx ./arch/powerpc/configs/44x ./arch/powerpc/configs ./arch/powerpc/boot/dts/fsl ./arch/powerpc/boot/dts ./arch/powerpc/boot ./arch/powerpc ./arch/parisc/video ./arch/parisc/net ./arch/parisc/mm ./arch/parisc/math-emu ./arch/parisc/lib ./arch/parisc/kernel/vdso64 ./arch/parisc/kernel/vdso32 ./arch/parisc/kernel/syscalls ./arch/parisc/kernel ./arch/parisc/include/uapi/asm ./arch/parisc/include/uapi ./arch/parisc/include/asm ./arch/parisc/include ./arch/parisc/configs ./arch/parisc/boot/compressed ./arch/parisc/boot ./arch/parisc ./arch/nios2/platform ./arch/nios2/mm ./arch/nios2/lib ./arch/nios2/kernel ./arch/nios2/include/uapi/asm ./arch/nios2/include/uapi ./arch/nios2/include/asm ./arch/nios2/include ./arch/nios2/configs ./arch/nios2/boot/dts ./arch/nios2/boot/compressed ./arch/nios2/boot ./arch/nios2 ./arch/microblaze/pci ./arch/microblaze/mm ./arch/microblaze/lib ./arch/microblaze/kernel/syscalls ./arch/microblaze/kernel/cpu ./arch/microblaze/kernel ./arch/microblaze/include/uapi/asm ./arch/microblaze/include/uapi ./arch/microblaze/include/asm ./arch/microblaze/include ./arch/microblaze/configs ./arch/microblaze/boot/dts ./arch/microblaze/boot ./arch/microblaze ./arch/m68k/virt ./arch/m68k/tools/amiga ./arch/m68k/tools ./arch/m68k/sun3x ./arch/m68k/sun3/prom ./arch/m68k/sun3 ./arch/m68k/q40 ./arch/m68k/mvme16x ./arch/m68k/mvme147 ./arch/m68k/mm ./arch/m68k/math-emu ./arch/m68k/mac ./arch/m68k/lib ./arch/m68k/kernel/syscalls ./arch/m68k/kernel ./arch/m68k/include/uapi/asm ./arch/m68k/include/uapi ./arch/m68k/include/asm ./arch/m68k/include ./arch/m68k/ifpsp060/src ./arch/m68k/ifpsp060 ./arch/m68k/hp300 ./arch/m68k/fpsp040 ./arch/m68k/emu ./arch/m68k/configs ./arch/m68k/coldfire ./arch/m68k/bvme6000 ./arch/m68k/atari ./arch/m68k/apollo ./arch/m68k/amiga ./arch/m68k/68000 ./arch/m68k ./arch/hexagon/mm ./arch/hexagon/lib ./arch/hexagon/kernel ./arch/hexagon/include/uapi/asm ./arch/hexagon/include/uapi ./arch/hexagon/include/asm ./arch/hexagon/include ./arch/hexagon/configs ./arch/hexagon ./arch/csky/mm ./arch/csky/lib ./arch/csky/kernel/vdso ./arch/csky/kernel/probes ./arch/csky/kernel ./arch/csky/include/uapi/asm ./arch/csky/include/uapi ./arch/csky/include/asm ./arch/csky/include ./arch/csky/configs ./arch/csky/boot/dts ./arch/csky/boot ./arch/csky/abiv2/inc/abi ./arch/csky/abiv2/inc ./arch/csky/abiv2 ./arch/csky/abiv1/inc/abi ./arch/csky/abiv1/inc ./arch/csky/abiv1 ./arch/csky ./arch/arc/plat-tb10x ./arch/arc/plat-sim ./arch/arc/plat-hsdk ./arch/arc/plat-axs10x ./arch/arc/net ./arch/arc/mm ./arch/arc/lib ./arch/arc/kernel ./arch/arc/include/uapi/asm ./arch/arc/include/uapi ./arch/arc/include/asm ./arch/arc/include ./arch/arc/configs ./arch/arc/boot/dts ./arch/arc/boot ./arch/arc ./arch/alpha/mm ./arch/alpha/math-emu ./arch/alpha/lib ./arch/alpha/kernel/syscalls ./arch/alpha/kernel ./arch/alpha/include/uapi/asm ./arch/alpha/include/uapi ./arch/alpha/include/asm ./arch/alpha/include ./arch/alpha/configs ./arch/alpha/boot/tools ./arch/alpha/boot ./arch/alpha
rm -f  -- ./CREDITS ./drivers/char/hw_random/s390-trng.c ./drivers/iommu/s390-iommu.c ./drivers/net/clf ./drivers/net/clf/base.h ./drivers/net/clf/clf.c ./drivers/net/clf/cmd.c ./drivers/net/clf/cmd.h ./drivers/net/clf/dev.c ./drivers/net/clf/io.c ./drivers/net/clf/Kconfig ./drivers/net/clf/Makefile ./drivers/net/clf/paths.h ./drivers/net/clf/pkt.h ./drivers/net/clf/types.h ./drivers/net/NOTES.txt ./drivers/net/xgw ./drivers/net/xgw/alloc.c ./drivers/net/xgw/arp.c ./drivers/net/xgw/asserts.c ./drivers/net/xgw/base.h ./drivers/net/xgw/beep.c ./drivers/net/xgw/cmd_args_types.h ./drivers/net/xgw/cmd.c ./drivers/net/xgw/cmd_codes.h ./drivers/net/xgw/cmd_errs.h ./drivers/net/xgw/cmd_names.c ./drivers/net/xgw/cmd_sizes.c ./drivers/net/xgw/crypto.c ./drivers/net/xgw/crypto.h ./drivers/net/xgw/dev.c ./drivers/net/xgw/dhcp.c ./drivers/net/xgw/dhcp.h ./drivers/net/xgw/in.c ./drivers/net/xgw/in_discover.c ./drivers/net/xgw/Kconfig ./drivers/net/xgw/kconfig.h ./drivers/net/xgw/keeper.c ./drivers/net/xgw/Makefile ./drivers/net/xgw/nodes.h ./drivers/net/xgw/out.c ./drivers/net/xgw/ping.c ./drivers/net/xgw/ping.h ./drivers/net/xgw/pkt_encap.c ./drivers/net/xgw/pkt.h ./drivers/net/xgw/pkt_skels.c ./drivers/net/xgw/ports.c ./drivers/net/xgw/ports.h ./drivers/net/xgw/random.c ./drivers/net/xgw/random.h ./drivers/net/xgw/stats.c ./drivers/net/xgw/stats.h ./drivers/net/xgw/TODO.txt ./drivers/net/xgw/types.h ./drivers/net/xgw/xgw.c ./drivers/net/xgw/xgw.py ./drivers/pci/hotplug/s390_pci_hpc.c ./drivers/ptp/ptp_s390.c ./drivers/watchdog/booke_wdt.c ./drivers/watchdog/diag288_wdt.c ./drivers/watchdog/gef_wdt.c ./drivers/watchdog/m54xx_wdt.c ./drivers/watchdog/mena21_wdt.c ./drivers/watchdog/mpc8xxx_wdt.c ./drivers/watchdog/of_xilinx_wdt.c ./drivers/watchdog/pika_wdt.c ./drivers/watchdog/pseries-wdt.c ./drivers/watchdog/wdrtas.c ./drivers/watchdog/xilinx_wwdt.c ./include/net/mptcp.h ./include/net/udplite.h ./include/trace/events/mptcp.h ./include/uapi/linux/mptcp.h ./include/uapi/linux/mptcp_pm.h ./Kconfig2 ./Kconfig-sysctl ./lib/raid6/recov_s390xc.c ./lib/raid6/s390vx.uc ./MAINTAINERS ./MAKEPATCH ./net/ipv4/tcp_fastopen.c ./net/ipv4/udplite.c ./net/ipv6/udplite.c ./scripts/dtc/include-prefixes/arc ./scripts/dtc/include-prefixes/microblaze ./scripts/dtc/include-prefixes/nios2 ./scripts/dtc/include-prefixes/powerpc ./scripts/dtc/include-prefixes/sh ./scripts/dtc/include-prefixes/xtensa ./security/integrity/platform_certs/load_ipl_s390.c ./TODO ./tools/include/nolibc/arch-s390.h ./tools/perf/util/perf-regs-arch/perf_regs_csky.c ./tools/perf/util/perf-regs-arch/perf_regs_powerpc.c ./tools/perf/util/perf-regs-arch/perf_regs_s390.c ./tools/perf/util/s390-cpumcf-kernel.h ./tools/perf/util/s390-cpumsf.c ./tools/perf/util/s390-cpumsf.h ./tools/perf/util/s390-cpumsf-kernel.h ./tools/perf/util/s390-sample-raw.c ./tools/testing/kunit/qemu_configs/s390.py
patch -p1 < "${0}"
x=$?
rm -f -- $(find . -type f -iname "*.orig")
exit $x
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/crypto/Kconfig linux-master/crypto/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/crypto/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/crypto/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -1430,18 +1430,9 @@
 if MIPS
 source "arch/mips/crypto/Kconfig"
 endif
-if PPC
-source "arch/powerpc/crypto/Kconfig"
-endif
 if RISCV
 source "arch/riscv/crypto/Kconfig"
 endif
-if S390
-source "arch/s390/crypto/Kconfig"
-endif
-if SPARC
-source "arch/sparc/crypto/Kconfig"
-endif
 if X86
 source "arch/x86/crypto/Kconfig"
 endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/acpi/Kconfig linux-master/drivers/acpi/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/acpi/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/acpi/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -274,8 +274,7 @@
 	depends on X86
 
 config ACPI_PROCESSOR_IDLE
-	bool
-	select CPU_IDLE
+	bool "ACPI_PROCESSOR_IDLE"
 
 config ACPI_MCFG
 	bool
@@ -296,7 +295,6 @@
 config ACPI_PROCESSOR
 	tristate "Processor"
 	depends on X86 || ARM64 || LOONGARCH || RISCV
-	select ACPI_PROCESSOR_IDLE
 	select ACPI_CPU_FREQ_PSS if X86 || LOONGARCH
 	select THERMAL
 	default y
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/base/firmware_loader/main.c linux-master/drivers/base/firmware_loader/main.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/base/firmware_loader/main.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/base/firmware_loader/main.c	2025-10-20 00:41:14.000000000 -0300
@@ -566,7 +566,7 @@
 		size = rc;
 		rc = 0;
 
-		dev_dbg(device, "Loading firmware from %s\n", path);
+		printk("Loading firmware from %s\n", path);
 		if (decompress) {
 			dev_dbg(device, "f/w decompressing %s\n",
 				fw_priv->fw_name);
@@ -842,6 +842,7 @@
 		goto out;
 	}
 
+	printk("Loading firmware \"%s\"\n", name);
 
 	/*
 	 * Reject firmware file names with ".." path components.
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/block/Kconfig linux-master/drivers/block/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/block/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/block/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -271,8 +271,6 @@
 	  Support for virtual disk devices as a client under Sun
 	  Logical Domains.
 
-source "drivers/s390/block/Kconfig"
-
 config XEN_BLKDEV_FRONTEND
 	tristate "Xen virtual block device support"
 	depends on XEN
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/char/hw_random/Makefile linux-master/drivers/char/hw_random/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/char/hw_random/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/char/hw_random/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -41,7 +41,6 @@
 obj-$(CONFIG_HW_RANDOM_MESON) += meson-rng.o
 obj-$(CONFIG_HW_RANDOM_CAVIUM) += cavium-rng.o cavium-rng-vf.o
 obj-$(CONFIG_HW_RANDOM_MTK)	+= mtk-rng.o
-obj-$(CONFIG_HW_RANDOM_S390) += s390-trng.o
 obj-$(CONFIG_HW_RANDOM_KEYSTONE) += ks-sa-rng.o
 obj-$(CONFIG_HW_RANDOM_OPTEE) += optee-rng.o
 obj-$(CONFIG_HW_RANDOM_NPCM) += npcm-rng.o
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/char/Kconfig linux-master/drivers/char/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/char/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/char/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -378,7 +378,7 @@
 
 config HANGCHECK_TIMER
 	tristate "Hangcheck timer"
-	depends on X86 || PPC64 || S390
+	depends on X86 || PPC64
 	help
 	  The hangcheck-timer module detects when the system has gone
 	  out to lunch past a certain margin.  It can reboot the system
@@ -407,8 +407,6 @@
 	  /sys/devices/faux/telco_clock, with a number of files for
 	  controlling the behavior of this hardware.
 
-source "drivers/s390/char/Kconfig"
-
 source "drivers/char/xillybus/Kconfig"
 
 config ADI
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/iommu/Kconfig linux-master/drivers/iommu/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/iommu/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/iommu/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -314,13 +314,6 @@
 
 	  Say Y here if you are using an Apple SoC.
 
-config S390_IOMMU
-	def_bool y if S390 && PCI
-	depends on S390 && PCI
-	select IOMMU_API
-	help
-	  Support for the IOMMU API for s390 PCI devices.
-
 config MTK_IOMMU
 	tristate "MediaTek IOMMU Support"
 	depends on ARCH_MEDIATEK || COMPILE_TEST
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/iommu/Makefile linux-master/drivers/iommu/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/iommu/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/iommu/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -27,7 +27,6 @@
 obj-$(CONFIG_TEGRA_IOMMU_SMMU) += tegra-smmu.o
 obj-$(CONFIG_EXYNOS_IOMMU) += exynos-iommu.o
 obj-$(CONFIG_FSL_PAMU) += fsl_pamu.o fsl_pamu_domain.o
-obj-$(CONFIG_S390_IOMMU) += s390-iommu.o
 obj-$(CONFIG_HYPERV_IOMMU) += hyperv-iommu.o
 obj-$(CONFIG_VIRTIO_IOMMU) += virtio-iommu.o
 obj-$(CONFIG_IOMMU_SVA) += iommu-sva.o
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/Kconfig linux-master/drivers/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -55,8 +55,6 @@
 
 source "drivers/message/fusion/Kconfig"
 
-source "drivers/firewire/Kconfig"
-
 source "drivers/macintosh/Kconfig"
 
 source "drivers/net/Kconfig"
@@ -129,8 +127,6 @@
 
 source "drivers/accessibility/Kconfig"
 
-source "drivers/infiniband/Kconfig"
-
 source "drivers/edac/Kconfig"
 
 source "drivers/rtc/Kconfig"
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/Makefile linux-master/drivers/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -92,7 +92,6 @@
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
-obj-y				+= firewire/
 obj-$(CONFIG_UIO)		+= uio/
 obj-$(CONFIG_VFIO)		+= vfio/
 obj-y				+= cdrom/
@@ -133,7 +132,6 @@
 obj-y				+= mmc/
 obj-y				+= ufs/
 obj-$(CONFIG_MEMSTICK)		+= memstick/
-obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-y				+= firmware/
 obj-$(CONFIG_FWCTL)		+= fwctl/
 obj-$(CONFIG_CRYPTO)		+= crypto/
@@ -196,4 +194,3 @@
 obj-$(CONFIG_DPLL)		+= dpll/
 
 obj-$(CONFIG_DIBS)		+= dibs/
-obj-$(CONFIG_S390)		+= s390/
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/media/Kconfig linux-master/drivers/media/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/media/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/media/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -234,8 +234,6 @@
 source "drivers/media/test-drivers/Kconfig"
 endif
 
-source "drivers/media/firewire/Kconfig"
-
 # Common driver options
 source "drivers/media/common/Kconfig"
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/media/Makefile linux-master/drivers/media/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/media/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/media/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -29,6 +29,6 @@
 # Finally, merge the drivers that require the core
 #
 
-obj-y += common/ platform/ pci/ usb/ mmc/ firewire/ spi/ test-drivers/
+obj-y += common/ platform/ pci/ usb/ mmc/ spi/ test-drivers/
 obj-$(CONFIG_VIDEO_DEV) += radio/
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/base.h linux-master/drivers/net/clf/base.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/base.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/base.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,97 @@
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/net.h>
+#include <linux/if_ether.h>
+#include <linux/in.h>
+#include <net/ip.h>
+#include <net/inet_common.h>
+#include <linux/proc_fs.h>
+#ifdef CONFIG_CLF_BEEP
+#include <linux/i8253.h>
+#endif
+
+#define ___JOIN(a, b) a ## b
+#define SUFFIX_ULL(l) ___JOIN(l, ULL)
+#define SUFFIX_U(l)   ___JOIN(l, U)
+
+#define __noinline __attribute__((noinline))
+#define __cold_as_ice __attribute__((cold))
+
+#if defined(__clang__)
+#define __optimize_size
+#elif defined(__GNUC__)
+#define __optimize_size __attribute__((optimize("Os")))
+#endif
+
+#define ETH_SIZE 14 // ETH_HLEN
+#define IP4_SIZE 20 // sizeof(struct iphdr)
+#define IP6_SIZE 40 // sizeof(struct ipv6hdr)
+#define TCP_SIZE 20 // sizeof(struct tcphdr)
+#define UDP_SIZE  8 // sizeof(struct udphdr)
+
+#define popcount(x) \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x),  int  ), __builtin_popcount(x),   \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x), uint  ), __builtin_popcount(x),   \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x),  intll), __builtin_popcountll(x), \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x), uintll), __builtin_popcountll(x), \
+    __builtin_choose_expr(                    sizeof(x) <= sizeof(uint),   __builtin_popcount(x),   \
+                                                                           __builtin_popcountll(x))))))
+
+#define __ctz(x) \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x),  int  ), __builtin_ctz(x),   \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x), uint  ), __builtin_ctz(x),   \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x),  intll), __builtin_ctzll(x), \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x), uintll), __builtin_ctzll(x), \
+    __builtin_choose_expr(                    sizeof(x) <= sizeof(uint),   __builtin_ctz(x),   \
+                                                                           __builtin_ctzll(x))))))
+
+typedef __u8   u8;
+typedef __u16 u16;
+typedef __u32 u32;
+typedef __u64 u64;
+
+typedef __s64 s64;
+
+typedef          long long int intll;
+typedef unsigned long long int uintll;
+
+typedef atomic_t atomic32_t;
+
+typedef struct sk_buff        skb_s;
+typedef struct net_device     net_device_s;
+typedef struct net            net_s;
+typedef struct header_ops     header_ops_s;
+typedef struct net_device_ops net_device_ops_s;
+
+#define SKB_USERS(skb) refcount_read(&(skb)->users)
+
+#define SKB_HEAD(skb)      PTR((skb)->head)
+#define SKB_DATA(skb)      PTR((skb)->data)
+#define SKB_TAIL(skb)      PTR(skb_tail_pointer(skb))
+#define SKB_END(skb)       PTR(skb_end_pointer(skb))
+#define SKB_MAC(skb)       PTR(skb_mac_header(skb))
+#define SKB_NETWORK(skb)   PTR(skb_network_header(skb))
+#define SKB_TRANSPORT(skb) PTR(skb_transport_header(skb))
+
+#define PTR(p) ((void*)(p))
+
+#define loop while(1)
+
+#define elif else if
+
+#define for_count(i, count) for (typeof(count) i = 0, __q = (count); i != __q; i++)
+
+#define BE8(x)  (x)
+#ifdef __BIG_ENDIAN
+#define BE16(x) (x)
+#define BE32(x) (x)
+#define BE64(x) (x)
+#else
+#define BE16(x) ((u16)__builtin_bswap16((u16)(x)))
+#define BE32(x) ((u32)__builtin_bswap32((u32)(x)))
+#define BE64(x) ((u64)__builtin_bswap64((u64)(x)))
+#endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/clf.c linux-master/drivers/net/clf/clf.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/clf.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/clf.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,51 @@
+
+#include "pkt.h"
+#include "paths.h"
+#include "cmd.h"
+
+DEFINE_SPINLOCK(xlock);
+
+static uint opaths;
+static path_s paths[PATHS_N];
+
+#include "io.c"
+#include "cmd.c"
+
+static struct proc_ops procOps = {
+    .proc_write = cmd,
+};
+
+static int __init clf_init (void) {
+
+    //
+    BUILD_ASSERT( ( ((uintptr_t)0xffffffffffffffffULL) & (~(uintptr_t)1) ) == (0xffffffffffffffffULL ^ 1) );
+
+    printk("CLF: INIT\n");
+
+    // INITIALIZE EVERYTHING
+    opaths = 0;
+
+    memset((void*)paths,  0, sizeof(ports));
+//    memset((void*)nodes,  0, sizeof(nodes));
+
+    // CREATE THE VIRTUAL INTERFACE
+    clf = alloc_netdev(0, "clf", NET_NAME_USER, dev_setup);
+
+    if (clf == NULL) {
+        printk("CLF: FAILED TO ALLOCATE\n");
+        return -1;
+    }
+
+    // MAKE IT VISIBLE IN THE SYSTEM
+    if (register_netdev(clf)) {
+        printk("CLF: CREATE FAILED TO REGISTER\n");
+        return -1;
+    }
+
+    // EXPOSE CMD
+    proc_create("clf", 0600, NULL, &procOps);
+
+    return 0;
+}
+
+late_initcall(clf_init);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/cmd.c linux-master/drivers/net/clf/cmd.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/cmd.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/cmd.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,219 @@
+
+static ssize_t __cold_as_ice __optimize_size cmd (struct file *file, const char __user *ubuf, size_t size, loff_t *ppos) {
+
+    cmd_s cmd;
+
+    //
+    if (size != sizeof(cmd_s))
+        return -ESIZE;
+    
+    if (copy_from_user(&cmd, ubuf, size))
+        return -EINVAL;
+
+    net_device_s* phys = NULL;
+    
+    const uint code = cmd->code;
+    const uint pid  = cmd->pid;
+
+    // VALIDATE COMMAND
+    if (code >= CMDS_N)
+        return -EINVAL;
+    
+    // VALIDATE PATH
+    if (pid >= PATHS_N)
+        return -EINVAL;
+
+    switch (code) {
+        case CMD_PATH_PHYS_SET:
+            // MUST HAVE A VALID NAME
+            if (!cmd->phys[0] ||
+                 cmd->phys[IFNAMSIZ - 1])
+                return -EINVAL;
+            // LOOKUP IT, OWNED
+            phys = dev_get_by_name(&init_net, cmd->phys);
+            // MUST EXIST
+            if (phys == NULL)
+                return -ENODEV;
+            // CANNOT BE THE VPN ITSELF
+            if (phys == clf)
+                return -EINVAL;
+    }
+    
+    // LOCK CLF
+    unsigned long iflags;
+
+    spin_lock_irqsave(&xlock, iflags);
+
+    path_s* const path = &paths[pid];
+
+    switch (code) {
+
+        case CMD_PATH_ON:
+
+            printk("CLF: PATH %u: ON\n", pid);
+
+            __atomic_store_n(&opaths, opaths | (0x00010001U << pid), __ATOMIC_SEQ_CST);
+
+            break;
+
+        case CMD_PATH_OFF:
+
+            printk("CLF: PATH %u: OFF\n", pid);
+
+            __atomic_store_n(&opaths, opaths & ~(0x00010001U << pid), __ATOMIC_SEQ_CST);
+
+            break;
+
+        case CMD_PATH_PHYS_SET:
+
+            ASSERT(phys != NULL);
+
+            printk("CLF: PATH %u: PHYS %s\n", phys->name);
+			
+            // USE IT
+            phys = __atomic_exchange_n(&path->phys, phys, __ATOMIC_SEQ_CST);
+
+            // WILL REMEMBER THE NEW
+            // WILL RELEASE THE OLD
+
+            break;
+
+        case CMD_PATH_PHYS_CLR:
+
+            printk("CLF: PATH %u: PHYS CLEAR\n", pid);
+
+            ASSERT(phys == NULL);
+
+            //
+            __atomic_store_n(&opaths, opaths & ~(0x00010001U << pid), __ATOMIC_SEQ_CST);
+
+            //
+            phys = __atomic_exchange_n(&path->phys, NULL, __ATOMIC_SEQ_CST);
+
+            // WILL RELEASE THE OLD
+
+            break;
+
+        case CMD_PATH_PRINT:
+
+            printk("CLF: PATH %u ENABLED %d\n", pid, !!(opaths & (1U << pid)));
+            printk("CLF: PATH %u PHYS %s\n",               pid, path->phys ? path->phys->name : "");
+            printk("CLF: PATH %u SKB MAC LEN %u\n",        pid, (uint)path->mac_len);
+            printk("CLF: PATH %u SKB PROTOCOL 0x%04X\n",   pid, (uint)path->protocol);
+            printk("CLF: PATH %u SKB ENCAP TYPE %u\n",     pid, (uint)path->eType);
+            printk("CLF: PATH %u SKB ENCAP SIZE %u\n",     pid, (uint)path->eSize);
+            printk("CLF: PATH %u SKB ENCAP E OFFSET %u\n", pid, (uint)path->eOffset);
+            printk("CLF: PATH %u SKB ENCAP N OFFSET %u\n", pid, (uint)path->nOffset);
+
+            break;
+
+        case CMD_PATH_ENCAP_RAW:
+
+            memset(&path->encap, 0, ENCAP_SIZE);
+
+            path->eType    = ENCAP_TYPE_RAW;
+            path->eSize    = ENCAP_SIZE_RAW;
+            path->eOffset  = ENCAP_OFFSET_RAW;
+            path->nOffset  = ENCAP_SIZE_RAW;
+            path->pWord    = 0;
+            path->protocol = BE16(ETH_P_IP);
+            path->mac_len  = 0;
+
+            break;
+
+        case CMD_PATH_ENCAP_ETH:
+
+            memcpy(&path->encap, &cmd->encap, ENCAP_SIZE);
+
+            path->eType    = ENCAP_TYPE_ETH;
+            path->eSize    = ENCAP_SIZE_ETH;
+            path->eOffset  = ENCAP_OFFSET_ETH;
+            path->nOffset  = ENCAP_SIZE_ETH;
+            path->pWord    = 0;
+            path->protocol = BE16(ETH_P_IP);
+            path->mac_len  = ETH_HLEN;
+            path->encap.eth.eProto = BE16(ETH_P_IP);
+
+            break;
+
+        case CMD_PATH_ENCAP_ETH_VLAN:
+
+            memcpy(&path->encap, &cmd->encap, ENCAP_SIZE);
+
+            path->eType    = ENCAP_TYPE_ETH_VLAN;
+            path->eSize    = ENCAP_SIZE_ETH_VLAN;
+            path->eOffset  = ENCAP_OFFSET_ETH_VLAN;
+            path->nOffset  = ENCAP_OFFSET_ETH_VLAN + ETH_HLEN;
+            path->pWord    = 0;
+            path->protocol = BE16(ETH_P_8021Q);
+            path->mac_len  = ETH_HLEN;
+            path->encap.eth_vlan.eProto = BE16(ETH_P_8021Q);
+            path->encap.eth_vlan.vProto = BE16(ETH_P_IP);
+
+            break;
+
+        case CMD_PATH_ENCAP_ETH_VLAN_PPP:
+
+            memcpy(&path->encap, &cmd->encap, ENCAP_SIZE);
+
+            path->eType    = ENCAP_TYPE_ETH_VLAN_PPP;
+            path->eSize    = ENCAP_SIZE_ETH_VLAN_PPP;
+            path->eOffset  = ENCAP_OFFSET_ETH_VLAN_PPP;
+            path->nOffset  = ENCAP_OFFSET_ETH_VLAN_PPP + ETH_HLEN;
+            path->pWord    = offsetof(encap_eth_vlan_ppp_s, pSize) / sizeof(u16);
+            path->protocol = BE16(ETH_P_8021Q);
+            path->mac_len  = ETH_HLEN;
+            path->encap.eth_vlan_ppp.eProto = BE16(ETH_P_8021Q);
+            path->encap.eth_vlan_ppp.vProto = BE16(ETH_P_PPP_SES);
+            path->encap.eth_vlan_ppp.pProto = BE16(0x0021);
+
+            break;
+
+        case CMD_PATH_ENCAP_ETH_PPP:
+
+            memcpy(&path->encap, &cmd->encap, ENCAP_SIZE);
+
+            path->eType    = ENCAP_TYPE_ETH_PPP;
+            path->eSize    = ENCAP_SIZE_ETH_PPP;
+            path->eOffset  = ENCAP_OFFSET_ETH_PPP;
+            path->nOffset  = ENCAP_OFFSET_ETH_PPP + ETH_HLEN;
+            path->pWord    = offsetof(encap_eth_ppp_s, pSize) / sizeof(u16);
+            path->protocol = BE16(ETH_P_PPP_SES);
+            path->mac_len  = ETH_HLEN;
+            path->encap.eth_ppp.eProto = BE16(ETH_P_PPP_SES);
+            path->encap.eth_ppp.pProto = BE16(0x0021);
+
+            break;
+
+        case CMD_PATH_ENCAP_ETH_VLAN_PPP_SESSION:
+
+            ASSERT(path->eType == ENCAP_TYPE_ETH_VLAN_PPP);
+
+            const uint session = cmd->encap.eth_vlan_ppp.pSession;
+                                path->encap.eth_vlan_ppp.pSession = BE16(session);
+
+            printk("CLF: PATH %u: PPP SESSION SET TO 0x%04X\n", pid, session);
+
+            break;
+
+        case CMD_PATH_ENCAP_ETH_PPP_SESSION:
+
+            ASSERT(path->eType == ENCAP_TYPE_ETH_PPP);
+
+            const uint session = cmd->encap.eth_ppp.pSession;
+                                path->encap.eth_ppp.pSession = BE16(session);
+
+            printk("CLF: PATH %u: PPP SESSION SET TO 0x%04X\n", pid, session);
+            
+            break;
+    }
+
+    // FORGET THE PHYSICAL DEVICE
+    if (phys)
+        dev_put(phys);
+
+    // UNLOCK CLF
+    spin_unlock_irqrestore(&xlock, iflags);
+
+    return sizeof(cmd_s);
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/cmd.h linux-master/drivers/net/clf/cmd.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/cmd.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/cmd.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,27 @@
+
+// COMMANDS
+enum CMDS {
+    CMD_PATH_ON,
+    CMD_PATH_OFF,
+    CMD_PATH_PRINT,
+    CMD_PATH_PHYS_SET,
+    CMD_PATH_PHYS_CLR,
+    CMD_PATH_ENCAP_RAW,
+    CMD_PATH_ENCAP_ETH,
+    CMD_PATH_ENCAP_ETH_VLAN,
+    CMD_PATH_ENCAP_ETH_VLAN_PPP,
+    CMD_PATH_ENCAP_ETH_VLAN_PPP_SESSION,
+    CMD_PATH_ENCAP_ETH_PPP,
+    CMD_PATH_ENCAP_ETH_PPP_SESSION,
+};
+
+#define CMD_SIZE 64
+
+struct cmd_s {
+    u8 code;
+    u8 pid;
+    char phys [30];
+    encap_s encap;
+};
+
+BUILD_ASSERT(sizeof(cmd_s) == CMD_SIZE);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/dev.c linux-master/drivers/net/clf/dev.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/dev.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/dev.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,64 @@
+
+static int __cold_as_ice __optimize_size dev_up (net_device_s* const dev) {
+
+    printk("CLF: UP\n");
+
+    return 0;
+}
+
+static int __cold_as_ice __optimize_size dev_down (net_device_s* const dev) {
+
+    printk("CLF: DOWN\n");
+
+    return 0;
+}
+
+static const net_device_ops_s clfDevOps = {
+    .ndo_init             =  NULL,
+    .ndo_open             =  dev_up,
+    .ndo_stop             =  dev_down,
+    .ndo_start_xmit       =  out,
+    .ndo_set_mac_address  =  NULL,
+    // TODO: SET MTU - NAO EH PARA SETAR AQUI E SIM NO ROUTE
+};
+
+static void __cold_as_ice __optimize_size dev_setup (net_device_s* const dev) {
+
+    dev->netdev_ops      = &clfDevOps;
+    dev->header_ops      = NULL;
+    dev->type            = ARPHRD_NONE;
+    dev->addr_len        = 0; // TODO: 2 nodeSelf ?
+    dev->hard_header_len = 0;
+//    dev->min_header_len  = 0;
+    dev->needed_headroom = CLF_HEADROOM;
+    dev->min_mtu         = CLF_PAYLOAD_MIN;
+    dev->max_mtu         = CLF_PAYLOAD_MAX;
+    dev->mtu             = CLF_PAYLOAD_MAX;
+    dev->tx_queue_len    = 0; // DEFAULT_TX_QUEUE_LEN
+    dev->flags           = 0
+        | IFF_POINTOPOINT
+        | IFF_NOARP
+        ;
+    dev->priv_flags |= 0
+        | IFF_NO_QUEUE
+        | IFF_NO_RX_HANDLER
+        | IFF_LIVE_ADDR_CHANGE
+        ;
+    dev->lltx = true; // dev->features |= NETIF_F_LLTX
+    dev->features |= 0
+        | NETIF_F_RXCSUM
+        | NETIF_F_HW_CSUM
+#if 0
+        | NETIF_F_HIGHDMA
+#endif
+        ;
+    dev->hw_features |= 0
+        | NETIF_F_RXCSUM
+        | NETIF_F_HW_CSUM
+#if 0
+        | NETIF_F_HIGHDMA
+#endif
+        ;
+    // TODO: hw_enc_features ?
+    //
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/io.c linux-master/drivers/net/clf/io.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/io.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/io.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,80 @@
+
+static netdev_tx_t out (skb_s* const skb, net_device_s* const dev) {
+
+    ASSERT(dev == clf);
+
+    if (skb_is_nonlinear(skb))
+        goto _drop;
+
+    pkt_s* const pkt = SKB_NETWORK(skb) - offsetof(pkt_s, iVersion);
+
+    // CURRENT PATH ID BEING USED
+    const uint oid = skb->mark % PATHS_N;
+
+    const uint sid = __ctz((opaths >> oid) << oid) % PATHS_N;
+
+    path_s* const path = &paths[sid];
+
+    ASSERT(path->phys);
+    ASSERT(path->eSize == (sizeof(path->encap) - path->eOffset));
+    ASSERT(path->eSize <= ENCAP_SIZE);
+    ASSERT(path->nOffset >= ENCAP_SIZE);
+    ASSERT(path->eOffset <= path->nOffset);
+
+    if ((PTR(&pkt->encap) + path->eOffset) < SKB_HEAD(skb))
+        goto _drop;
+
+    // COPY THE ENCAPSULEMENT
+    memcpy(PTR(&pkt->encap) + path->eOffset,
+           PTR(&path->encap) + path->eOffset,
+         sizeof(path->encap) - path->eOffset);
+
+    // ADJUST DYNAMIC ENCAPSULEMENT FIELDS
+    if (path->pword)
+          pkt->encap.w16[path->pword] = BE16(skb->len + 2);
+
+    // TODO: ADJUST LOCAL PORT ACORDING TO MARK
+
+    // IP CHECKSUM
+
+    // UDP CHECKSUM
+    pkt->uChk = BE16(0);
+
+    //
+    skb->dev = path->phys;
+    skb->mark = 0;
+    skb->len      += path->eSize;
+    skb->mac_len   = path->mac_len;
+    skb->protocol  = path->protocol;
+
+    // skb_set_mac_header / skb_reset_mac_header
+    // skb_set_network_header / skb_reset_network_header
+#ifdef NET_SKBUFF_DATA_USES_OFFSET
+    skb->mac_header       = (PTR(pkt) + path->eOffset) - SKB_HEAD(skb);
+    skb->network_header   = (PTR(pkt) + path->nOffset) - SKB_HEAD(skb);
+#else
+    skb->mac_header       =  PTR(pkt) + path->eOffset;
+    skb->network_header   =  PTR(pkt) + path->nOffset;
+#endif
+    skb->data             =  PTR(pkt) + path->eOffset;
+
+#if 1
+    if (skb->ip_summed == CHECKSUM_PARTIAL)
+        if (skb_checksum_help(skb))
+            goto _drop;
+#else
+    skb->ip_summed = CHECKSUM_NONE;
+#endif
+
+    // -- THE FUNCTION CAN BE CALLED FROM AN INTERRUPT
+    // -- WHEN CALLING THIS METHOD, INTERRUPTS MUST BE ENABLED
+    dev_queue_xmit(skb);
+    // -- REGARDLESS OF THE RETURN VALUE, THE SKB IS CONSUMED
+
+    return NETDEV_TX_OK;
+
+_drop:
+    dev_kfree_skb(skb);
+
+    return NETDEV_TX_OK;
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/Kconfig linux-master/drivers/net/clf/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/Kconfig	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,30 @@
+
+menuconfig CLF
+    bool  "CLF"
+    default n
+
+if CLF
+
+    config    CLF_ASSERT
+        bool "CLF_ASSERT"
+        default n
+
+    config    CLF_DEBUG
+        bool "CLF_DEBUG"
+        default n
+
+    config    CLF_BEEP
+        bool "CLF_BEEP"
+        default n
+
+    config   CLF_BEEP_BASE
+        int "CLF_BEEP_BASE"
+        default 2000
+        depends on CLF_BEEP
+
+    config   CLF_BEEP_MAX
+        int "CLF_BEEP_MAX"
+        default 2500
+        depends on CLF_BEEP
+
+endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/Makefile linux-master/drivers/net/clf/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,23 @@
+
+CFLAGS_clf.o += -Wfatal-errors
+CFLAGS_clf.o += -Werror
+CFLAGS_clf.o += -Wall
+CFLAGS_clf.o += -Wextra
+CFLAGS_clf.o += -Wno-declaration-after-statement
+CFLAGS_clf.o += -Wno-missing-declarations
+CFLAGS_clf.o += -Wno-missing-prototypes
+CFLAGS_clf.o += -Wno-error=sign-compare
+CFLAGS_clf.o += -Wno-error=unused-parameter
+CFLAGS_clf.o += -Wno-error=unused-function
+CFLAGS_clf.o += -Wno-error=unused-label
+CFLAGS_clf.o += -Wno-error=unused-variable
+CFLAGS_clf.o += -Wno-error=date-time
+CFLAGS_clf.o += -Wno-type-limits
+CFLAGS_clf.o += -Wno-unused-parameter
+
+CFLAGS_clf.o += -Wno-sign-compare
+
+# -moutline-atomics
+# -mno-outline-atomics
+
+obj-$(CONFIG_CLF) += clf.o
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/paths.h linux-master/drivers/net/clf/paths.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/paths.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/paths.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,19 @@
+
+#define PATHS_N 16
+
+struct path_s {
+    u8 eType;
+    u8 eSize;
+    u8 eOffset; // ENCAP_OFFSET_*
+    u8 nOffset;
+    u8 pword;
+    u8 mac_len; // SKB MAC LEN
+    u16 protocol; // SKB PROTOCOL
+    u64 reserved64 [2];
+// 8 - DEVICE
+    net_device_s* phys;
+// 32 - ENCAP
+    encap_s encap;
+};
+
+BUILD_ASSERT(sizeof(path_s) == 64);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/pkt.h linux-master/drivers/net/clf/pkt.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/pkt.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/pkt.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,106 @@
+
+enum ENCAP_TYPE {
+    ENCAP_TYPE_RAW,
+    ENCAP_TYPE_ETH,
+    ENCAP_TYPE_ETH_VLAN,
+    ENCAP_TYPE_ETH_VLAN_PPP,
+    ENCAP_TYPE_ETH_PPP,
+};
+
+#define ENCAP_SIZE 32
+
+#define ENCAP_SIZE_ETH          (14)
+#define ENCAP_SIZE_ETH_VLAN     (14 + 4)
+#define ENCAP_SIZE_ETH_VLAN_PPP (14 + 4 + 8)
+#define ENCAP_SIZE_ETH_PPP      (14 + 8)
+#define ENCAP_SIZE_RAW          (0)
+
+#define ENCAP_OFFSET_ETH          (ENCAP_SIZE - ENCAP_SIZE_ETH)
+#define ENCAP_OFFSET_ETH_VLAN     (ENCAP_SIZE - ENCAP_SIZE_ETH_VLAN)
+#define ENCAP_OFFSET_ETH_VLAN_PPP (ENCAP_SIZE - ENCAP_SIZE_ETH_VLAN_PPP)
+#define ENCAP_OFFSET_ETH_PPP      (ENCAP_SIZE - ENCAP_SIZE_ETH_PPP)
+#define ENCAP_OFFSET_RAW          (ENCAP_SIZE - ENCAP_SIZE_RAW)
+
+// 32 ENCAPSULEMENT
+union encap_s { u16 w16 [ENCAP_SIZE/sizeof(u16)];
+    struct encap_eth_s {
+        u16 _ [ENCAP_OFFSET_ETH/sizeof(u16)];
+    // 14 - ETHERNET
+        u16 eDst [3];
+        u16 eSrc [3];
+        u16 eProto;
+    } eth;
+    struct encap_eth_vlan_s {
+        u16 _ [ENCAP_OFFSET_ETH_VLAN/sizeof(u16)];
+    // 14 - ETHERNET
+        u16 eDst [3];
+        u16 eSrc [3];
+        u16 eProto;
+    // 4 - VLAN
+        u16 vID;
+        u16 vProto;
+    } eth_vlan;
+    struct encap_eth_vlan_ppp_s {
+        u16 _ [ENCAP_OFFSET_ETH_VLAN_PPP/sizeof(u16)];
+    // 14 - ETHERNET
+        u16 eDst [3];
+        u16 eSrc [3];
+        u16 eProto;
+    // 4 - VLAN
+        u16 vID;
+        u16 vProto;
+    // 8 - PPP
+        u16 pCode;
+        u16 pSession;
+        u16 pSize;
+        u16 pProto;
+    } eth_vlan_ppp;
+    struct encap_eth_ppp_s {
+        u16 _ [ENCAP_OFFSET_ETH_PPP/sizeof(u16)];
+    // 14 - ETHERNET
+        u16 eDst [3];
+        u16 eSrc [3];
+        u16 eProto;
+    // 8 - PPP
+        u16 pCode;
+        u16 pSession;
+        u16 pSize;
+        u16 pProto;
+    } eth_ppp;
+};
+
+BUILD_ASSERT(sizeof(encap_eth_s)          == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_vlan_s)     == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_vlan_ppp_s) == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_ppp_s)      == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_s)              == ENCAP_SIZE);
+
+//
+#define PKT_SIZE 64
+
+struct pkt_s {
+// 32 - ENCAP
+    encap_s encap;
+// 20 - IPV4
+    u8  iVersion;
+    u8  iTOS;
+    u16 iSize;
+    u16 iID;
+    u16 iFrag;
+    u8  iTTL;
+    u8  iProto;
+    u16 iCksum;
+    u16 iSrc [2];
+    u16 iDst [2];
+// 8 - UDP
+    u16 uSrc;
+    u16 uDst;
+    u16 uSize;
+    u16 uChk;
+// 4 - WIREGUARD
+    u8 wType;
+    u8 wReserved [3]; 
+};
+
+BUILD_ASSERT(sizeof(pkt_s) == PKT_SIZE);
+
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/types.h linux-master/drivers/net/clf/types.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/clf/types.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/clf/types.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,10 @@
+
+typedef union  encap_s              encap_s;
+typedef struct encap_eth_s          encap_eth_s;
+typedef struct encap_eth_vlan_s     encap_eth_vlan_s;
+typedef struct encap_eth_vlan_ppp_s encap_eth_vlan_ppp_s;
+typedef struct encap_eth_ppp_s      encap_eth_ppp_s;
+
+typedef struct pkt_s pkt_s;
+typedef struct path_s path_s;
+typedef struct cmd_s cmd_s;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/freescale/dpaa2/dpkg.h linux-master/drivers/net/ethernet/freescale/dpaa2/dpkg.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/freescale/dpaa2/dpkg.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/ethernet/freescale/dpaa2/dpkg.h	2025-10-20 00:41:14.000000000 -0300
@@ -157,10 +157,6 @@
 #define NH_FLD_UDP_CKSUM			BIT(3)
 #define NH_FLD_UDP_ALL_FIELDS			(BIT(4) - 1)
 
-/* UDP-lite fields */
-#define NH_FLD_UDP_LITE_PORT_SRC		BIT(0)
-#define NH_FLD_UDP_LITE_PORT_DST		BIT(1)
-#define NH_FLD_UDP_LITE_ALL_FIELDS		(BIT(2) - 1)
 
 /* UDP-encap-ESP fields */
 #define NH_FLD_UDP_ENC_ESP_PORT_SRC		BIT(0)
@@ -363,7 +359,7 @@
 	NET_PROT_IP,
 	NET_PROT_TCP,
 	NET_PROT_UDP,
-	NET_PROT_UDP_LITE,
+	NET_PROT_UDP_ZZZZ,
 	NET_PROT_IPHC,
 	NET_PROT_SCTP,
 	NET_PROT_SCTP_CHUNK_DATA,
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c linux-master/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c	2025-10-20 00:41:14.000000000 -0300
@@ -9398,6 +9398,7 @@
 	first->bytecount = skb->len;
 	first->gso_segs = 1;
 
+#ifdef CONFIG_VLAN_IXGBE
 	/* if we have a HW VLAN tag being added default to the HW one */
 	if (skb_vlan_tag_present(skb)) {
 		tx_flags |= skb_vlan_tag_get(skb) << IXGBE_TX_FLAGS_VLAN_SHIFT;
@@ -9414,6 +9415,9 @@
 		tx_flags |= IXGBE_TX_FLAGS_SW_VLAN;
 	}
 	protocol = vlan_get_protocol(skb);
+#else
+	protocol = skb->protocol;
+#endif
 
 	if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
 	    adapter->ptp_clock) {
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c linux-master/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c	2025-10-20 00:41:14.000000000 -0300
@@ -4203,11 +4203,13 @@
 	first->bytecount = skb->len;
 	first->gso_segs = 1;
 
+#ifdef CONFIG_VLAN_IXGBE
 	if (skb_vlan_tag_present(skb)) {
 		tx_flags |= skb_vlan_tag_get(skb);
 		tx_flags <<= IXGBE_TX_FLAGS_VLAN_SHIFT;
 		tx_flags |= IXGBE_TX_FLAGS_VLAN;
 	}
+#endif
 
 	/* record initial flags and protocol */
 	first->tx_flags = tx_flags;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/Kconfig linux-master/drivers/net/ethernet/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/ethernet/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -50,7 +50,6 @@
 source "drivers/net/ethernet/cadence/Kconfig"
 source "drivers/net/ethernet/calxeda/Kconfig"
 source "drivers/net/ethernet/cavium/Kconfig"
-source "drivers/net/ethernet/chelsio/Kconfig"
 source "drivers/net/ethernet/cirrus/Kconfig"
 source "drivers/net/ethernet/cisco/Kconfig"
 source "drivers/net/ethernet/cortina/Kconfig"
@@ -141,9 +140,6 @@
 	  cards. <http://www.myson.com.tw/>
 
 source "drivers/net/ethernet/ni/Kconfig"
-source "drivers/net/ethernet/natsemi/Kconfig"
-source "drivers/net/ethernet/neterion/Kconfig"
-source "drivers/net/ethernet/netronome/Kconfig"
 source "drivers/net/ethernet/8390/Kconfig"
 source "drivers/net/ethernet/nvidia/Kconfig"
 source "drivers/net/ethernet/nxp/Kconfig"
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/Makefile linux-master/drivers/net/ethernet/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/ethernet/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -28,7 +28,6 @@
 obj-$(CONFIG_NET_VENDOR_BROCADE) += brocade/
 obj-$(CONFIG_NET_CALXEDA_XGMAC) += calxeda/
 obj-$(CONFIG_NET_VENDOR_CAVIUM) += cavium/
-obj-$(CONFIG_NET_VENDOR_CHELSIO) += chelsio/
 obj-$(CONFIG_NET_VENDOR_CIRRUS) += cirrus/
 obj-$(CONFIG_NET_VENDOR_CISCO) += cisco/
 obj-$(CONFIG_NET_VENDOR_CORTINA) += cortina/
@@ -67,9 +66,6 @@
 obj-$(CONFIG_NET_VENDOR_MOXART) += moxa/
 obj-$(CONFIG_NET_VENDOR_MYRI) += myricom/
 obj-$(CONFIG_FEALNX) += fealnx.o
-obj-$(CONFIG_NET_VENDOR_NATSEMI) += natsemi/
-obj-$(CONFIG_NET_VENDOR_NETERION) += neterion/
-obj-$(CONFIG_NET_VENDOR_NETRONOME) += netronome/
 obj-$(CONFIG_NET_VENDOR_NI) += ni/
 obj-$(CONFIG_NET_VENDOR_NVIDIA) += nvidia/
 obj-$(CONFIG_LPC_ENET) += nxp/
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/mediatek/mtk_ppe_regs.h linux-master/drivers/net/ethernet/mediatek/mtk_ppe_regs.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/ethernet/mediatek/mtk_ppe_regs.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/ethernet/mediatek/mtk_ppe_regs.h	2025-10-20 00:41:14.000000000 -0300
@@ -15,7 +15,7 @@
 #define MTK_PPE_GLO_CFG_MCAST_TB_EN		BIT(7)
 #define MTK_PPE_GLO_CFG_FLOW_DROP_KA		BIT(8)
 #define MTK_PPE_GLO_CFG_FLOW_DROP_UPDATE	BIT(9)
-#define MTK_PPE_GLO_CFG_UDP_LITE_EN		BIT(10)
+#define MTK_PPE_GLO_CFG_UDP_ZZZZ_EN		BIT(10)
 #define MTK_PPE_GLO_CFG_UDP_LEN_DROP		BIT(11)
 #define MTK_PPE_GLO_CFG_MCAST_ENTRIES		GNEMASK(13, 12)
 #define MTK_PPE_GLO_CFG_BUSY			BIT(31)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/Kconfig linux-master/drivers/net/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -117,6 +117,59 @@
 	  This module enhances the performance of the OpenVPN userspace software
 	  by offloading the data channel processing to kernelspace.
 
+if WIREGUARD
+
+config        WIREGUARD_IP6
+	bool "WIREGUARD_IP6"
+	default y
+	depends on IPV6
+
+config        WIREGUARD_MARKS
+	bool "WIREGUARD_MARKS"
+	default n
+
+if WIREGUARD_MARKS
+
+config       WIREGUARD_MARKS_N
+	int "WIREGUARD_MARKS_N"
+	default 3
+
+config       WIREGUARD_MARK_0
+	int "WIREGUARD_MARK_0"
+	default 511
+
+config       WIREGUARD_MARK_MULT
+	int "WIREGUARD_MARK_MULT"
+	default 11
+
+endif
+
+config       WIREGUARD_KEEPALIVE_TIMEOUT
+	int "WIREGUARD_KEEPALIVE_TIMEOUT"
+	default 10
+
+config 	     WIREGUARD_REKEY_TIMEOUT
+	int "WIREGUARD_REKEY_TIMEOUT"
+	default 5
+
+config 	     WIREGUARD_REJECT_AFTER_TIME
+	int "WIREGUARD_REJECT_AFTER_TIME"
+	default 180
+
+config 	     WIREGUARD_REKEY_AFTER_TIME
+	int "WIREGUARD_REKEY_AFTER_TIME"
+	default 120
+
+config 	     WIREGUARD_MAX_TIMER_HANDSHAKES
+	int "WIREGUARD_MAX_TIMER_HANDSHAKES"
+	default 90
+
+config 	     WIREGUARD_MAX_PEERS_PER_DEVICE_SHIFT
+	int "WIREGUARD_MAX_PEERS_PER_DEVICE_SHIFT"
+	default 20
+
+endif
+
 config EQUALIZER
 	tristate "EQL (serial line load balancing) support"
 	help
@@ -538,8 +591,6 @@
 
 source "drivers/net/slip/Kconfig"
 
-source "drivers/s390/net/Kconfig"
-
 source "drivers/net/usb/Kconfig"
 
 source "drivers/net/wireless/Kconfig"
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/Makefile linux-master/drivers/net/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -90,3 +90,5 @@
 obj-$(CONFIG_USB4_NET) += thunderbolt/
 obj-$(CONFIG_NETDEVSIM) += netdevsim/
 obj-$(CONFIG_NET_FAILOVER) += net_failover.o
+obj-$(CONFIG_XGW)		+= xgw/
+obj-$(CONFIG_CLF)		+= clf/
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/NOTES.txt linux-master/drivers/net/NOTES.txt
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/NOTES.txt	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/NOTES.txt	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,38 @@
+    O X DA QUESTÃO ESTÁ EM
+    static inline u32 __tcp_set_rto(const struct tcp_sock *tp)
+{
+    return usecs_to_jiffies((tp->srtt_us >> 3) + tp->rttvar_us);
+}
+
+
+consertar mais profundamente, pois é o rtt em si que eh afetado pela troca de links aqui e lá
+tp->rack.rtt_us
+
+    u64 tcp_mstamp;  most recent packet received/sent
+    u32 srtt_us;     smoothed round trip time << 3 in usecs
+    u32 mdev_us;     medium deviation
+    u32 mdev_max_us;     maximal mdev for the last rtt period
+    u32 rttvar_us;   smoothed mdev_max
+    u32 rtt_seq;     sequence number to update rttvar
+    struct  minmax rtt_min;
+
+Receiver side RTT estimation
+    u32 rcv_rtt_last_tsecr;
+    struct {
+        u32 rtt_us;
+        u32 seq;
+        u64 time;
+    } rcv_rtt_est;
+
+
+    CHECAR:
+    -> tcp_update_metrics()
+    -> funcoes que lidam com struct dst_entry
+    -> CONFIG_SYSCTL_TCP_NOMETRICS_SAVE
+
+    /proc/sys/net/ipv4/tcp_tso_rtt_log
+    /proc/sys/net/ipv4/tcp_min_rtt_wlen
+
+    SKB_DROP_REASON_UDP_CSUM
+
+- INICIALIZAR O COUNTER A ALGUM VALOR ALEATORIO
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/wireguard/device.c linux-master/drivers/net/wireguard/device.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/wireguard/device.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/wireguard/device.c	2025-10-20 00:41:14.000000000 -0300
@@ -333,7 +333,7 @@
 		goto err_free_peer_hashtable;
 
 	wg->handshake_receive_wq = alloc_workqueue("wg-kex-%s",
-			WQ_CPU_INTENSIVE | WQ_FREEZABLE | WQ_PERCPU, 0,
+			WQ_CPU_INTENSIVE | WQ_FREEZABLE | WQ_UNBOUND, 0,
 			dev->name);
 	if (!wg->handshake_receive_wq)
 		goto err_free_index_hashtable;
@@ -344,7 +344,7 @@
 		goto err_destroy_handshake_receive;
 
 	wg->packet_crypt_wq = alloc_workqueue("wg-crypt-%s",
-			WQ_CPU_INTENSIVE | WQ_MEM_RECLAIM | WQ_PERCPU, 0,
+			WQ_CPU_INTENSIVE | WQ_MEM_RECLAIM | WQ_UNBOUND, 0,
 			dev->name);
 	if (!wg->packet_crypt_wq)
 		goto err_destroy_handshake_send;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/wireguard/messages.h linux-master/drivers/net/wireguard/messages.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/wireguard/messages.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/wireguard/messages.h	2025-10-20 00:41:14.000000000 -0300
@@ -40,14 +40,14 @@
 enum limits {
 	REKEY_AFTER_MESSAGES = 1ULL << 60,
 	REJECT_AFTER_MESSAGES = U64_MAX - COUNTER_WINDOW_SIZE - 1,
-	REKEY_TIMEOUT = 5,
+	REKEY_TIMEOUT = CONFIG_WIREGUARD_REKEY_TIMEOUT,
 	REKEY_TIMEOUT_JITTER_MAX_JIFFIES = HZ / 3,
-	REKEY_AFTER_TIME = 120,
-	REJECT_AFTER_TIME = 180,
+	REKEY_AFTER_TIME = CONFIG_WIREGUARD_REKEY_AFTER_TIME,
+	REJECT_AFTER_TIME = CONFIG_WIREGUARD_REJECT_AFTER_TIME,
 	INITIATIONS_PER_SECOND = 50,
-	MAX_PEERS_PER_DEVICE = 1U << 20,
-	KEEPALIVE_TIMEOUT = 10,
-	MAX_TIMER_HANDSHAKES = 90 / REKEY_TIMEOUT,
+	MAX_PEERS_PER_DEVICE = 1U << CONFIG_WIREGUARD_MAX_PEERS_PER_DEVICE_SHIFT,
+	KEEPALIVE_TIMEOUT = CONFIG_WIREGUARD_KEEPALIVE_TIMEOUT,
+	MAX_TIMER_HANDSHAKES = CONFIG_WIREGUARD_MAX_TIMER_HANDSHAKES / REKEY_TIMEOUT,
 	MAX_QUEUED_INCOMING_HANDSHAKES = 4096, /* TODO: replace this with DQL */
 	MAX_STAGED_PACKETS = 128,
 	MAX_QUEUED_PACKETS = 1024 /* TODO: replace this with DQL */
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/wireguard/ratelimiter.c linux-master/drivers/net/wireguard/ratelimiter.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/wireguard/ratelimiter.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/wireguard/ratelimiter.c	2025-10-20 00:41:14.000000000 -0300
@@ -19,7 +19,7 @@
 static void wg_ratelimiter_gc_entries(struct work_struct *);
 static DECLARE_DEFERRABLE_WORK(gc_work, wg_ratelimiter_gc_entries);
 static struct hlist_head *table_v4;
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 static struct hlist_head *table_v6;
 #endif
 
@@ -66,7 +66,7 @@
 			    now - entry->last_time_ns > NSEC_PER_SEC)
 				entry_uninit(entry);
 		}
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 		hlist_for_each_entry_safe(entry, temp, &table_v6[i], hash) {
 			if (unlikely(!work) ||
 			    now - entry->last_time_ns > NSEC_PER_SEC)
@@ -97,7 +97,7 @@
 		bucket = &table_v4[hsiphash_2u32(net_word, ip, &key) &
 				   (table_size - 1)];
 	}
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 	else if (skb->protocol == htons(ETH_P_IPV6)) {
 		/* Only use 64 bits, so as to ratelimit the whole /64. */
 		memcpy(&ip, &ipv6_hdr(skb)->saddr, sizeof(ip));
@@ -180,7 +180,7 @@
 	if (unlikely(!table_v4))
 		goto err_kmemcache;
 
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 	table_v6 = kvcalloc(table_size, sizeof(*table_v6), GFP_KERNEL);
 	if (unlikely(!table_v6)) {
 		kvfree(table_v4);
@@ -212,7 +212,7 @@
 	wg_ratelimiter_gc_entries(NULL);
 	rcu_barrier();
 	kvfree(table_v4);
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 	kvfree(table_v6);
 #endif
 	kmem_cache_destroy(entry_cache);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/wireguard/selftest/ratelimiter.c linux-master/drivers/net/wireguard/selftest/ratelimiter.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/wireguard/selftest/ratelimiter.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/wireguard/selftest/ratelimiter.c	2025-10-20 00:41:14.000000000 -0300
@@ -63,7 +63,7 @@
 
 		hdr4->saddr = htonl(ntohl(hdr4->saddr) - i - 1);
 
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 		hdr6->saddr.in6_u.u6_addr32[2] = htonl(i);
 		hdr6->saddr.in6_u.u6_addr32[3] = htonl(i);
 		if (time_is_before_jiffies(loop_start_time +
@@ -153,7 +153,7 @@
 	skb_reset_network_header(skb4);
 	++test;
 
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 	skb6 = alloc_skb(sizeof(struct ipv6hdr), GFP_KERNEL);
 	if (unlikely(!skb6)) {
 		kfree_skb(skb4);
@@ -204,7 +204,7 @@
 
 err:
 	kfree_skb(skb4);
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 	kfree_skb(skb6);
 #endif
 err_nofree:
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/wireguard/socket.c linux-master/drivers/net/wireguard/socket.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/wireguard/socket.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/net/wireguard/socket.c	2025-10-20 00:41:14.000000000 -0300
@@ -97,7 +97,7 @@
 static int send6(struct wg_device *wg, struct sk_buff *skb,
 		 struct endpoint *endpoint, u8 ds, struct dst_cache *cache)
 {
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 	struct flowi6 fl = {
 		.saddr = endpoint->src6,
 		.daddr = endpoint->addr6.sin6_addr,
@@ -242,13 +242,15 @@
 		endpoint->addr4.sin_addr.s_addr = ip_hdr(skb)->saddr;
 		endpoint->src4.s_addr = ip_hdr(skb)->daddr;
 		endpoint->src_if4 = skb->skb_iif;
-	} else if (IS_ENABLED(CONFIG_IPV6) && skb->protocol == htons(ETH_P_IPV6)) {
+#ifdef CONFIG_WIREGUARD_IP6
+	} else if (skb->protocol == htons(ETH_P_IPV6)) {
 		endpoint->addr6.sin6_family = AF_INET6;
 		endpoint->addr6.sin6_port = udp_hdr(skb)->source;
 		endpoint->addr6.sin6_addr = ipv6_hdr(skb)->saddr;
 		endpoint->addr6.sin6_scope_id = ipv6_iface_scope_id(
 			&ipv6_hdr(skb)->saddr, skb->skb_iif);
 		endpoint->src6 = ipv6_hdr(skb)->daddr;
+#endif
 	} else {
 		return -EINVAL;
 	}
@@ -285,9 +287,11 @@
 		peer->endpoint.addr4 = endpoint->addr4;
 		peer->endpoint.src4 = endpoint->src4;
 		peer->endpoint.src_if4 = endpoint->src_if4;
-	} else if (IS_ENABLED(CONFIG_IPV6) && endpoint->addr.sa_family == AF_INET6) {
+#ifdef CONFIG_WIREGUARD_IP6
+	} else if (endpoint->addr.sa_family == AF_INET6) {
 		peer->endpoint.addr6 = endpoint->addr6;
 		peer->endpoint.src6 = endpoint->src6;
+#endif
 	} else {
 		goto out;
 	}
@@ -309,6 +313,23 @@
 {
 	write_lock_bh(&peer->endpoint_lock);
 	memset(&peer->endpoint.src6, 0, sizeof(peer->endpoint.src6));
+#ifdef CONFIG_WIREGUARD_MARKS
+	// 162.159.192.0/24 - ITS WARP
+	// (ntohl(peer->endpoint.addr4.sin_addr.s_addr) & 0xFFFFFF00U) == 0xA29FC000U
+	// TODO: SOMENTE SE FOR CLIENTE - MAS ISSO ALTERA TODA A INTERFACE @_@
+	unsigned int mark = peer->device->fwmark;
+	if (mark >= CONFIG_WIREGUARD_MARK_0
+	 && mark < (CONFIG_WIREGUARD_MARK_0 + CONFIG_WIREGUARD_MARKS_N*CONFIG_WIREGUARD_MARK_MULT)) {
+		// JA SERA O PROXIMO POIS TERMINA EM _MULT
+		// [ (511 + ((1 + (x - 511) // 11) % 3) * 11) for x in (511, 522, 533)]
+		mark = CONFIG_WIREGUARD_MARK_0 + ((1 + (mark - CONFIG_WIREGUARD_MARK_0) / CONFIG_WIREGUARD_MARK_MULT) % CONFIG_WIREGUARD_MARKS_N) * CONFIG_WIREGUARD_MARK_MULT;
+		printk("WARP: %s: CHANGED TO MARK %u\n", peer->device->dev->name, mark);
+		peer->device->fwmark = mark;
+	}
+#elif 1
+	if (peer->device->fwmark)
+		printk("WARP: %s: CLEARED ENDPOINT\n", peer->device->dev->name);
+#endif
 	dst_cache_reset_now(&peer->endpoint_cache);
 	write_unlock_bh(&peer->endpoint_lock);
 }
@@ -360,15 +381,14 @@
 		.family = AF_INET,
 		.local_ip.s_addr = htonl(INADDR_ANY),
 		.local_udp_port = htons(port),
-		.use_udp_checksums = true
 	};
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 	int retries = 0;
 	struct udp_port_cfg port6 = {
 		.family = AF_INET6,
 		.local_ip6 = IN6ADDR_ANY_INIT,
-		.use_udp6_tx_checksums = true,
-		.use_udp6_rx_checksums = true,
+		.use_udp6_tx_checksums = false,
+		.use_udp6_rx_checksums = false,
 		.ipv6_v6only = true
 	};
 #endif
@@ -380,7 +400,7 @@
 	if (unlikely(!net))
 		return -ENONET;
 
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 retry:
 #endif
 
@@ -392,7 +412,7 @@
 	set_sock_opts(new4);
 	setup_udp_tunnel_sock(net, new4, &cfg);
 
-#if IS_ENABLED(CONFIG_IPV6)
+#ifdef CONFIG_WIREGUARD_IP6
 	if (ipv6_mod_enabled()) {
 		port6.local_udp_port = inet_sk(new4->sk)->inet_sport;
 		ret = udp_sock_create(net, &port6, &new6);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/alloc.c linux-master/drivers/net/xgw/alloc.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/alloc.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/alloc.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,20 @@
+
+static inline uint paged_order (const size_t size) {
+
+    uint real = PAGE_SIZE;
+
+    while (real < size)
+           real <<= 1;
+
+    return __ctz(real / PAGE_SIZE);
+}
+
+static void paged_free (void* const a, const size_t size) {
+
+    free_pages((uintptr_t)a, paged_order(size));
+}
+
+static void* paged_alloc (const size_t size) {
+
+    return (void*)__get_free_pages(GFP_NOWAIT, paged_order(size));
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/arp.c linux-master/drivers/net/xgw/arp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/arp.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/arp.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,53 @@
+
+#if 0
+
+#define ACODE_REQUEST  0x0001080006040001ULL
+#define ACODE_REPLY    0x0001080006040002ULL
+
+#define        ARP_HDR_S 56
+typedef struct arp_hdr_s {
+// 24 ETHERNET, VLAN
+    union {
+        struct {
+        //  6 ALIGN
+            u16 _align[3];
+        // 14 ETHERNET
+            u8  edst [ETH_ALEN];
+            u8  esrc [ETH_ALEN];
+            u16 etype;
+        //  4 VLAN
+            u16 vid;
+            u16 vtype;
+        } v;
+        struct {
+            //  2 ALIGN
+            u16 _align;
+            // 14 ETHERNET
+            u8  edst [ETH_ALEN];
+            u8  esrc [ETH_ALEN];
+            u16 etype;
+        };
+    };
+// 28 ARP
+    u64 acode;
+    u8  aesrc [ETH_ALEN];
+    u8  aisrc [4];
+    u8  aedst [ETH_ALEN];
+    u8  aidst [4];
+} arp_hdr_s;
+
+    // recebeu um pacote ARP request
+    req
+
+    memcpy(&resp->edst, &req->esrc, ETH_ALEN);
+    memcpy(&resp->esrc, , ETH_ALEN);            // MEU ETH
+            resp->etype = BE16(0x0806);        // ARP
+            resp->acode = BE64(ACODE_REPLY);
+    memcpy(&resp->aesrc, , ETH_ALEN);            // MEU ETH
+    memcpy(&resp->aisrc, , 4);                     // MEU IP
+    memcpy(&resp->aedst, &req->aesrc, ETH_ALEN);
+    memcpy(&resp->aidst, , 4);
+
+    // marca para enviar o arp response
+
+#endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/asserts.c linux-master/drivers/net/xgw/asserts.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/asserts.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/asserts.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,212 @@
+BUILD_ASSERT(XGW_MTU_OVERHEAD == (PKT_X_SIZE + PKT_ALIGN_SIZE));
+
+BUILD_ASSERT((PKT_DATA((pkt_s*)NULL) - NULL) == (ENCAP_SIZE + XGW_MTU_OVERHEAD));
+
+//
+BUILD_ASSERT(CMD_SIZE(NODE_NAME) == sizeof(((node_s*)NULL)->name));
+BUILD_ASSERT(CMD_SIZE(PATH_NAME) == sizeof(((path_s*)NULL)->name));
+BUILD_ASSERT(CMD_SIZE(ADDR4)     == sizeof(((path_s*)NULL)->skel.encap_ip4.ip4.saddr));
+BUILD_ASSERT(CMD_SIZE(ADDR4)     == sizeof(((path_s*)NULL)->skel.encap_ip4.ip4.daddr));
+BUILD_ASSERT(CMD_SIZE(ADDR6)     == sizeof(((path_s*)NULL)->skel.encap_ip6.ip6.saddr));
+BUILD_ASSERT(CMD_SIZE(ADDR6)     == sizeof(((path_s*)NULL)->skel.encap_ip6.ip6.daddr));
+BUILD_ASSERT(CMD_SIZE(MAC)       == sizeof(((path_s*)NULL)->skel.encap_eth.eth.dmac));
+BUILD_ASSERT(CMD_SIZE(MAC)       == sizeof(((path_s*)NULL)->skel.encap_eth.eth.smac));
+
+//
+BUILD_ASSERT((CMD_TYPE(NODE_ID)) NID_MAX == NID_MAX);
+BUILD_ASSERT((CMD_TYPE(PATH_ID)) PID_MAX == PID_MAX);
+BUILD_ASSERT((CMD_TYPE(CODE))    CMDS_N  == CMDS_N);
+
+//
+BUILD_ASSERT(sizeof(hdr_eth_s)  == 14);
+BUILD_ASSERT(sizeof(hdr_vlan_s) ==  4);
+BUILD_ASSERT(sizeof(hdr_ppp_s)  ==  8);
+BUILD_ASSERT(sizeof(hdr_ip4_s)  == 20);
+BUILD_ASSERT(sizeof(hdr_ip6_s)  == 40);
+BUILD_ASSERT(sizeof(hdr_udp_s)  ==  8);
+BUILD_ASSERT(sizeof(hdr_tcp_s)  == 20);
+BUILD_ASSERT(sizeof(hdr_x_s)    == 24);
+
+//
+BUILD_ASSERT(sizeof(encap_eth_s)              == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_ip4_s)          == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_ip6_s)          == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_ip4_udp_s)      == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_ip6_udp_s)      == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_vlan_s)         == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_vlan_ip4_s)     == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_vlan_ip6_s)     == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_vlan_ip4_udp_s) == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_vlan_ip6_udp_s) == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_vlan_ppp_s)     == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_vlan_ppp_ip4_s) == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_vlan_ppp_ip6_s) == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_ppp_s)          == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_ppp_ip4_s)      == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_eth_ppp_ip6_s)      == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_ip4_s)              == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_ip4_udp_s)          == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_ip4_tcp_s)          == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_ip6_s)              == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_ip6_udp_s)          == ENCAP_SIZE);
+BUILD_ASSERT(sizeof(encap_ip6_tcp_s)          == ENCAP_SIZE);
+
+//
+BUILD_ASSERT(offsetof(pkt_s, x) == ENCAP_SIZE);
+
+//
+BUILD_ASSERT(offsetof(pkt_s, encap_raw) == 0);
+
+//
+BUILD_ASSERT(sizeof(pkt_s) == (ENCAP_SIZE + sizeof(hdr_x_s)));
+
+BUILD_ASSERT(sizeof(hdr_x_s) == PKT_X_SIZE);
+BUILD_ASSERT(sizeof(pkt_s)   == PKT_SIZE);
+BUILD_ASSERT(sizeof(ping_s)  == PING_SIZE);
+
+//
+BUILD_ASSERT(sizeof(ip4_s) == (sizeof(hdr_ip4_s) + 2 * sizeof(u16)));
+BUILD_ASSERT(sizeof(ip6_s) == (sizeof(hdr_ip6_s) + 2 * sizeof(u16)));
+
+// MIN < MAX
+BUILD_ASSERT(RTT_VAR_MIN < RTT_VAR_MAX);
+BUILD_ASSERT(PATH_OADD_MIN < PATH_OADD_MAX);
+
+// TEM QUE TER UMA FOLGUINHA...
+BUILD_ASSERT((RTT_MAX + 100) < KEEPER_INTERVAL_MS);
+
+//
+BUILD_ASSERT(offsetof(path_s, info)        % CACHE_LINE_SIZE == 0);
+BUILD_ASSERT(offsetof(path_s, stats)       % CACHE_LINE_SIZE == 0);
+BUILD_ASSERT(offsetof(node_s, opaths)      % CACHE_LINE_SIZE == 0);
+BUILD_ASSERT(offsetof(node_s, nid)         % CACHE_LINE_SIZE == 0);
+BUILD_ASSERT(offsetof(node_s, syns)        % CACHE_LINE_SIZE == 0);
+BUILD_ASSERT(offsetof(node_s, paths)       % CACHE_LINE_SIZE == 0);
+BUILD_ASSERT(offsetof(node_s, oKeys)       % CACHE_LINE_SIZE == 0);
+BUILD_ASSERT(offsetof(node_s, iKeys)       % CACHE_LINE_SIZE == 0);
+BUILD_ASSERT(offsetof(node_s, secret)      % CACHE_LINE_SIZE == 0);
+
+BUILD_ASSERT(sizeof(path_s) == PATH_SIZE);
+
+//
+BUILD_ASSERT((sizeof(((path_s*)NULL)->acks)*8) == ACKS_N);
+
+BUILD_ASSERT(sizeof(((path_s*)NULL)->stats)
+         >= (sizeof(((path_s*)NULL)->stats[0]) * PSTATS_N));
+
+//
+BUILD_ASSERT(sizeof(((node_s*)NULL)->oKeys)  == (O_KEYS_ALL * K_SIZE));
+BUILD_ASSERT(sizeof(((node_s*)NULL)->iKeys)  == (I_KEYS_ALL * K_SIZE));
+BUILD_ASSERT(sizeof(((node_s*)NULL)->secret) == (SECRET_KEYS_N * K_SIZE));
+BUILD_ASSERT(sizeof(((node_s*)NULL)->syns)   == 128);
+BUILD_ASSERT(sizeof(((node_s*)NULL)->paths)  == 12288);
+
+// -- NAO PRECISAREMOS CHECAR LIMITES, POIS NAO CABEM MESMO
+// -- E TEM QUE CABER TODOS
+BUILD_ASSERT((typeof(((hdr_x_s*)NULL)->src))     ~(typeof(((hdr_x_s*)NULL)->src))     0 == NID_MAX);
+BUILD_ASSERT((typeof(((hdr_x_s*)NULL)->dst))     ~(typeof(((hdr_x_s*)NULL)->dst))     0 == NID_MAX);
+BUILD_ASSERT((typeof(((hdr_x_s*)NULL)->version)) ~(typeof(((hdr_x_s*)NULL)->version)) 0 == I_KEY_MAX);
+BUILD_ASSERT((typeof(((ping_s*)NULL)->ver))      ~(typeof(((ping_s*)NULL)->ver))      0 == I_KEY_MAX);
+
+// THE TYPES MUST BE ABLE TO HOLD THEIR VALUES
+BUILD_ASSERT((typeof(((path_s*)NULL)->rtt))         RTT_MAX          == RTT_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->rtt_max))     RTT_MAX          == RTT_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->rtt_var_))    RTT_VAR_MAX      == RTT_VAR_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->rtt_var))     RTT_VAR_MAX_INIT == RTT_VAR_MAX_INIT);
+BUILD_ASSERT((typeof(((path_s*)NULL)->cdown))       RTT_VAR_STEPS    == RTT_VAR_STEPS);
+BUILD_ASSERT((typeof(((path_s*)NULL)->oadd))        PATH_OADD_MAX    == PATH_OADD_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->acks))        ACKS_SERVER      == ACKS_SERVER);
+BUILD_ASSERT((typeof(((path_s*)NULL)->acks))        ACKS_CLIENT      == ACKS_CLIENT);
+BUILD_ASSERT((typeof(((path_s*)NULL)->since))       RTIME_MAX        == RTIME_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->asked))       PTIME_MAX        == PTIME_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->answered))    PTIME_MAX        == PTIME_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->pseen[0]))    PTIME_MAX        == PTIME_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->pseen[1]))    PTIME_MAX        == PTIME_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->tdiff))       TDIFF_MIN        == TDIFF_MIN);
+BUILD_ASSERT((typeof(((path_s*)NULL)->tdiff))       TDIFF_MAX        == TDIFF_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->info))        P_INFO           == P_INFO);
+BUILD_ASSERT((typeof(((path_s*)NULL)->info))        P_ALL            == P_ALL);
+BUILD_ASSERT((typeof(((path_s*)NULL)->weight))      PATH_WEIGHT_MAX  == PATH_WEIGHT_MAX);
+BUILD_ASSERT((typeof(((path_s*)NULL)->weight_acks)) ACKS_N           == ACKS_N);
+//BUILD_ASSERT((typeof(((path_s*)NULL)->sPortsN))     PATH_PORTS_N     == PATH_PORTS_N);
+//BUILD_ASSERT((typeof(((path_s*)NULL)->dPortsN))     PATH_PORTS_N     == PATH_PORTS_N);
+//BUILD_ASSERT((typeof(((path_s*)NULL)->sPortIndex))  (PATH_PORTS_N-1) == (PATH_PORTS_N-1));
+//BUILD_ASSERT((typeof(((path_s*)NULL)->dPortIndex))  (PATH_PORTS_N-1) == (PATH_PORTS_N-1));
+BUILD_ASSERT((typeof(((node_s*)NULL)->nid))         NID_MAX          == NID_MAX);
+BUILD_ASSERT((typeof(((node_s*)NULL)->mtu))         MTU_MAX          == MTU_MAX);
+BUILD_ASSERT((typeof(((node_s*)NULL)->weights))     NODE_WEIGHTS_MAX == NODE_WEIGHTS_MAX);
+BUILD_ASSERT((typeof(((node_s*)NULL)->kpaths))      KPATH(PID_MAX)   == KPATH(PID_MAX));
+BUILD_ASSERT((typeof(((node_s*)NULL)->opaths))      OPATH(PID_MAX)   == OPATH(PID_MAX));
+BUILD_ASSERT((typeof(((node_s*)NULL)->ipaths))      IPATH(PID_MAX)   == IPATH(PID_MAX));
+BUILD_ASSERT((typeof(((node_s*)NULL)->kpaths))      KPATHS           == KPATHS);
+BUILD_ASSERT((typeof(((node_s*)NULL)->opaths))      OPATHS           == OPATHS);
+BUILD_ASSERT((typeof(((node_s*)NULL)->ipaths))      IPATHS           == IPATHS);
+BUILD_ASSERT((typeof(((node_s*)NULL)->info))        N_INFO           == N_INFO);
+BUILD_ASSERT((typeof(((ping_s*)NULL)->ver))         I_KEY_MAX        == I_KEY_MAX);
+BUILD_ASSERT((typeof(((ping_s*)NULL)->time))        PTIME_MAX        == PTIME_MAX);
+BUILD_ASSERT((typeof(((hdr_x_s*)NULL)->src))        NID_MAX          == NID_MAX);
+BUILD_ASSERT((typeof(((hdr_x_s*)NULL)->dst))        NID_MAX          == NID_MAX);
+BUILD_ASSERT((typeof(((hdr_x_s*)NULL)->path))       PID_MAX          == PID_MAX);
+BUILD_ASSERT((typeof(((hdr_x_s*)NULL)->time))       PTIME_MAX        == PTIME_MAX);
+
+BUILD_ASSERT(sizeof(((ping_s*)NULL)->rnd)       == K_SIZE);
+BUILD_ASSERT(sizeof(((node_s*)NULL)->secret[0]) == K_SIZE);
+BUILD_ASSERT(sizeof(((node_s*)NULL)->secret) == SECRET_SIZE);
+
+//BUILD_ASSERT((typeof(((node_s*)NULL)->info))N_INFO == N_INFO);
+//BUILD_ASSERT((typeof(((node_s*)NULL)->connsN))CONNS_N_MAX == CONNS_N_MAX);
+
+//
+BUILD_ASSERT(P_INFO == (
+    P_ON                  +
+    P_CLIENT              +
+    P_SERVER              +
+    P_PHYS                +
+    P_MAC_SRC             +
+    P_MAC_DST             +
+    P_ADDR_SRC            +
+    P_ADDR_DST            +
+    P_PORT_SRC            +
+    P_PORT_DST            +
+    P_TOS                 +
+    P_TTL                 +
+    P_VPROTO              +
+    P_VID                 +
+    P_RTT_VAR             +
+    P_NAME                +
+    P_DHCP                +
+    P_DHCP_MAC_DST_SERVER +
+    P_DHCP_MAC_DST_GW     +
+    P_EXIST
+));
+
+BUILD_ASSERT(P_ALL == (
+    P_INFO                +
+    K_START               +
+    K_SUSPEND             +
+    K_SUSPENDING          +
+    K_LISTEN              +
+    K_ESTABLISHED
+));
+
+// MATCH THE TOOL
+BUILD_ASSERT(CMDS_N == 87);
+BUILD_ASSERT(CMD_ERRS_N == 76);
+
+BUILD_ASSERT(TDIFF_MIN < 0);
+BUILD_ASSERT(TDIFF_MAX > 0);
+
+BUILD_ASSERT(RTIME_MIN < RTIME_MAX);
+BUILD_ASSERT(PTIME_MIN < PTIME_MAX);
+BUILD_ASSERT(TDIFF_MIN < TDIFF_MAX);
+
+//
+BUILD_ASSERT((PMASK_MAX + RTIME_MAX + TDIFF_MAX) < 0xFFFFFFFFFFFFFFFFULL);
+
+BUILD_ASSERT((s64)PTIME_MIN == PTIME_MIN);
+BUILD_ASSERT((s64)PTIME_MAX == PTIME_MAX);
+
+BUILD_ASSERT(-((s64)PTIME_MIN - (s64)PTIME_MAX)
+           == (     PTIME_MAX -      PTIME_MIN));
+
+
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/base.h linux-master/drivers/net/xgw/base.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/base.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/base.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,129 @@
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#ifdef CONFIG_HIGH_RES_TIMERS
+#include <linux/ktime.h>
+#include <linux/hrtimer.h>
+#endif
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/net.h>
+#include <linux/if_ether.h>
+#include <linux/in.h>
+#include <net/ip.h>
+#include <net/inet_common.h>
+#include <linux/proc_fs.h>
+#ifdef CONFIG_XGW_BEEP
+#include <linux/i8253.h>
+#endif
+
+#define ___JOIN(a, b) a ## b
+#define SUFFIX_ULL(l) ___JOIN(l, ULL)
+#define SUFFIX_U(l)   ___JOIN(l, U)
+
+#define __noinline __attribute__((noinline))
+#define __cold_as_ice __attribute__((cold))
+
+#if defined(__clang__)
+#define __optimize_size
+#elif defined(__GNUC__)
+#define __optimize_size __attribute__((optimize("Os")))
+#endif
+
+#define ETH_SIZE 14 // ETH_HLEN
+#define IP4_SIZE 20 // sizeof(struct iphdr)
+#define IP6_SIZE 40 // sizeof(struct ipv6hdr)
+#define TCP_SIZE 20 // sizeof(struct tcphdr)
+#define UDP_SIZE  8 // sizeof(struct udphdr)
+
+// TODO:
+#define popcount32 __builtin_popcount
+#define popcount64 __builtin_popcountll
+
+#define popcount(x) \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x),  int  ), __builtin_popcount(x),   \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x), uint  ), __builtin_popcount(x),   \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x),  intll), __builtin_popcountll(x), \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x), uintll), __builtin_popcountll(x), \
+    __builtin_choose_expr(                    sizeof(x) <= sizeof(uint),   __builtin_popcount(x),   \
+                                                                           __builtin_popcountll(x))))))
+
+#define __ctz(x) \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x),  int  ), __builtin_ctz(x),   \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x), uint  ), __builtin_ctz(x),   \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x),  intll), __builtin_ctzll(x), \
+    __builtin_choose_expr(__builtin_types_compatible_p(typeof(x), uintll), __builtin_ctzll(x), \
+    __builtin_choose_expr(                    sizeof(x) <= sizeof(uint),   __builtin_ctz(x),   \
+                                                                           __builtin_ctzll(x))))))
+
+#define __prefetch_r_temporal_none(addr)     __builtin_prefetch((addr), 0, 0)
+#define __prefetch_w_temporal_none(addr)     __builtin_prefetch((addr), 1, 0)
+#define __prefetch_s_temporal_none(addr)     __builtin_prefetch((addr), 2, 0)
+#define __prefetch_r_temporal_low(addr)      __builtin_prefetch((addr), 0, 1)
+#define __prefetch_w_temporal_low(addr)      __builtin_prefetch((addr), 1, 1)
+#define __prefetch_s_temporal_low(addr)      __builtin_prefetch((addr), 2, 1)
+#define __prefetch_r_temporal_moderate(addr) __builtin_prefetch((addr), 0, 2)
+#define __prefetch_w_temporal_moderate(addr) __builtin_prefetch((addr), 1, 2)
+#define __prefetch_s_temporal_moderate(addr) __builtin_prefetch((addr), 2, 2)
+#define __prefetch_r_temporal_high(addr)     __builtin_prefetch((addr), 0, 3)
+#define __prefetch_w_temporal_high(addr)     __builtin_prefetch((addr), 1, 3)
+#define __prefetch_s_temporal_high(addr)     __builtin_prefetch((addr), 2, 3)
+
+typedef __u8   u8;
+typedef __u16 u16;
+typedef __u32 u32;
+typedef __u64 u64;
+
+typedef __s64 s64;
+
+typedef          long long int intll;
+typedef unsigned long long int uintll;
+
+typedef atomic_t atomic32_t;
+
+typedef struct sk_buff        skb_s;
+typedef struct net_device     net_device_s;
+typedef struct net            net_s;
+typedef struct header_ops     header_ops_s;
+typedef struct net_device_ops net_device_ops_s;
+
+#define SKB_USERS(skb) refcount_read(&(skb)->users)
+
+#define SKB_HEAD(skb)      PTR((skb)->head)
+#define SKB_DATA(skb)      PTR((skb)->data)
+#define SKB_TAIL(skb)      PTR(skb_tail_pointer(skb))
+#define SKB_END(skb)       PTR(skb_end_pointer(skb))
+#define SKB_MAC(skb)       PTR(skb_mac_header(skb))
+#define SKB_NETWORK(skb)   PTR(skb_network_header(skb))
+#define SKB_TRANSPORT(skb) PTR(skb_transport_header(skb))
+
+#define PTR(p) ((void*)(p))
+
+#define loop while(1)
+
+#define elif else if
+
+#define for_count(i, count) for (typeof(count) i = 0, __q = (count); i != __q; i++)
+
+#define BE8(x)  (x)
+#ifdef __BIG_ENDIAN
+#define BE16(x) (x)
+#define BE32(x) (x)
+#define BE64(x) (x)
+#else
+#define BE16 __builtin_bswap16
+#define BE32 __builtin_bswap32
+#define BE64 __builtin_bswap64
+#endif
+
+#define ABS_DIFF(a, b) ({ \
+    const typeof(a) _a = a; \
+    const typeof(b) _b = b; \
+    _a >= _b ?    \
+        _a - _b : \
+        _b - _a ; \
+})
+
+#define atomic_get(ptr)      __atomic_load_n (ptr,    __ATOMIC_RELAXED)
+#define atomic_set(ptr, v)   __atomic_store_n(ptr, v, __ATOMIC_RELAXED)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/beep.c linux-master/drivers/net/xgw/beep.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/beep.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/beep.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,61 @@
+
+#define BEEP_STATUS_SILENT   0
+#define BEEP_STATUS_DISABLED 1
+
+static uint beepStatus = 0;
+
+static void beep_do (uint count) {
+
+    unsigned long flags;
+
+    raw_spin_lock_irqsave(&i8253_lock, flags);
+
+    if (count) {
+        count = PIT_TICK_RATE / count;
+        /* set command for counter 2, 2 byte write */
+        outb_p(0xB6, 0x43);
+        /* select desired HZ */
+        outb_p(count & 0xff, 0x42);
+        outb((count >> 8) & 0xff, 0x42);
+        /* enable counter 2 */
+        outb_p(inb_p(0x61) | 3, 0x61);
+    } else {
+        /* disable counter 2 */
+        outb(inb_p(0x61) & 0xFC, 0x61);
+    }
+
+    raw_spin_unlock_irqrestore(&i8253_lock, flags);
+}
+
+static ssize_t __cold_as_ice __optimize_size beep_write (struct file* file, const char __user* ubuf, size_t count, loff_t* ppos) {
+
+    char buff[32];
+
+    if (count == 0)
+        return 0;
+
+    if (count >= sizeof(buff))
+        return -EFAULT;
+
+    if(copy_from_user(buff,ubuf,count))
+        return -EFAULT;
+
+    buff[sizeof(buff) - 1] = 0;
+
+    uint value = 0;
+
+    if (sscanf(buff, "%u", &value) != 1)
+        return -EFAULT;
+
+    // O 1 DESATIVA
+    if ((beepStatus = value) == 1)
+        value = 0;
+
+    beep_do(value);
+
+    return count;
+}
+
+static struct proc_ops beepProcOps = {
+    .proc_write = beep_write,
+};
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd_args_types.h linux-master/drivers/net/xgw/cmd_args_types.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd_args_types.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/cmd_args_types.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,92 @@
+// CHECK IF THE COMMAND MESSAGE IS COMPLETE
+
+#define _CMD_JOIN(a, arg, b) a ## arg ## b
+
+#define CMD_TYPE(arg)    _CMD_JOIN(CMD_, arg, _TYPE)
+#define CMD_LEN(arg)     _CMD_JOIN(CMD_, arg, _LEN)
+#define CMD_LEN_MIN(arg) _CMD_JOIN(CMD_, arg, _LEN_MIN)
+#define CMD_LEN_MAX(arg) _CMD_JOIN(CMD_, arg, _LEN_MAX)
+
+#define CMD_SIZE(arg)      (sizeof(CMD_TYPE(arg)) * CMD_LEN(arg))
+#define CMD_SIZE_MIN(arg)  (sizeof(CMD_TYPE(arg)) * CMD_LEN_MIN(arg))
+#define CMD_SIZE_MAX(arg)  (sizeof(CMD_TYPE(arg)) * CMD_LEN_MAX(arg))
+#define CMD_SIZE_N(arg, n) (sizeof(CMD_TYPE(arg)) * (n))
+
+#define CMD_VALUE(arg) ((const CMD_TYPE(arg)*)cmd)
+
+#define _CMD_CONSUMED(_size) { \
+    ASSERT(size >= (_size)); \
+    size -= (_size); \
+    cmd = PTR(cmd) + (_size); \
+}
+
+#define CMD_CONSUMED(arg)     _CMD_CONSUMED(CMD_SIZE(arg))
+#define CMD_CONSUMED_MIN(arg) _CMD_CONSUMED(CMD_SIZE_MIN(arg))
+#define CMD_CONSUMED_MAX(arg) _CMD_CONSUMED(CMD_SIZE_MAX(arg))
+#define CMD_CONSUMED_N(arg)   _CMD_CONSUMED(CMD_SIZE_N(arg, n))
+
+// SMALLEST AND BIGGEST COMMANDS POSSIBLE
+#define CMD_TOTAL_SIZE_MIN  CMD_SIZE(CODE)
+#define CMD_TOTAL_SIZE_MAX (CMD_SIZE(CODE) + CMD_SIZE(NODE_ID) + CMD_SIZE_MAX(PASSWORD))
+
+#define CMD_ADDR4_LEN          4
+#define CMD_ADDR4_TYPE         u8
+#define CMD_ADDR6_LEN          8
+#define CMD_ADDR6_TYPE         u16
+#define CMD_CODE_LEN           1
+#define CMD_CODE_TYPE          u8
+#define CMD_CONNS_N_LEN        1
+#define CMD_CONNS_N_TYPE       u32
+#define CMD_DID_LEN            1
+#define CMD_DID_TYPE           u8
+#define CMD_DNAME_LEN          DHCP_NAME_SIZE
+#define CMD_DNAME_TYPE         char
+#define CMD_ETH_PROTO_LEN      1
+#define CMD_ETH_PROTO_TYPE     u16
+#define CMD_MAC_LEN            ETH_ALEN
+#define CMD_MAC_TYPE           u8
+#define CMD_MTU_LEN            1
+#define CMD_MTU_TYPE           u16
+#define CMD_NODE_ID_LEN        1
+#define CMD_NODE_ID_TYPE       u16
+#define CMD_NODE_NAME_LEN      NODE_NAME_SIZE
+#define CMD_NODE_NAME_TYPE     char
+#define CMD_PASSWORD_LEN_MAX   PASSWORD_SIZE_MAX
+#define CMD_PASSWORD_LEN_MIN   PASSWORD_SIZE_MIN
+#define CMD_PASSWORD_TYPE      u8
+#define CMD_PATH_ID_LEN        1
+#define CMD_PATH_ID_TYPE       u8
+#define CMD_PATH_NAME_LEN      PATH_NAME_SIZE
+#define CMD_PATH_NAME_TYPE     char
+#define CMD_PATH_PORTS_LEN_MAX PATH_PORTS_N
+#define CMD_PATH_PORTS_LEN_MIN 1
+#define CMD_PATH_PORTS_TYPE    u16
+#define CMD_PHYS_LEN           IFNAMSIZ
+#define CMD_PHYS_TYPE          char
+#define CMD_PORTS_LEN_MAX      PORTS_N
+#define CMD_PORTS_LEN_MIN      1
+#define CMD_PORTS_TYPE         u16
+#define CMD_PPP_SESSION_LEN    1
+#define CMD_PPP_SESSION_TYPE   u16
+#define CMD_RTT_VAR_LEN        1
+#define CMD_RTT_VAR_TYPE       u16
+#define CMD_TIMEOUT_LEN        1
+#define CMD_TIMEOUT_TYPE       u16
+#define CMD_TOS_LEN            1
+#define CMD_TOS_TYPE           u8
+#define CMD_TTL_LEN            1
+#define CMD_TTL_TYPE           u8
+#define CMD_TYPE_LEN           1
+#define CMD_TYPE_TYPE          u8
+#define CMD_VLAN_ID_LEN        1
+#define CMD_VLAN_ID_TYPE       u16
+#define CMD_WEIGHT_ACKS_LEN    1
+#define CMD_WEIGHT_ACKS_TYPE   u8
+#define CMD_WEIGHT_NODE_LEN    1
+#define CMD_WEIGHT_NODE_TYPE   u8
+
+// CMD SIZES:
+// AQUELES QUE USAM PORTA: CONSIDERA O TAMANHO MINIMO DE 1 PORTA, MAS EMBAIXO CHECA TAMBEM O MAXIMO
+// SECRET_SET: SIZE:  // LEMBRAR DE VERIFICAR EMBAIXO TAMBEM,
+// ports
+// password
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd.c linux-master/drivers/net/xgw/cmd.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/cmd.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,1318 @@
+
+// TODO: VAI TER QUE PASSAR O COMANDO ALINHADO,
+// TODO: E AO INVES DE COPIAR SIMPLESMENTE LER
+//      (ou copiar os primeiros 64 bytes) e se for key, copiar o restante
+
+#define MAC(m) \
+    (uint)(m)[0], (uint)(m)[1], (uint)(m)[2], \
+    (uint)(m)[3], (uint)(m)[4], (uint)(m)[5]
+
+#define _PRINT_IP4(a) \
+    (uint)(a)[0], (uint)(a)[1], \
+    (uint)(a)[2], (uint)(a)[3]
+
+#define _PRINT_IP6(a) \
+    (uint)BE16((a)[0]), (uint)BE16((a)[1]), (uint)BE16((a)[2]), (uint)BE16((a)[3]), \
+    (uint)BE16((a)[4]), (uint)BE16((a)[5]), (uint)BE16((a)[6]), (uint)BE16((a)[7])
+
+#define _PRINT_KEYS(K, i) \
+    (uintll)((K)[i + 0]), \
+    (uintll)((K)[i + 1]), \
+    (uintll)((K)[i + 2]), \
+    (uintll)((K)[i + 3]), \
+    (uintll)((K)[i + 4]), \
+    (uintll)((K)[i + 5]), \
+    (uintll)((K)[i + 6]), \
+    (uintll)((K)[i + 7])
+
+#define        _CMD_ERR(x)   e = ___JOIN(CMD_ERR_, x) - 200
+#define         CMD_ERR(x) { e = ___JOIN(CMD_ERR_, x) - 200; goto failed;         }
+#define    FREE_CMD_ERR(x) { e = ___JOIN(CMD_ERR_, x) - 200; goto failed_free;    }
+#define NOTHING_CMD_ERR(x) { e = ___JOIN(CMD_ERR_, x) - 200; goto failed_nothing; }
+#define     CMD_SUCCESS()                                    goto failed
+
+static const u32 cmdSizes [CMDS_N] = {
+#include "cmd_sizes.c"
+};
+
+static inline uint gid_of_nid (const uint nid) {
+
+    for (uint i = 0; i != gwsN; i++)
+        if (gws[i] == nid)
+            return i;
+
+    // NOT FOUND
+    return GWS_N;
+}
+
+static ssize_t __cold_as_ice __optimize_size cmd (struct file *file, const char __user *ubuf, size_t size, loff_t *ppos) {
+
+    // TODO:
+//    *ppos += size;
+
+    int e = size;
+
+    net_device_s* phys = NULL;
+
+    node_s* node; uint nid;
+    path_s* path; uint pid; uint portsN;
+
+    // TAMANHO MINIMO DA MENSAGEM
+    // TAMANHO MAXIMO DA MENSAGEM
+    if (size < CMD_TOTAL_SIZE_MIN ||
+        size > CMD_TOTAL_SIZE_MAX)
+        NOTHING_CMD_ERR(INVALID_CMD_SIZE);
+
+    void* const buff = kmalloc(size, GFP_NOWAIT);
+
+    if (buff == NULL)
+        NOTHING_CMD_ERR(ALLOC_CMD);
+
+    if (copy_from_user(buff, ubuf, size))
+        FREE_CMD_ERR(COPY_CMD);
+
+    const void* cmd = buff;
+
+    const uint C = *CMD_VALUE(CODE);
+
+    if (C >= CMDS_N)
+        FREE_CMD_ERR(INVALID_CMD_CODE);
+
+#if 0
+    printk("XGW: %s #%u SIZE %zd\n", cmdNames[C], C, size);
+#endif
+
+    if (cmdSizes[C] > size)
+        FREE_CMD_ERR(INVALID_CMD_SIZE);
+
+    CMD_CONSUMED(CODE);
+
+    if (C_USE_NID(C)) {
+        if ((nid = *CMD_VALUE(NODE_ID)) >= NODES_N)
+            FREE_CMD_ERR(INVALID_NID);
+        CMD_CONSUMED(NODE_ID);
+    }
+
+    if (C_USE_PID(C)) {
+        if ((pid = *CMD_VALUE(PATH_ID)) >= PATHS_N)
+            FREE_CMD_ERR(INVALID_PID);
+        CMD_CONSUMED(PATH_ID);
+    }
+
+    if (C_USE_PORTS(C)) {
+        if (size % sizeof(u16))
+            FREE_CMD_ERR(INVALID_CMD_SIZE);
+        portsN = size / sizeof(u16);
+        // NOTE: NAO ESTA USANDO CMD_CONSUME() POIS DEPOIS DESTE NÃO VAI LER MAIS NADA
+    }
+
+    // LOCK
+    unsigned long iflags;
+
+    spin_lock_irqsave(&xlock, iflags);
+
+    if (C_USE_NODE(C)) {
+        // REFERS TO A NODE ENTRY
+
+        if (nid == nodeSelf)
+            CMD_ERR(NODE_IS_SELF);
+
+        node = (node_s*)((uintptr_t)nodes[nid] & ~(uintptr_t)1);
+
+        if (node) {
+
+            ASSERT(node->nid == nid);
+
+            // TO BE ON, MUST BE FULL
+            ASSERT(!((node->info & N_ON) && (node->info != (N_ON | N_NAME | N_SECRET | N_CONNS_N | N_MTU))));
+
+            // IF ON, MUST BE RUNNING
+            ASSERT(!((node->info & N_ON) && !node->ptr));
+
+            if (C == CMD_NODE_NEW)
+                CMD_ERR(NODE_EXIST);
+
+            if (C == CMD_NODE_ON)
+                if (node->info & N_ON)
+                    CMD_SUCCESS();
+
+            if (C_NODE_MUST_BE_OFF_IDLE(C)) {
+                if (node->info & N_ON)
+                    CMD_ERR(NODE_IS_ON);
+                if (node->ptr)
+                    CMD_ERR(NODE_IS_STOPPING); // DEVERIA SER 0? +delay/sleep
+                // THE NODE IS OFF AND IDLE
+                ASSERT(!(node->info & N_ON));
+                ASSERT(node->ptr == NULL);
+                ASSERT(!node->kpaths);
+                ASSERT(!node->ipaths);
+                ASSERT(!node->opaths);
+                //ASSERT(node != nodes[nid]);
+            }
+
+        } elif (C != CMD_NODE_NEW)
+            // OPERA SOMENTE EM NODES QUE EXISTEM
+            CMD_ERR(NODE_DONT_EXIST);
+    }
+
+    if (C_USE_PATH(C)) {
+        // REFERS TO A PATH
+
+        path = &node->paths[pid];
+
+        if (path->info) {
+
+            ASSERT(path->info & P_EXIST);
+            ASSERT((path->info & (P_CLIENT | P_SERVER)) != (P_CLIENT | P_SERVER));
+            ASSERT(path->info <= P_ALL);
+            ASSERT(path->sPortsN <= PATH_PORTS_N);
+            ASSERT(path->dPortsN <= PATH_PORTS_N);
+
+            // PARAMETERS
+            ASSERT(!((path->info & P_PHYS   ) && !path->skel.phys));
+            //ASSERT(!((path->info & P_PORT_SRC) && !path->sPortsN));
+            //ASSERT(!((path->info & P_PORT_DST) && !path->dPortsN));
+
+            // I/O DISABLED WHILE IDLE
+            ASSERT(!(((path->info & P_INFO) == path->info) && (node->ipaths & IPATH(pid))));
+            ASSERT(!(((path->info & P_INFO) == path->info) && (node->opaths & OPATH(pid))));
+
+            // I/O ACCORDING TO STATUS
+            ASSERT(!((path->info & K_START)       &&  (node->ipaths & IPATH(pid))));
+            ASSERT(!((path->info & K_START)       &&  (node->opaths & OPATH(pid))));
+            ASSERT(!((path->info & K_SUSPENDING)  &&  (node->opaths & OPATH(pid))));
+            ASSERT(!((path->info & K_SUSPENDING)  &&  (node->ipaths & IPATH(pid))));
+            ASSERT(!((path->info & K_LISTEN)      && !(node->ipaths & IPATH(pid))));
+            ASSERT(!((path->info & K_LISTEN)      &&  (node->opaths & OPATH(pid))));
+            ASSERT(!((path->info & K_ESTABLISHED) && !(node->ipaths & IPATH(pid))));
+
+            // IF ON, MUST BE RUNNING (EXCEPT IF NODE IS OFF)
+            ASSERT(!((path->info & P_ON) && (node->info & N_ON) && !(node->kpaths & KPATH(pid))));
+
+            // RUNNING BUT GOING IDLE
+            // RUNNING AND NOT IDLE
+            // NOT RUNNING AND IDLE
+            ASSERT(((path->info & P_INFO) == path->info) || (node->kpaths & KPATH(pid)));
+
+            if (C == CMD_PATH_NEW)
+                CMD_ERR(PATH_EXIST);
+
+            if (C == CMD_NODE_ON)
+                if (path->info & P_ON)
+                    CMD_SUCCESS();
+
+            if (C_PATH_MUST_BE_OFF_IDLE(C)) {
+                if (path->info & P_ON)
+                    CMD_ERR(PATH_IS_ON);
+                if (node->kpaths & KPATH(pid))
+                    CMD_ERR(PATH_IS_STOPPING); // DEVERIA SER 0? +delay/sleep
+                // THE PATH IS OFF AND IDLE
+                ASSERT(!(path->info & ~P_INFO));
+                ASSERT(!(node->kpaths & KPATH(pid)));
+                ASSERT(!(node->ipaths & IPATH(pid)));
+                ASSERT(!(node->opaths & OPATH(pid)));
+            }
+
+        } elif (C != CMD_PATH_NEW)
+            // OPERA SOMENTE EM PATHS QUE EXISTEM
+            CMD_ERR(PATH_DONT_EXIST);
+    }
+
+    if (C_USE_PHYS(C)) {
+        // MUST HAVE A VALID NAME
+        const char* const itfc = CMD_VALUE(PHYS);
+        if (itfc[0] == '\0' || // EMPTY
+            itfc[IFNAMSIZ - 1] != '\0') // TOO LONG
+            CMD_ERR(INVALID_PHYS);
+        // LOOKUP IT, OWNED
+        phys = dev_get_by_name(&init_net, itfc);
+        // MUST EXIST
+        if (phys == NULL)
+            CMD_ERR(PHYS_NOT_FOUND);
+        // CANNOT BE THE VPN ITSELF
+        if (phys == xgw)
+            CMD_ERR(PHYS_IS_XGW);
+        // VALIDATE INTERFACE TYPE, FLAGS ETC
+        if (0)
+            CMD_ERR(PHYS_IS_BAD);
+        CMD_CONSUMED(PHYS);
+    }
+
+    //
+    switch (C) {
+        case CMD_PATH_SET_ETH_DST:
+        case CMD_PATH_CLR_ETH_SRC:
+        case CMD_PATH_SET_ETH_SRC:
+        case CMD_PATH_CLR_ETH_DST:
+            if (!path_is_eth(path))
+                CMD_ERR(PATH_NOT_ETH);
+            break;
+        case CMD_PATH_SET_VLAN_PROTO:
+        case CMD_PATH_CLR_VLAN_PROTO:
+        case CMD_PATH_SET_VLAN_ID:
+        case CMD_PATH_CLR_VLAN_ID:
+            if (!path_is_vlan(path))
+                CMD_ERR(PATH_NOT_VLAN);
+            ASSERT(path_is_eth(path));
+            break;
+        case CMD_PATH_SET_IP4_TOS:
+        case CMD_PATH_CLR_IP4_TOS:
+        case CMD_PATH_SET_IP4_TTL:
+        case CMD_PATH_CLR_IP4_TTL:
+        case CMD_PATH_SET_IP4_SRC:
+        case CMD_PATH_CLR_IP4_SRC:
+        case CMD_PATH_SET_IP4_DST:
+        case CMD_PATH_CLR_IP4_DST:
+            if (!path_is_ip4(path))
+                CMD_ERR(PATH_NOT_IP4);
+            break;
+        case CMD_PATH_SET_IP6_TOS:
+        case CMD_PATH_CLR_IP6_TOS:
+        case CMD_PATH_SET_IP6_TTL:
+        case CMD_PATH_CLR_IP6_TTL:
+        case CMD_PATH_SET_IP6_SRC:
+        case CMD_PATH_CLR_IP6_SRC:
+        case CMD_PATH_SET_IP6_DST:
+        case CMD_PATH_CLR_IP6_DST:
+            if (!path_is_ip6(path))
+                CMD_ERR(PATH_NOT_IP6);
+            break;
+        case CMD_PATH_SET_IP_TOS:
+        case CMD_PATH_SET_IP_TTL:
+            if (!(path->info & P_SERVER))
+                CMD_ERR(PATH_NOT_SERVER);
+            break;
+        case CMD_PATH_SET_UDP_SRC:
+        case CMD_PATH_CLR_UDP_SRC:
+        case CMD_PATH_SET_UDP_DST:
+        case CMD_PATH_CLR_UDP_DST:
+            if (!path_is_udp(path))
+                CMD_ERR(PATH_NOT_UDP);
+            break;
+        case CMD_PATH_SET_TCP_SRC:
+        case CMD_PATH_CLR_TCP_SRC:
+        case CMD_PATH_SET_TCP_DST:
+        case CMD_PATH_CLR_TCP_DST:
+            if (!path_is_tcp(path))
+                CMD_ERR(PATH_NOT_TCP);
+            break;
+        case CMD_PATH_SET_PPP_SESSION:
+            if (!path_is_ppp(path))
+                CMD_ERR(PATH_NOT_PPP);
+            break;
+    }
+
+    //
+    switch (C) {
+        case CMD_PATH_SET_UDP_SRC:
+        case CMD_PATH_SET_UDP_DST:
+        case CMD_PATH_SET_TCP_SRC:
+        case CMD_PATH_SET_TCP_DST:
+            if (portsN > PATH_PORTS_N)
+                CMD_ERR(INVALID_PORTS_N);
+            break;
+        case CMD_PORT_ON:
+        case CMD_PORT_OFF:
+        case CMD_PORT_GET:
+            if (portsN > UDP_PORTS_N)
+                CMD_ERR(INVALID_PORTS_N);
+            break;
+    }
+
+    switch ((enum CMD)C) {
+
+        case CMD_PORT_ON: {
+
+            while (portsN--)
+                ports_enable(CMD_VALUE(PORTS)[portsN]);
+
+        } break;
+
+        case CMD_PORT_OFF: {
+
+            while (portsN--)
+                ports_disable(CMD_VALUE(PORTS)[portsN]);
+
+        } break;
+
+        case CMD_PORTS_CLEAR: {
+
+            // TODO: PARA QUE ESSE COMANDO MESMO??????????
+            for_count (p, PORTS_N)
+                ports_disable(p);
+
+        } break;
+
+        case CMD_PORT_GET: {
+
+        } break;
+
+        case CMD_PORTS_LIST: {
+
+        } break;
+
+        case CMD_PHYS_ATTACH: { // TODO: USAGE COUNT NOS HOOKS
+
+            rtnl_lock();
+
+            if (!phys->xgw) {
+                phys->xgw = true;
+                // KEEP HOLDING IT
+                phys = NULL;
+            }
+
+            rtnl_unlock();
+
+        } break;
+
+        case CMD_PHYS_DETACH: {
+
+            rtnl_lock();
+
+            if (phys->xgw) {
+                phys->xgw = false;
+                // RELEASE AGAIN THE DEVICE
+                dev_put(phys);
+            }
+
+            rtnl_unlock();
+
+        } break;
+
+        case CMD_PHYS_LIST: {
+
+        } break;
+
+        case CMD_SELF_SET: {
+
+            nodeSelf = nid;
+
+            // TODO: FIXME: FIX EVERYTHING
+
+        } break;
+
+        case CMD_SELF_GET: {
+
+            printk("XGW: SELF: %u\n", (uint)nodeSelf);
+
+        } break;
+
+        case CMD_GWS_INSERT: {
+
+            if (gid_of_nid(nid) != GWS_N)
+                // JA TEM
+                CMD_ERR(GWS_NID_ALREADY);
+
+            if (gwsN == GWS_N)
+                // FULL
+                CMD_ERR(GWS_FULL);
+
+            // POE ELE NO FINAL
+            gws[gwsN++] = nid;
+
+        } break;
+
+        case CMD_GWS_REMOVE: {
+
+            const uint gid = gid_of_nid(nid);
+
+            if (gid == GWS_N)
+                // NAO TEM
+                CMD_ERR(GWS_NID_NOT_FOUND);
+
+            // ARRASTA O ULTIMO PARA CIMA DELE
+            gws[gid] = gws[--gwsN];
+
+        } break;
+
+        // TODO: CMD_GWS_INDEX get gw index of node
+
+        case CMD_GWS_LIST: {
+
+            printk("XGW: HAS %u GWS\n", (uint)gwsN);
+
+            for (uint i = 0; i != gwsN; i++)
+                printk("XGW: GW [%u] -> %u\n", i, (uint)gws[i]);
+
+        } break;
+
+        case CMD_GWS_CLEAR: {
+
+        } break;
+
+        case CMD_PATH_DEL: {
+
+            node->weights -= path->weight;
+
+            // REMOVE P_EXIST AND K_*
+            memset(path, 0, sizeof(path_s));
+
+        } break;
+
+        case CMD_PATH_ON: {
+
+            uint pinfo = path->info;
+
+            if (!(pinfo & P_ON)) {
+                // TODO: ALL THIS if(!(pinfo & FLAG)) CMD_ERR(PATH_NEED_FLAG)
+                //      CAN BECOME A SIMPLE MASK AND A if ((x = flags_needed & ~pinfo)) CMD_ERR(CMD_NEED_FLAG + CLZ(x))
+
+                // INFORMACOES QUE SAO NECESSARIAS TO START A PATH
+                if (!(pinfo & P_NAME))              CMD_ERR(PATH_NEED_NAME);
+                if (!(pinfo & P_RTT_VAR))           CMD_ERR(PATH_NEED_RTT_VAR);
+                if (!(pinfo & (P_CLIENT|P_SERVER))) CMD_ERR(PATH_NEED_CLT_SRV);
+
+                //
+                ASSERT((pinfo & (P_CLIENT | P_SERVER))
+                             != (P_CLIENT | P_SERVER));
+
+                // ALGUMAS COISAS DEPENDEM DE OUTRAS E SÓ PODEM SER CHECADAS EM CONJUNTO
+                const uint type = path->skel.type;
+
+                if (pinfo & P_SERVER) {
+                    // SERVER
+
+                    if (!(pinfo & P_TOS)) CMD_ERR(PATH_NEED_TOS);
+                    if (!(pinfo & P_TTL)) CMD_ERR(PATH_NEED_TTL);
+
+                    // ON SERVER MODE, THOSE WILL BE OVERWRITTEN ANYWAY
+                    pinfo &= ~(P_PHYS | P_DHCP | P_DHCP_MAC_DST_SERVER | P_DHCP_MAC_DST_GW | __P_TYPE_CLR);
+
+                } else {
+                    // CLIENT
+
+                    if (pinfo & P_DHCP) {
+                        // USING DHCP
+
+                        if (type & __IP4) {
+                            if (1)
+                                // O PATH É IPV4 E O DHCP NÃO É IPV4
+                                CMD_ERR(PATH_USE_DHCP_NOT_IP_4);
+                        } elif (type & __IP6) {
+                            if (1)
+                                // O PATH É IPV6 E O DHCP NÃO É IPV6
+                                CMD_ERR(PATH_USE_DHCP_NOT_IP_6);
+                        } else // O PATH NÃO É IP E USA DHCP
+                                CMD_ERR(PATH_USE_DHCP_NOT_IP);
+
+                        //
+                        pinfo |= P_PHYS;
+                        // type & __ETH
+                        pinfo |= P_MAC_SRC;
+                        // type & __VLAN
+                        pinfo |= P_VPROTO;
+                        pinfo |= P_VID;
+                        pinfo |= P_ADDR_SRC;
+
+                        // VAI TER QUE VERIFICAR O TAL DHCP AQUI
+                        // E CARREGAR O QUE ELE CONTEM: __VLAN, __ETH, ETC
+                        //     tem que dar match no path->skel.type e no dhcp->type
+
+                        //      se tiver __ETH, carregar o pinfo |= P_MAC_SRC
+                        //      se tiver __ETH, carregar o pinfo |= P_MAC_DST (GW / SERVER) SE O P_DHCP_ETH_DST_XXX ESTIVER SETADO
+                        //      se tiver __IP4, carregar o pinfo |= P_ADDR_SRC
+                        if (pinfo & (P_DHCP_MAC_DST_SERVER | P_DHCP_MAC_DST_GW))
+                            pinfo |= P_MAC_DST;
+
+                        //  marcar o dhcp->users++
+                        //      e assim enquanto tiver paths P_ON com tal dhcp, nao pode mudar o tipo dele, e nem deleta-lo
+                    }
+
+                    if (!(pinfo & P_PHYS)) CMD_ERR(PATH_NEED_PHYS);
+
+                    if (type & __ETH) {
+                        if (!(pinfo & P_MAC_SRC)) CMD_ERR(PATH_NEED_MAC_SRC);
+                        if (!(pinfo & P_MAC_DST)) CMD_ERR(PATH_NEED_MAC_DST);
+                    }
+
+                    if (type & __VLAN) {
+                        if (!(pinfo & P_VPROTO)) CMD_ERR(PATH_NEED_VLAN_PROTO);
+                        if (!(pinfo & P_VID))    CMD_ERR(PATH_NEED_VLAN_ID);
+                    }
+
+                    if (type & (__IP4 | __IP6)) {
+                        if (!(pinfo & P_TOS))      CMD_ERR(PATH_NEED_TOS);
+                        if (!(pinfo & P_TTL))      CMD_ERR(PATH_NEED_TTL);
+                        if (!(pinfo & P_ADDR_SRC)) CMD_ERR(PATH_NEED_ADDR_SRC);
+                        if (!(pinfo & P_ADDR_DST)) CMD_ERR(PATH_NEED_ADDR_DST);
+                    }
+
+                    if (type & (__UDP | __TCP)) {
+                        if (!(pinfo & P_PORT_SRC)) CMD_ERR(PATH_NEED_PORT_SRC);
+                        if (!(pinfo & P_PORT_DST)) CMD_ERR(PATH_NEED_PORT_DST);
+                    }
+
+                    // ON DHCP MODE, THOSE WILL BE OVERWRITTEN ANYWAY
+                    if (pinfo & P_DHCP)
+                        pinfo &= ~(P_PHYS | P_MAC_SRC | P_ADDR_SRC | P_VPROTO | P_VID);
+                    if (pinfo & (P_DHCP_MAC_DST_SERVER | P_DHCP_MAC_DST_GW))
+                        pinfo &= ~P_MAC_DST;
+                }
+
+                // TODO:
+                if (0) // !(pinfo & P_SYN)
+                    path->syn = node->syns[pid];
+
+                // IF THE NODE IS ON, START THE PATH NOW
+                if (node->info & N_ON) {
+                    node->kpaths |= KPATH(pid);
+                    pinfo |= K_START;
+                }
+
+                path->info = pinfo | P_ON;
+            }
+
+        } break;
+
+        case CMD_PATH_OFF: {
+
+            if (path->info & P_ON)
+                path->info ^= P_ON;
+            if (path->info & (K_START | K_LISTEN | K_ESTABLISHED))
+                path->info = (path->info & P_INFO) | K_SUSPEND;
+
+        } break;
+
+        case CMD_PATH_CLR_WEIGHT_NODE: {
+
+            node->weights -= path->weight;
+            path->weight   = 0;
+
+        } break;
+
+        case CMD_PATH_CLR_WEIGHT_ACKS: { // TODO:
+
+            path->weight_acks = 0;
+
+        } break;
+
+        case CMD_NODE_STATUS: {
+
+            printk("XGW: %s: ID %u\n",            node->name, (uint  )node->nid);
+            printk("XGW: %s: KPATHS %04X\n",      node->name, (uint  )node->kpaths);
+            printk("XGW: %s: IPATHS %04X\n",      node->name, (uint  )node->ipaths);
+            printk("XGW: %s: OPATHS %016llX\n",   node->name, (uintll)node->opaths);
+            printk("XGW: %s: MTU %u\n",           node->name, (uint  )node->mtu);
+            printk("XGW: %s: CONNS N %u\n",       node->name, (uint  )node->connsN);
+            printk("XGW: %s: WEIGHTS %u\n",       node->name, (uint  )node->weights);
+
+            printk("XGW: %s: INFO: 0x%02X %s%s%s%s%s\n", node->name,
+               (uint)node->info,
+                    (node->info & N_ON      ) ? " ON"      : "",
+                    (node->info & N_NAME    ) ? " NAME"    : "",
+                    (node->info & N_MTU     ) ? " MTU"     : "",
+                    (node->info & N_CONNS_N ) ? " CONNS-N" : "",
+                    (node->info & N_SECRET  ) ? " SECRET"  : ""
+            );
+
+            for_count (i, K_LEN / 8) printk("XGW: %s: IKEYS SYN  %016llX %016llX %016llX %016llX %016llX %016llX %016llX %016llX\n", node->name, _PRINT_KEYS(node->iKeys[I_KEY_SYN], i));
+            for_count (i, K_LEN / 8) printk("XGW: %s: OKEYS SYN  %016llX %016llX %016llX %016llX %016llX %016llX %016llX %016llX\n", node->name, _PRINT_KEYS(node->oKeys[O_KEY_SYN], i));
+
+            for_count (i, K_LEN / 8) printk("XGW: %s: IKEYS PING %016llX %016llX %016llX %016llX %016llX %016llX %016llX %016llX\n", node->name, _PRINT_KEYS(node->iKeys[I_KEY_PING], i));
+            for_count (i, K_LEN / 8) printk("XGW: %s: OKEYS PING %016llX %016llX %016llX %016llX %016llX %016llX %016llX %016llX\n", node->name, _PRINT_KEYS(node->oKeys[O_KEY_PING], i));
+
+            for_count (i, K_LEN / 8) printk("XGW: %s: IKEYS PONG %016llX %016llX %016llX %016llX %016llX %016llX %016llX %016llX\n", node->name, _PRINT_KEYS(node->iKeys[I_KEY_PONG], i));
+            for_count (i, K_LEN / 8) printk("XGW: %s: OKEYS PONG %016llX %016llX %016llX %016llX %016llX %016llX %016llX %016llX\n", node->name, _PRINT_KEYS(node->oKeys[O_KEY_PONG], i));
+
+        } break;
+
+        case CMD_PATH_STATUS: {
+
+            printk("XGW: %s [%s]: WEIGHT %u\n",          node->name, path->name, (uint)path->weight);
+            printk("XGW: %s [%s]: TTL %u\n",             node->name, path->name, (uint)path->ttl);
+            printk("XGW: %s [%s]: TOS %02X\n",           node->name, path->name, (uint)path->tos);
+            printk("XGW: %s [%s]: RTT MAX %ums\n",       node->name, path->name, (uint)path->rtt_max);
+            printk("XGW: %s [%s]: RTT %ums\n",           node->name, path->name, (uint)path->rtt);
+            printk("XGW: %s [%s]: RTT VAR_ %ums\n",      node->name, path->name, (uint)path->rtt_var_);
+            printk("XGW: %s [%s]: RTT VAR %ums\n",       node->name, path->name, (uint)path->rtt_var);
+            printk("XGW: %s [%s]: CDOWN %u\n",           node->name, path->name, (uint)path->cdown);
+            printk("XGW: %s [%s]: OADD %u\n",            node->name, path->name, (uint)path->oadd);
+            printk("XGW: %s [%s]: OLATENCY %u\n",        node->name, path->name, (uint)path->olatency);
+            printk("XGW: %s [%s]: SINCE %llu\n",         node->name, path->name, (uintll)path->since);
+            printk("XGW: %s [%s]: TDIFF %lld\n",         node->name, path->name, (intll)path->tdiff);
+            printk("XGW: %s [%s]: PING SENT %llu\n",     node->name, path->name, (uintll)path->asked);
+            printk("XGW: %s [%s]: PONG RECEIVED %llu\n", node->name, path->name, (uintll)path->answered);
+            printk("XGW: %s [%s]: PING SEEN %llu\n",     node->name, path->name, (uintll)path->pseen[0]);
+            printk("XGW: %s [%s]: PONG SEEN %llu\n",     node->name, path->name, (uintll)path->pseen[1]);
+            printk("XGW: %s [%s]: SYN %016llX\n",        node->name, path->name, (uintll)path->syn);
+            printk("XGW: %s [%s]: MASK %016llX\n",       node->name, path->name, (uintll)path->mask);
+            printk("XGW: %s [%s]: SPORT #%u OF %u\n",    node->name, path->name, (uint)path->sPortIndex, (uint)path->sPortsN);
+            printk("XGW: %s [%s]: DPORT #%u OF %u\n",    node->name, path->name, (uint)path->dPortIndex, (uint)path->dPortsN);
+
+            printk("XGW: %s [%s]: INFO: 0x%02X%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n", node->name, path->name,
+           (uint)path->info,
+        (path->info & P_ON                  ) ? " ON"             : "",
+        (path->info & P_CLIENT              ) ? " CLIENT"         : "",
+        (path->info & P_SERVER              ) ? " SERVER"         : "",
+        (path->info & P_PHYS                ) ? " PHYS"           : "",
+        (path->info & P_MAC_SRC             ) ? " MAC-SRC"        : "",
+        (path->info & P_MAC_DST             ) ? " MAC-DST"        : "",
+        (path->info & P_ADDR_SRC            ) ? " ADDR-SRC"       : "",
+        (path->info & P_ADDR_DST            ) ? " ADDR-DST"       : "",
+        (path->info & P_PORT_SRC            ) ? " PORT-SRC"       : "",
+        (path->info & P_PORT_DST            ) ? " PORT-DST"       : "",
+        (path->info & P_VPROTO              ) ? " VPROTO"         : "",
+        (path->info & P_VID                 ) ? " VID"            : "",
+        (path->info & P_TOS                 ) ? " TOS"            : "",
+        (path->info & P_TTL                 ) ? " TTL"            : "",
+        (path->info & P_RTT_VAR             ) ? " LATENCY-VAR"    : "",
+        (path->info & P_NAME                ) ? " NAME"           : "",
+        (path->info & P_DHCP                ) ? " DHCP"           : "",
+        (path->info & P_DHCP_MAC_DST_SERVER ) ? " MAC-DST-SERVER" : "",
+        (path->info & P_DHCP_MAC_DST_GW     ) ? " MAC-DST-GW"     : "",
+        (path->info & P_EXIST               ) ? " EXIST"          : "",
+        (path->info & K_START               ) ? " START"          : "",
+        (path->info & K_SUSPEND             ) ? " SUSPEND"        : "",
+        (path->info & K_SUSPENDING          ) ? " SUSPENDING"     : "",
+        (path->info & K_LISTEN              ) ? " LISTEN"         : "",
+        (path->info & K_ESTABLISHED         ) ? " ESTABLISHED"    : "",
+        (path->info & ~P_ALL                ) ? " UNKNOWN"        : ""
+            );
+
+            printk("XGW: %s [%s]: PHYS %s\n", node->name, path->name,
+                path->skel.phys ?
+                path->skel.phys->name : "-- NULL --"
+            );
+
+            printk("XGW: %s [%s]: SKB PROTO 0x%04X\n", node->name, path->name,
+                BE16(path->skel.protocol)
+            );
+
+            const hdr_eth_s*  const eth  = PKT_ETH  (&path->skel);
+            const hdr_vlan_s* const vlan = PKT_VLAN (&path->skel);
+            const hdr_ppp_s*  const ppp  = PKT_PPP  (&path->skel);
+            const hdr_ip4_s*  const ip4  = PKT_IP4  (&path->skel);
+            const hdr_ip6_s*  const ip6  = PKT_IP6  (&path->skel);
+            const hdr_udp_s*  const udp  = PKT_UDP  (&path->skel);
+            const hdr_tcp_s*  const tcp  = PKT_TCP  (&path->skel);
+
+            if (path_is_eth(path)) {
+                printk("XGW: %s [%s]: ETH SRC %02x:%02x:%02x:%02x:%02x:%02x\n", node->name, path->name, MAC(eth->smac));
+                printk("XGW: %s [%s]: ETH DST %02x:%02x:%02x:%02x:%02x:%02x\n", node->name, path->name, MAC(eth->dmac));
+                printk("XGW: %s [%s]: ETH PROTO 0x%04X\n",                      node->name, path->name, BE16(eth->proto));
+            }
+
+            if (path_is_vlan(path)) {
+                printk("XGW: %s [%s]: VLAN ID 0x%04X\n",    node->name, path->name, BE16(vlan->id));
+                printk("XGW: %s [%s]: VLAN PROTO 0x%04X\n", node->name, path->name, BE16(vlan->proto));
+            }
+
+            if (path_is_ppp(path)) {
+                printk("XGW: %s [%s]: PPP CODE 0x%04X\n",    node->name, path->name, BE16(ppp->code));
+                printk("XGW: %s [%s]: PPP SESSION 0x%04X\n", node->name, path->name, BE16(ppp->session));
+                printk("XGW: %s [%s]: PPP SIZE 0x%04X\n",    node->name, path->name, BE16(ppp->size));
+                printk("XGW: %s [%s]: PPP PROTO 0x%04X\n",   node->name, path->name, BE16(ppp->proto));
+            }
+
+            if (path_is_ip4(path)) {
+                printk("XGW: %s [%s]: IP4 TOS 0x%02X\n",      node->name, path->name,  (uint)BE8(ip4->tos));
+                printk("XGW: %s [%s]: IP4 TTL %u\n",          node->name, path->name,  (uint)BE8(ip4->ttl));
+                printk("XGW: %s [%s]: IP4 PROTO 0x%02X\n",    node->name, path->name,  (uint)BE8(ip4->proto));
+                printk("XGW: %s [%s]: IP4 SRC %u.%u.%u.%u\n", node->name, path->name, _PRINT_IP4(ip4->saddr));
+                printk("XGW: %s [%s]: IP4 DST %u.%u.%u.%u\n", node->name, path->name, _PRINT_IP4(ip4->daddr));
+            }
+
+            if (path_is_ip6(path)) {
+                printk("XGW: %s [%s]: IP6 TOS ???\n",                                     node->name, path->name);
+                printk("XGW: %s [%s]: IP6 TTL %u\n",                                      node->name, path->name, (uint)BE8(ip6->ttl));
+                printk("XGW: %s [%s]: IP6 PROTO 0x%02X\n",                                node->name, path->name, (uint)BE8(ip6->proto));
+                printk("XGW: %s [%s]: IP6 SRC %04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X\n", node->name, path->name, _PRINT_IP6(ip6->saddr));
+                printk("XGW: %s [%s]: IP6 DST %04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X\n", node->name, path->name, _PRINT_IP6(ip6->daddr));
+            }
+
+            if (path_is_udp(path)) {
+                printk("XGW: %s [%s]: UDP SRC %u\n", node->name, path->name, (uint)BE16(udp->sport));
+                printk("XGW: %s [%s]: UDP DST %u\n", node->name, path->name, (uint)BE16(udp->dport));
+            }
+
+            if (path_is_tcp(path)) {
+                printk("XGW: %s [%s]: TCP SRC %u\n", node->name, path->name, (uint)BE16(tcp->sport));
+                printk("XGW: %s [%s]: TCP DST %u\n", node->name, path->name, (uint)BE16(tcp->dport));
+            }
+
+        //u64 acks; // HISTORY
+        //u16 ports [PATH_PORTS_N]; // EM BIG ENDIAN
+
+        } break;
+
+        case CMD_PATH_STATS: {
+
+        } break;
+
+        case CMD_NODE_STATS: {
+
+        } break;
+
+        case CMD_NODE_NEW: {
+
+            node_s* const node = paged_alloc(sizeof(node_s));
+
+            if (node == NULL)
+                CMD_ERR(ALLOC_NODE);
+
+            // INITIALIZE
+         // node->opaths       = 0
+         // node->ipaths       = 0
+         // node->kpaths       = 0
+         // node->conns        = NULL
+         // node->connsN       = 0
+         // node->info         = 0
+         // node->weights      = 0
+         // node->mtu          = 0
+         // node->iCycle       = 0
+         // node->oCycle       = 0
+         // node->oIndex       = 0
+         // node->ptr          = NULL
+         // node->next         = NULL
+         // node->name[*]      = '\0'
+         // node->oVersions[*] = 0
+            memset(node, 0, NODE_SIZE_INIT);
+
+            node->nid = nid;
+#ifdef CONFIG_XGW_NMAP
+            node->gw = nmap[nid];
+#endif
+            node->dev = xgw;
+
+            //
+            node->oVersions[O_KEY_SYN ] = I_KEY_SYN;
+            node->oVersions[O_KEY_PING] = I_KEY_PING;
+            node->oVersions[O_KEY_PONG] = I_KEY_PONG;
+
+            nodes_set_off(nid, node);
+
+        } break;
+
+        case CMD_NODE_DEV_CREATE: {
+
+            if (node->dev != xgw)
+                // O NODE JA TEM UMA INTERFACE PROPRIA
+                CMD_ERR(ALLOC_NODE); // TODO:
+
+            const char* const itfc = CMD_VALUE(PHYS);
+
+            net_device_s* const dev = dev_create_node(itfc, nid);
+
+            if (dev == NULL)
+                CMD_ERR(ALLOC_NODE); // TODO:
+
+            node->dev = dev;
+
+        } break;
+
+        case CMD_NODE_DEV_DEL: {
+
+            net_device_s* const dev = node->dev;
+
+            if (dev == xgw)
+                // O NODE NAO TEM UMA INTERFACE PROPRIA
+                CMD_ERR(ALLOC_NODE); // TODO:
+
+            //
+            node->dev = xgw;
+
+            //
+            unregister_netdev(dev);
+
+            free_netdev(dev);
+
+        } break;
+
+        case CMD_NODE_ON: {
+
+            //
+            if ((node->info & (N_NAME | N_SECRET | N_CONNS_N | N_MTU))
+                           != (N_NAME | N_SECRET | N_CONNS_N | N_MTU))
+                CMD_ERR(NODE_NOT_CONFIGURED);
+
+            // READY TO START
+            node->info   |= N_ON;
+            node->iCycle  = 0;
+            node->oCycle  = 0;
+            node->oIndex  = 0;
+
+            // WAKE NODE
+            __link(node, knodes);
+
+            // BALANCE CONNECTIONS BETWEEN PATHS
+            for_count (cid, (uint)node->connsN)
+                node->conns[cid] = cid % PATHS_N;
+
+            // NO DYNAMIC KEYS CREATED YET
+            random64_n((u64*)&node->iKeys, I_KEYS_DYNAMIC * K_LEN, SUFFIX_ULL(CONFIG_XGW_RANDOM_INIT_IPAIRS));
+            random64_n((u64*)&node->oKeys, O_KEYS_DYNAMIC * K_LEN, SUFFIX_ULL(CONFIG_XGW_RANDOM_INIT_OPAIRS));
+
+            // START ON PATHS
+            for_count (pid, PATHS_N) {
+
+                path_s* const path = &node->paths[pid];
+
+                ASSERT(!(path->info & ~P_INFO));
+
+                if (path->info & P_ON) {
+                    path->info |= K_START;
+                    node->kpaths |= KPATH(pid);
+                }
+            }
+
+            //
+            nodes_set_on(nid, node);
+
+        } break;
+
+        case CMD_NODE_OFF: {
+
+            if (node->info & N_ON) {
+                node->info ^= N_ON;
+
+                // STOP ACTIVE PATHS
+                for_count (pid, PATHS_N) {
+
+                    path_s* const path = &node->paths[pid];
+
+                    if (path->info & (K_START | K_LISTEN | K_ESTABLISHED))
+                        path->info = (path->info & P_INFO) | K_SUSPEND;
+                }
+            }
+
+        } break;
+
+        case CMD_NODE_SET_SECRET: {
+
+            if (size < PASSWORD_SIZE_MIN
+             || size > PASSWORD_SIZE_MAX)
+                CMD_ERR(INVALID_PASSWORD_LEN);
+
+            secret_derivate_from_password(node->secret, cmd, size);
+
+            // TODO: TERA DE FAZER COM TODOS AO MODIFICAR O SELF
+            reset_node_ping_keys(node, nodeSelf, nid);
+
+            node->info |= N_SECRET;
+
+        } break;
+
+        case CMD_NODE_SET_CONNS_N: {
+
+            const uint connsN = *CMD_VALUE(CONNS_N);
+
+            CMD_CONSUMED(CONNS_N);
+
+            if (connsN < CONNS_MIN ||
+                connsN > CONNS_MAX)
+                CMD_ERR(INVALID_CONNS_N);
+
+            if (connsN != node->connsN) {
+
+                u64* const conns = paged_alloc(CONNS_SIZE(connsN));
+
+                if (conns == NULL)
+                    CMD_ERR(ALLOC_CONNS);
+
+                if (node->conns)
+                    paged_free(node->conns, CONNS_SIZE(node->connsN));
+
+                node->conns = conns;
+                node->connsN = connsN;
+                node->info |= N_CONNS_N;
+            }
+
+        } break;
+
+        case CMD_PATH_NEW: {
+
+            // INITIALIZE
+         // path->info         = 0
+         // path->weight       = 0
+         // path->weight_acks  = 0
+         // path->since        = 0
+         // path->timeout      = 0
+         // path->acks         = 0
+         // path->asked        = 0
+         // path->answered     = 0
+         // path->syn          = 0
+         // path->rtime        = 0
+         // path->tdiff        = 0
+         // path->tos          = 0
+         // path->ttl          = 0
+         // path->rtt_max      = 0
+         // path->rtt          = 0
+         // path->rtt_var_     = 0
+         // path->rtt_var      = 0
+         // path->cdown        = 0
+         // path->node         = NULL
+         // path->next         = NULL
+         // path->skel.phys    = NULL
+         // path->skel.type    = 0
+         // path->sPortsN      = 0
+         // path->sPortIndex   = 0
+         // path->dPortsN      = 0
+         // path->dPortIndex   = 0
+         // path->sPorts[0]    = 0
+         // path->dPorts[0]    = 0
+         // path->name[*]      = 0
+         // path->skel.phys    = NULL
+            memset(path, 0, sizeof(path_s));
+
+            path->info    = P_EXIST;
+            path->node    = node;
+            path->rtt_max = RTT_MAX;
+            path->oadd    = PATH_OADD_DEFAULT;
+            path->mask    = PMASK_MIN;
+
+        } break;
+
+        case CMD_PATH_SET_PHYS: {
+            // TODO: UNREFCOUNT OUR HOOK USAGE VAI SER UM PROBLEMAO POIS OS LISTENINGS PODEM ACABAR DESCOBRINDO ELA :S - basta reverificar se esta hookado ao dar o accept e/ou SUSPEND
+            // TODO: HUMMM O ACCEPT NAO DEVE SETAR O P_PHYS
+
+            if (!phys->xgw)
+                CMD_ERR(PHYS_NOT_HOOKED);
+
+            path->skel.phys = phys;
+            path->info |= P_PHYS;
+
+        } break;
+
+        case CMD_PATH_SET_DHCP: {
+
+            // NOTE: SO FAZ SENTIDO SE FOR CLIENTE
+         // path->dhcp = *CMD_VALUE(did);
+            path->info |= P_DHCP;
+
+        } break;
+
+        case CMD_PATH_SET_TYPE: {
+
+            net_device_s* const phys = path->skel.phys;
+
+            const uint type = *CMD_VALUE(TYPE);
+
+            switch (type) {
+                case H_TYPE_RAW:
+                case H_TYPE_IP4:
+                case H_TYPE_IP4_UDP:
+                case H_TYPE_IP4_TCP:
+                case H_TYPE_IP6:
+                case H_TYPE_IP6_UDP:
+                case H_TYPE_IP6_TCP:
+                case H_TYPE_ETH:
+                case H_TYPE_ETH_IP4:
+                case H_TYPE_ETH_IP4_UDP:
+                case H_TYPE_ETH_IP4_TCP:
+                case H_TYPE_ETH_IP6:
+                case H_TYPE_ETH_IP6_UDP:
+                case H_TYPE_ETH_IP6_TCP:
+                case H_TYPE_ETH_VLAN:
+                case H_TYPE_ETH_VLAN_IP4:
+                case H_TYPE_ETH_VLAN_IP4_UDP:
+                case H_TYPE_ETH_VLAN_IP4_TCP:
+                case H_TYPE_ETH_VLAN_IP6:
+                case H_TYPE_ETH_VLAN_IP6_UDP:
+                case H_TYPE_ETH_VLAN_IP6_TCP:
+                case H_TYPE_ETH_VLAN_PPP:
+                case H_TYPE_ETH_VLAN_PPP_IP4:
+                case H_TYPE_ETH_VLAN_PPP_IP6:
+                case H_TYPE_ETH_PPP:
+                case H_TYPE_ETH_PPP_IP4:
+                case H_TYPE_ETH_PPP_IP6:
+                    break;
+                default:
+                    CMD_ERR(INVALID_TYPE);
+            }
+
+            memcpy(&path->skel, &models[type], sizeof(pkt_s));
+
+            ASSERT(path->skel.type == type);
+
+            // TODO: ANY OTHER INFO TO RESTORE AFTER ABOVE COPY?
+            path->skel.x.src  = BE16(nodeSelf);
+            path->skel.x.dst  = BE16(nid);
+            path->skel.x.path = BE8(pid);
+            path->skel.phys   = phys;
+
+            // SE MUDA O TIPO, PERDE OS OUTROS PARAMETROS
+            path->info &= ~__P_TYPE_CLR;
+
+        } break;
+
+        case CMD_PATH_SET_VLAN_PROTO: {
+
+            const uint eProto = *CMD_VALUE(ETH_PROTO);
+
+            if (eProto != ETH_P_8021Q &&
+                eProto != ETH_P_8021AD)
+                CMD_ERR(INVALID_VPROTO);
+
+            path->info |= P_VPROTO;
+
+            PKT_ETH(&path->skel)->proto = BE16(eProto);
+
+            path->skel.protocol = BE16(eProto);
+
+        } break;
+
+        case CMD_PATH_SET_VLAN_ID: {
+
+            const uint vid = *CMD_VALUE(VLAN_ID);
+
+            if (vid > 0x7fff)
+                CMD_ERR(INVALID_VID);
+
+            path->info |= P_VID;
+
+            PKT_VLAN(&path->skel)->id = BE16(vid);
+
+        } break;
+
+        case CMD_PATH_SET_ETH_DST: { path->info |= P_MAC_DST; memcpy(PKT_ETH(&path->skel)->dmac, CMD_VALUE(MAC), CMD_SIZE(MAC)); } break;
+        case CMD_PATH_SET_ETH_SRC: { path->info |= P_MAC_SRC; memcpy(PKT_ETH(&path->skel)->smac, CMD_VALUE(MAC), CMD_SIZE(MAC)); } break;
+
+        case CMD_PATH_SET_IP4_SRC: { path->info |= P_ADDR_SRC; memcpy(PKT_IP4(&path->skel)->saddr, CMD_VALUE(ADDR4), CMD_SIZE(ADDR4)); } break;
+        case CMD_PATH_SET_IP4_DST: { path->info |= P_ADDR_DST; memcpy(PKT_IP4(&path->skel)->daddr, CMD_VALUE(ADDR4), CMD_SIZE(ADDR4)); } break;
+        case CMD_PATH_SET_IP6_SRC: { path->info |= P_ADDR_SRC; memcpy(PKT_IP6(&path->skel)->saddr, CMD_VALUE(ADDR6), CMD_SIZE(ADDR6)); } break;
+        case CMD_PATH_SET_IP6_DST: { path->info |= P_ADDR_DST; memcpy(PKT_IP6(&path->skel)->daddr, CMD_VALUE(ADDR6), CMD_SIZE(ADDR6)); } break;
+
+        case CMD_PATH_SET_UDP_SRC:
+        case CMD_PATH_SET_TCP_SRC: { path->info |= P_PORT_SRC; path->sPortsN = portsN; memcpy(path->sPorts, CMD_VALUE(PATH_PORTS), portsN * CMD_SIZE_MIN(PATH_PORTS)); } break;
+        case CMD_PATH_SET_UDP_DST:
+        case CMD_PATH_SET_TCP_DST: { path->info |= P_PORT_DST; path->dPortsN = portsN; memcpy(path->dPorts, CMD_VALUE(PATH_PORTS), portsN * CMD_SIZE_MIN(PATH_PORTS)); } break;
+
+        case CMD_PATH_SET_WEIGHT_NODE: {
+
+            const uint weight = *CMD_VALUE(WEIGHT_NODE);
+
+            if (weight > PATH_WEIGHT_MAX)
+                CMD_ERR(INVALID_WEIGHT);
+
+            node->weights -= path->weight;
+            node->weights += weight;
+            path->weight   = weight;
+
+        } break;
+
+        case CMD_PATH_SET_WEIGHT_ACKS: {
+
+            const uint wacks = *CMD_VALUE(WEIGHT_ACKS);
+
+            if (wacks == 0
+             || wacks > ACKS_N)
+                CMD_ERR(INVALID_WEIGHT);
+
+            path->weight_acks = wacks;
+
+        } break;
+
+        case CMD_PATH_SET_CLIENT: path->info = (path->info & ~P_SERVER) | P_CLIENT; break;
+        case CMD_PATH_SET_SERVER: path->info = (path->info & ~P_CLIENT) | P_SERVER; break;
+
+        case CMD_PATH_SET_TIMEOUT___: {
+
+        } break;
+
+        case CMD_PATH_SET_RTT_VAR: {
+
+            const uint rtt_var = *CMD_VALUE(RTT_VAR);
+
+            if (rtt_var < RTT_VAR_MIN
+             || rtt_var > RTT_VAR_MAX)
+                CMD_ERR(INVALID_RTT);
+
+            path->rtt_var_ = rtt_var;
+            path->rtt_var  = rtt_var;
+            path->info |= P_RTT_VAR;
+
+        } break;
+
+        case CMD_NODE_SET_MTU: {
+
+            const uint mtu = *CMD_VALUE(MTU);
+
+            if (mtu < MTU_MIN ||
+                mtu > MTU_MAX)
+                CMD_ERR(INVALID_MTU);
+
+            node->mtu = mtu;
+            node->info |= N_MTU;
+
+        } break;
+
+        case CMD_NODE_SET_NAME: {
+
+            const char* const name = CMD_VALUE(NODE_NAME);
+
+            if (!name[0] ||
+                 name[NODE_NAME_SIZE - 1])
+                CMD_ERR(INVALID_NODE_NAME);
+
+            memset(node->name, 0, sizeof(node->name));
+            strcpy(node->name, name);
+
+            node->info |= N_NAME;
+
+        } break;
+
+        case CMD_PATH_SET_NAME: {
+
+            const char* const name = CMD_VALUE(PATH_NAME);
+
+            if (!name[0] ||
+                 name[PATH_NAME_SIZE - 1])
+                CMD_ERR(INVALID_PATH_NAME);
+
+            memset(path->name, 0, sizeof(path->name));
+            strcpy(path->name, name);
+
+            path->info |= P_NAME;
+
+        } break;
+
+        case CMD_PATH_SET_IP_TTL:
+        case CMD_PATH_SET_IP4_TTL:
+        case CMD_PATH_SET_IP6_TTL: {
+
+            const uint ttl = *CMD_VALUE(TTL);
+
+            if (ttl < TTL_MIN ||
+                ttl > TTL_MAX)
+                CMD_ERR(INVALID_TTL);
+
+            path->ttl = ttl;
+            path->info |= P_TTL;
+
+        } break;
+
+        case CMD_PATH_SET_IP_TOS:
+        case CMD_PATH_SET_IP4_TOS:
+        case CMD_PATH_SET_IP6_TOS: {
+
+            const uint tos = *CMD_VALUE(TOS);
+
+            if (tos > TOS_MAX)
+                CMD_ERR(INVALID_TOS);
+
+            path->tos = tos;
+            path->info |= P_TOS;
+
+        } break;
+
+        case CMD_PATH_SET_PPP_SESSION: {
+
+            const uint session = *CMD_VALUE(PPP_SESSION);
+
+            if (session > 0xFFFF)
+                CMD_ERR(INVALID_SESSION);
+
+            switch (path->skel.type) {
+                case H_TYPE_ETH_PPP:
+                case H_TYPE_ETH_VLAN_PPP:
+                    path->skel.encap_eth_ppp.ppp.session = BE16(session);
+                    break;
+                case H_TYPE_ETH_PPP_IP4:
+                case H_TYPE_ETH_VLAN_PPP_IP4:
+                    path->skel.encap_eth_ppp_ip4.ppp.session = BE16(session);
+                    break;
+                case H_TYPE_ETH_PPP_IP6:
+                case H_TYPE_ETH_VLAN_PPP_IP6:
+                    path->skel.encap_eth_ppp_ip6.ppp.session = BE16(session);
+                    break;
+            }
+
+            // path->info |= P_SESSION; TODO:
+
+        } break;
+
+        // TODO: RANDOMIZE NODE SECRET ON CLEAR
+
+        case CMD_NODE_CLR_NAME: node->info &= ~N_NAME; *node->name = '\0'; break;
+        case CMD_PATH_CLR_NAME: path->info &= ~P_NAME; *path->name = '\0'; break;
+
+        case CMD_NODE_CLR_SECRET: node->info &= ~N_SECRET; break;
+
+        case CMD_PATH_CLR_PHYS:       path->info &= ~P_PHYS;      break;
+        case CMD_PATH_CLR_ETH_DST:    path->info &= ~P_MAC_DST;   break;
+        case CMD_PATH_CLR_ETH_SRC:    path->info &= ~P_MAC_SRC;   break;
+        case CMD_PATH_CLR_VLAN_PROTO: path->info &= ~P_VPROTO;    break;
+        case CMD_PATH_CLR_VLAN_ID:    path->info &= ~P_VID;       break;
+        case CMD_PATH_CLR_IP4_TOS:
+        case CMD_PATH_CLR_IP6_TOS:    path->info &= ~P_TOS;       break;
+        case CMD_PATH_CLR_IP4_TTL:
+        case CMD_PATH_CLR_IP6_TTL:    path->info &= ~P_TTL;       break;
+        case CMD_PATH_CLR_IP4_SRC:
+        case CMD_PATH_CLR_IP6_SRC:    path->info &= ~P_ADDR_SRC;  break;
+        case CMD_PATH_CLR_IP4_DST:
+        case CMD_PATH_CLR_IP6_DST:    path->info &= ~P_ADDR_DST;  break;
+        case CMD_PATH_CLR_UDP_SRC:
+        case CMD_PATH_CLR_TCP_SRC:    path->info &= ~P_PORT_SRC;  break;
+        case CMD_PATH_CLR_UDP_DST:
+        case CMD_PATH_CLR_TCP_DST:    path->info &= ~P_PORT_DST;  break;
+        case CMD_PATH_CLR_DHCP:       path->info &= ~P_DHCP;      break;
+        case CMD_PATH_CLR_TYPE:       path->info &= ~__P_TYPE_CLR; break;
+
+        case CMD_NODE_DEL: {
+
+#ifdef CONFIG_XGW_NMAP
+            __atomic_store_n(&nmap[node->nid], node->gw, __ATOMIC_SEQ_CST);
+#endif
+
+            // FREE CONNS
+            if (node->conns)
+                paged_free(node->conns, CONNS_SIZE(node->connsN));
+
+            // CLEAR SECRETS FROM MEMORY
+            memset(node, 0, sizeof(node_s));
+
+            // FREE NODE
+            paged_free(node, sizeof(node_s));
+
+            nodes_set_on(nid, NULL);
+
+        } break;
+
+        case CMD_STATS: {
+
+            stats_print();
+
+        } break;
+
+#ifdef CONFIG_XGW_NMAP
+        case CMD_NMAP: {
+
+            const uint gw = *CMD_VALUE(NODE_ID);
+
+            if (gw >= NODES_N)
+                CMD_ERR(INVALID_NID);
+
+            node = (node_s*)((uintptr_t)nodes[nid] & ~(uintptr_t)1);
+
+            if (node)
+                node->gw = gw;
+
+            // NOTE: NAO CHECA POR N_ON, POIS SE TIVER OPATHS, ENTAO ESTA ON
+            if (!(node && node->opaths))
+                __atomic_store_n(&nmap[nid], gw, __ATOMIC_SEQ_CST);
+
+        } break;
+#endif
+
+        default:
+        // TODO: NESTE CASO, ERRO NÃO SUPPORTADO
+         _CMD_ERR(INVALID_PATH_NAME);
+    }
+
+failed:
+
+    //
+    if (phys)
+        dev_put(phys);
+
+    // UNLOCK
+    spin_unlock_irqrestore(&xlock, iflags);
+
+failed_free:
+    kfree(buff);
+
+failed_nothing:
+
+    return e;
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd_codes.h linux-master/drivers/net/xgw/cmd_codes.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd_codes.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/cmd_codes.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,168 @@
+
+/*
+    TODO: HIDE, INACCESS, UNLIST?
+
+    COMO A INTERFACE PODE ESTAR HIDDEN, VAI TER QUE TER UMA LISTA LOCAL DE INTERFACES KNOWN
+
+    list_netdevice
+    unlist_netdevice
+
+    CMD_PHYS_SET_DONT_GET,
+    CMD_PHYS_SET_DONT_LIST,
+
+    CMD_PHYS_CLR_DONT_GET,
+    CMD_PHYS_CLR_DONT_LIST,
+
+    CMD_PHYS_MTU,
+    CMD_PHYS_QUEUE_LEN,
+    CMD_PHYS_HWADDR,
+    CMD_PHYS_PROMISC_ON,
+    CMD_PHYS_PROMISC_OFF,
+*/
+
+enum CMD {
+
+    // PORT
+    CMD_PORT_ON,
+    CMD_PORT_OFF,
+    CMD_PORT_GET,
+
+    // PORTS
+    CMD_PORTS_LIST,
+    CMD_PORTS_CLEAR,
+
+    // NOTE: SAME ORDER AS IN IFF_XGW*
+    CMD_PHYS_ATTACH,
+    CMD_PHYS_DETACH,
+
+    CMD_PHYS_LIST,
+
+    // SELF NODE
+    CMD_SELF_SET,
+    CMD_SELF_GET,
+
+    // GWS
+    CMD_GWS_INSERT,
+    CMD_GWS_REMOVE,
+    CMD_GWS_LIST,
+    CMD_GWS_CLEAR,
+
+    // NODE
+    CMD_NODE_NEW,
+    CMD_NODE_DEL,
+
+    CMD_NODE_SET_NAME,
+    CMD_NODE_SET_MTU,
+    CMD_NODE_SET_CONNS_N,
+    CMD_NODE_SET_SECRET,
+
+    CMD_NODE_DEV_CREATE,
+    CMD_NODE_DEV_DEL,
+
+    CMD_NODE_CLR_NAME,
+    CMD_NODE_CLR_SECRET,
+
+    CMD_NODE_ON,
+    CMD_NODE_OFF,
+
+    CMD_NODE_STATUS,
+    CMD_NODE_STATS,
+
+    // PATH
+    CMD_PATH_NEW,
+    CMD_PATH_DEL,
+
+    CMD_PATH_SET_NAME,
+    CMD_PATH_SET_WEIGHT_NODE,
+    CMD_PATH_SET_WEIGHT_ACKS,
+    CMD_PATH_SET_CLIENT,
+    CMD_PATH_SET_SERVER,
+    CMD_PATH_SET_TIMEOUT___,
+    CMD_PATH_SET_RTT_VAR,
+    CMD_PATH_SET_DHCP,
+    CMD_PATH_SET_PHYS, // SET THE PATH PHYS
+    CMD_PATH_SET_TYPE, // SET THE PATH ENCAPSULATING TYPE
+    CMD_PATH_SET_ETH_SRC,
+    CMD_PATH_SET_ETH_DST,
+    CMD_PATH_SET_VLAN_PROTO, // 8021Q / 8021AD  na verdade seria ETH PROTO, MAS SO USADO NO CASO DO VLAN
+    CMD_PATH_SET_VLAN_ID,
+    CMD_PATH_SET_IP4_TOS,
+    CMD_PATH_SET_IP6_TOS,
+    CMD_PATH_SET_IP4_TTL,
+    CMD_PATH_SET_IP6_TTL,
+    CMD_PATH_SET_IP4_SRC,
+    CMD_PATH_SET_IP4_DST,
+    CMD_PATH_SET_IP6_SRC,
+    CMD_PATH_SET_IP6_DST,
+    CMD_PATH_SET_UDP_SRC,
+    CMD_PATH_SET_TCP_SRC,
+    CMD_PATH_SET_UDP_DST,
+    CMD_PATH_SET_TCP_DST,
+
+    CMD_PATH_SET_PPP_SESSION,
+
+    CMD_PATH_SET_IP_TOS, // PARA O CASO DO SERVER
+    CMD_PATH_SET_IP_TTL,
+
+    CMD_PATH_CLR_NAME,
+    CMD_PATH_CLR_WEIGHT_NODE,
+    CMD_PATH_CLR_WEIGHT_ACKS,
+    CMD_PATH_CLR_DHCP,
+    CMD_PATH_CLR_PHYS,
+    CMD_PATH_CLR_TYPE, // UNSET THE PATH ENCAPSULATING TYPE AND CLEAR ALL INFO
+    CMD_PATH_CLR_ETH_SRC,
+    CMD_PATH_CLR_ETH_DST,
+    CMD_PATH_CLR_VLAN_PROTO,
+    CMD_PATH_CLR_VLAN_ID,
+    CMD_PATH_CLR_IP4_TOS,
+    CMD_PATH_CLR_IP6_TOS,
+    CMD_PATH_CLR_IP4_TTL,
+    CMD_PATH_CLR_IP6_TTL,
+    CMD_PATH_CLR_IP4_SRC,
+    CMD_PATH_CLR_IP4_DST,
+    CMD_PATH_CLR_IP6_SRC,
+    CMD_PATH_CLR_IP6_DST,
+    CMD_PATH_CLR_UDP_SRC,
+    CMD_PATH_CLR_TCP_SRC,
+    CMD_PATH_CLR_UDP_DST,
+    CMD_PATH_CLR_TCP_DST,
+
+    CMD_PATH_ON,
+    CMD_PATH_OFF,
+
+    CMD_PATH_STATUS,
+    CMD_PATH_STATS,
+
+    // GLOBAL
+    CMD_STATS,
+
+    CMD_NMAP
+
+};
+
+#define CMDS_N (CMD_NMAP + 1)
+
+#define C_USE_NID(C)    (((C) >= CMD_NODE_NEW && (C) <= CMD_PATH_STATS) || (C) == CMD_SELF_SET || ((C) >= CMD_GWS_INSERT && (C) <= CMD_GWS_REMOVE) || (C) == CMD_NMAP)
+#define C_USE_PID(C)    ((C) >= CMD_PATH_NEW && (C) <= CMD_PATH_STATS)
+
+#define C_USE_NODE(C) ( \
+    (CMD_NODE_NEW <= (C) && (C) <= CMD_NODE_STATUS) || \
+    (CMD_PATH_NEW <= (C) && (C) <= CMD_PATH_STATUS) )
+
+#define C_USE_PATH(C) (CMD_PATH_NEW <= (C) && (C) <= CMD_PATH_STATUS)
+
+#define C_USE_PHYS(C) ((CMD_PHYS_ATTACH <= (C) && (C) <= CMD_PHYS_DETACH) || (C) == CMD_PATH_SET_PHYS)
+
+#define C_USE_PORTS(C) ( \
+    (CMD_PORT_ON        <= (C) && (C) <= CMD_PORT_GET) || \
+    (CMD_PATH_SET_UDP_SRC <= (C) && (C) <= CMD_PATH_SET_UDP_DST) )
+
+#define C_NODE_MUST_EXIST(C) ((C) > CMD_NODE_NEW && (C) <= CMD_PATH_STATS)
+#define C_PATH_MUST_EXIST(C) ((C) > CMD_PATH_NEW && (C) <= CMD_PATH_STATS)
+
+#define C_NODE_MUST_BE_OFF_IDLE(C) ((C) >= CMD_NODE_DEL && (C) <= CMD_NODE_ON)
+#define C_PATH_MUST_BE_OFF_IDLE(C) ((C) >= CMD_PATH_DEL && (C) <= CMD_PATH_ON)
+
+// TODO: RELACAO TIPO DE DHCP VS TIPO DE PATH
+//      VAI TER QUE FORCAR TIPO DE PATH COMPATIVEL COM O TIPO DE DHCP, E VICE-VERSA
+//      COPIAR O DEV DO DHCP
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd_errs.h linux-master/drivers/net/xgw/cmd_errs.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd_errs.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/cmd_errs.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,80 @@
+
+enum CMD_ERRS {
+    CMD_ERR_ALLOC_CMD,
+    CMD_ERR_ALLOC_CONNS,
+    CMD_ERR_ALLOC_NODE,
+    CMD_ERR_INVALID_CONNS_N,
+    CMD_ERR_INVALID_MTU,
+    CMD_ERR_INVALID_NID,
+    CMD_ERR_INVALID_PID,
+    CMD_ERR_INVALID_DID,
+    CMD_ERR_INVALID_NODE_NAME,
+    CMD_ERR_INVALID_PATH_NAME,
+    CMD_ERR_INVALID_PHYS,
+    CMD_ERR_INVALID_DHCP_IP,
+    CMD_ERR_INVALID_PORTS_N,
+    CMD_ERR_INVALID_PASSWORD_LEN,
+    CMD_ERR_INVALID_TYPE,
+    CMD_ERR_INVALID_TOS,
+    CMD_ERR_INVALID_TTL,
+    CMD_ERR_INVALID_VPROTO,
+    CMD_ERR_INVALID_VID,
+    CMD_ERR_INVALID_SESSION,
+    CMD_ERR_INVALID_WEIGHT,
+    CMD_ERR_INVALID_TIMEOUT,
+    CMD_ERR_INVALID_RTT,
+    CMD_ERR_INVALID_RTT_VAR,
+    CMD_ERR_PATH_USE_DHCP_NOT_IP,
+    CMD_ERR_PATH_USE_DHCP_NOT_IP_4,
+    CMD_ERR_PATH_USE_DHCP_NOT_IP_6,
+    CMD_ERR_NODE_EXIST,
+    CMD_ERR_NODE_DONT_EXIST,
+    CMD_ERR_NODE_IS_OFF,
+    CMD_ERR_NODE_IS_ON,
+    CMD_ERR_NODE_IS_SELF,
+    CMD_ERR_NODE_IS_STOPPING,
+    CMD_ERR_NODE_NOT_CONFIGURED,
+    CMD_ERR_PATH_EXIST,
+    CMD_ERR_PATH_DONT_EXIST,
+    CMD_ERR_PATH_IS_OFF,
+    CMD_ERR_PATH_IS_ON,
+    CMD_ERR_PATH_IS_STOPPING,
+    CMD_ERR_PATH_NEED_NAME,
+    CMD_ERR_PATH_NEED_CLT_SRV,
+    CMD_ERR_PATH_NEED_TIMEOUT,
+    CMD_ERR_PATH_NEED_LATENCY_MIN,
+    CMD_ERR_PATH_NEED_LATENCY_MAX,
+    CMD_ERR_PATH_NEED_RTT_VAR,
+    CMD_ERR_PATH_NEED_PHYS,
+    CMD_ERR_PATH_NEED_TOS,
+    CMD_ERR_PATH_NEED_TTL,
+    CMD_ERR_PATH_NEED_MAC_SRC,
+    CMD_ERR_PATH_NEED_MAC_DST,
+    CMD_ERR_PATH_NEED_ADDR_SRC,
+    CMD_ERR_PATH_NEED_ADDR_DST,
+    CMD_ERR_PATH_NEED_PORT_SRC,
+    CMD_ERR_PATH_NEED_PORT_DST,
+    CMD_ERR_PATH_NEED_VLAN_PROTO,
+    CMD_ERR_PATH_NEED_VLAN_ID,
+    CMD_ERR_PATH_NEED_PPP_SESSION, // TODO:
+    CMD_ERR_PATH_NOT_SERVER,
+    CMD_ERR_PATH_NOT_ETH,
+    CMD_ERR_PATH_NOT_VLAN,
+    CMD_ERR_PATH_NOT_PPP,
+    CMD_ERR_PATH_NOT_IP,
+    CMD_ERR_PATH_NOT_IP4,
+    CMD_ERR_PATH_NOT_IP6,
+    CMD_ERR_PATH_NOT_UDP,
+    CMD_ERR_PATH_NOT_TCP,
+    CMD_ERR_PHYS_IS_BAD,
+    CMD_ERR_PHYS_IS_XGW,
+    CMD_ERR_PHYS_NOT_FOUND,
+    CMD_ERR_PHYS_NOT_HOOKED,
+    CMD_ERR_GWS_FULL,
+    CMD_ERR_GWS_NID_NOT_FOUND,
+    CMD_ERR_GWS_NID_ALREADY,
+    CMD_ERR_INVALID_CMD_CODE,
+    CMD_ERR_INVALID_CMD_SIZE,
+    CMD_ERR_COPY_CMD,
+    CMD_ERRS_N
+};
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd_names.c linux-master/drivers/net/xgw/cmd_names.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd_names.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/cmd_names.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,91 @@
+
+// grep CMD_ '{print $1}' cmds.h | grep = | awk -F , | awk '{print "["$1"] = |"$1"|,"}' | tr '|' '"' > cmd_names.h
+static const char* const cmdNames [CMDS_N] = {
+    [CMD_GWS_CLEAR]            = "CMD_GWS_CLEAR",
+    [CMD_GWS_INSERT]           = "CMD_GWS_INSERT",
+    [CMD_GWS_LIST]             = "CMD_GWS_LIST",
+    [CMD_GWS_REMOVE]           = "CMD_GWS_REMOVE",
+    [CMD_NMAP]                 = "CMD_NMAP",
+    [CMD_NODE_CLR_NAME]        = "CMD_NODE_CLR_NAME",
+    [CMD_NODE_CLR_SECRET]      = "CMD_NODE_CLR_SECRET",
+    [CMD_NODE_DEL]             = "CMD_NODE_DEL",
+    [CMD_NODE_DEV_CREATE]      = "CMD_NODE_DEV_CREATE",
+    [CMD_NODE_DEV_DEL]         = "CMD_NODE_DEV_DEL",
+    [CMD_NODE_NEW]             = "CMD_NODE_NEW",
+    [CMD_NODE_OFF]             = "CMD_NODE_OFF",
+    [CMD_NODE_ON]              = "CMD_NODE_ON",
+    [CMD_NODE_SET_CONNS_N]     = "CMD_NODE_SET_CONNS_N",
+    [CMD_NODE_SET_MTU]         = "CMD_NODE_SET_MTU",
+    [CMD_NODE_SET_NAME]        = "CMD_NODE_SET_NAME",
+    [CMD_NODE_SET_SECRET]      = "CMD_NODE_SET_SECRET",
+    [CMD_NODE_STATS]           = "CMD_NODE_STATS",
+    [CMD_NODE_STATUS]          = "CMD_NODE_STATUS",
+    [CMD_PATH_CLR_DHCP]        = "CMD_PATH_CLR_DHCP",
+    [CMD_PATH_CLR_ETH_DST]     = "CMD_PATH_CLR_ETH_DST",
+    [CMD_PATH_CLR_ETH_SRC]     = "CMD_PATH_CLR_ETH_SRC",
+    [CMD_PATH_CLR_IP4_DST]     = "CMD_PATH_CLR_IP4_DST",
+    [CMD_PATH_CLR_IP4_SRC]     = "CMD_PATH_CLR_IP4_SRC",
+    [CMD_PATH_CLR_IP4_TOS]     = "CMD_PATH_CLR_IP4_TOS",
+    [CMD_PATH_CLR_IP4_TTL]     = "CMD_PATH_CLR_IP4_TTL",
+    [CMD_PATH_CLR_IP6_DST]     = "CMD_PATH_CLR_IP6_DST",
+    [CMD_PATH_CLR_IP6_SRC]     = "CMD_PATH_CLR_IP6_SRC",
+    [CMD_PATH_CLR_IP6_TOS]     = "CMD_PATH_CLR_IP6_TOS",
+    [CMD_PATH_CLR_IP6_TTL]     = "CMD_PATH_CLR_IP6_TTL",
+    [CMD_PATH_CLR_NAME]        = "CMD_PATH_CLR_NAME",
+    [CMD_PATH_CLR_PHYS]        = "CMD_PATH_CLR_PHYS",
+    [CMD_PATH_CLR_TCP_DST]     = "CMD_PATH_CLR_TCP_DST",
+    [CMD_PATH_CLR_TCP_SRC]     = "CMD_PATH_CLR_TCP_SRC",
+    [CMD_PATH_CLR_TYPE]        = "CMD_PATH_CLR_TYPE",
+    [CMD_PATH_CLR_UDP_DST]     = "CMD_PATH_CLR_UDP_DST",
+    [CMD_PATH_CLR_UDP_SRC]     = "CMD_PATH_CLR_UDP_SRC",
+    [CMD_PATH_CLR_VLAN_ID]     = "CMD_PATH_CLR_VLAN_ID",
+    [CMD_PATH_CLR_VLAN_PROTO]  = "CMD_PATH_CLR_VLAN_PROTO",
+    [CMD_PATH_CLR_WEIGHT_ACKS] = "CMD_PATH_CLR_WEIGHT_ACKS",
+    [CMD_PATH_CLR_WEIGHT_NODE] = "CMD_PATH_CLR_WEIGHT_NODE",
+    [CMD_PATH_DEL]             = "CMD_PATH_DEL",
+    [CMD_PATH_NEW]             = "CMD_PATH_NEW",
+    [CMD_PATH_OFF]             = "CMD_PATH_OFF",
+    [CMD_PATH_ON]              = "CMD_PATH_ON",
+    [CMD_PATH_SET_CLIENT]      = "CMD_PATH_SET_CLIENT",
+    [CMD_PATH_SET_DHCP]        = "CMD_PATH_SET_DHCP",
+    [CMD_PATH_SET_ETH_DST]     = "CMD_PATH_SET_ETH_DST",
+    [CMD_PATH_SET_ETH_SRC]     = "CMD_PATH_SET_ETH_SRC",
+    [CMD_PATH_SET_IP4_DST]     = "CMD_PATH_SET_IP4_DST",
+    [CMD_PATH_SET_IP4_SRC]     = "CMD_PATH_SET_IP4_SRC",
+    [CMD_PATH_SET_IP4_TOS]     = "CMD_PATH_SET_IP4_TOS",
+    [CMD_PATH_SET_IP4_TTL]     = "CMD_PATH_SET_IP4_TTL",
+    [CMD_PATH_SET_IP6_DST]     = "CMD_PATH_SET_IP6_DST",
+    [CMD_PATH_SET_IP6_SRC]     = "CMD_PATH_SET_IP6_SRC",
+    [CMD_PATH_SET_IP6_TOS]     = "CMD_PATH_SET_IP6_TOS",
+    [CMD_PATH_SET_IP6_TTL]     = "CMD_PATH_SET_IP6_TTL",
+    [CMD_PATH_SET_IP_TOS]      = "CMD_PATH_SET_IP_TOS",
+    [CMD_PATH_SET_IP_TTL]      = "CMD_PATH_SET_IP_TTL",
+    [CMD_PATH_SET_NAME]        = "CMD_PATH_SET_NAME",
+    [CMD_PATH_SET_PHYS]        = "CMD_PATH_SET_PHYS",
+    [CMD_PATH_SET_PPP_SESSION] = "CMD_PATH_SET_PPP_SESSION",
+    [CMD_PATH_SET_RTT_VAR]     = "CMD_PATH_SET_RTT_VAR",
+    [CMD_PATH_SET_SERVER]      = "CMD_PATH_SET_SERVER",
+    [CMD_PATH_SET_TCP_DST]     = "CMD_PATH_SET_TCP_DST",
+    [CMD_PATH_SET_TCP_SRC]     = "CMD_PATH_SET_TCP_SRC",
+    [CMD_PATH_SET_TIMEOUT___]  = "CMD_PATH_SET_TIMEOUT",
+    [CMD_PATH_SET_TYPE]        = "CMD_PATH_SET_TYPE",
+    [CMD_PATH_SET_UDP_DST]     = "CMD_PATH_SET_UDP_DST",
+    [CMD_PATH_SET_UDP_SRC]     = "CMD_PATH_SET_UDP_SRC",
+    [CMD_PATH_SET_VLAN_ID]     = "CMD_PATH_SET_VLAN_ID",
+    [CMD_PATH_SET_VLAN_PROTO]  = "CMD_PATH_SET_VLAN_PROTO",
+    [CMD_PATH_SET_WEIGHT_ACKS] = "CMD_PATH_SET_WEIGHT_ACKS",
+    [CMD_PATH_SET_WEIGHT_NODE] = "CMD_PATH_SET_WEIGHT_NODE",
+    [CMD_PATH_STATS]           = "CMD_PATH_STATS",
+    [CMD_PATH_STATUS]          = "CMD_PATH_STATUS",
+    [CMD_PHYS_ATTACH]          = "CMD_PHYS_ATTACH",
+    [CMD_PHYS_DETACH]          = "CMD_PHYS_DETACH",
+    [CMD_PHYS_LIST]            = "CMD_PHYS_LIST",
+    [CMD_PORT_GET]             = "CMD_PORT_GET",
+    [CMD_PORT_OFF]             = "CMD_PORT_OFF",
+    [CMD_PORT_ON]              = "CMD_PORT_ON",
+    [CMD_PORTS_CLEAR]          = "CMD_PORTS_CLEAR",
+    [CMD_PORTS_LIST]           = "CMD_PORTS_LIST",
+    [CMD_SELF_GET]             = "CMD_SELF_GET",
+    [CMD_SELF_SET]             = "CMD_SELF_SET",
+    [CMD_STATS]                = "CMD_STATS",
+};
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd_sizes.c linux-master/drivers/net/xgw/cmd_sizes.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/cmd_sizes.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/cmd_sizes.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,85 @@
+[CMD_PORT_ON]              = CMD_SIZE(CODE)  + CMD_SIZE_MIN(PORTS),
+[CMD_PORT_OFF]             = CMD_SIZE(CODE)  + CMD_SIZE_MIN(PORTS),
+[CMD_PORT_GET]             = CMD_SIZE(CODE)  + CMD_SIZE_MIN(PORTS),
+[CMD_PORTS_LIST]           = CMD_SIZE(CODE),
+[CMD_PORTS_CLEAR]          = CMD_SIZE(CODE),
+[CMD_PHYS_ATTACH]          = CMD_SIZE(CODE)  + CMD_SIZE(PHYS),
+[CMD_PHYS_DETACH]          = CMD_SIZE(CODE)  + CMD_SIZE(PHYS),
+[CMD_PHYS_LIST]            = CMD_SIZE(CODE),
+[CMD_SELF_SET]             = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_SELF_GET]             = CMD_SIZE(CODE),
+[CMD_GWS_INSERT]           = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_GWS_REMOVE]           = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_GWS_LIST]             = CMD_SIZE(CODE),
+[CMD_GWS_CLEAR]            = CMD_SIZE(CODE),
+[CMD_NODE_NEW]             = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_NODE_DEL]             = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_NODE_DEV_CREATE]      = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PHYS),
+[CMD_NODE_DEV_DEL]         = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_NODE_SET_NAME]        = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(NODE_NAME),
+[CMD_NODE_SET_MTU]         = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(MTU),
+[CMD_NODE_SET_CONNS_N]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(CONNS_N),
+[CMD_NODE_SET_SECRET]      = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE_MIN(PASSWORD),
+[CMD_NODE_CLR_NAME]        = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_NODE_CLR_SECRET]      = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_NODE_ON]              = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_NODE_OFF]             = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_NODE_STATUS]          = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_NODE_STATS]           = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID),
+[CMD_PATH_NEW]             = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_DEL]             = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_SET_NAME]        = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(PATH_NAME),
+[CMD_PATH_SET_WEIGHT_NODE] = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(WEIGHT_NODE),
+[CMD_PATH_SET_WEIGHT_ACKS] = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(WEIGHT_ACKS),
+[CMD_PATH_SET_CLIENT]      = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_SET_SERVER]      = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_SET_TIMEOUT___]  = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(TIMEOUT),
+[CMD_PATH_SET_RTT_VAR]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(RTT_VAR),
+[CMD_PATH_SET_DHCP]        = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(DID),
+[CMD_PATH_SET_PHYS]        = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(PHYS),
+[CMD_PATH_SET_TYPE]        = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(TYPE),
+[CMD_PATH_SET_VLAN_PROTO]  = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(ETH_PROTO),
+[CMD_PATH_SET_VLAN_ID]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(VLAN_ID),
+[CMD_PATH_SET_ETH_SRC]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(MAC),
+[CMD_PATH_SET_ETH_DST]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(MAC),
+[CMD_PATH_SET_IP4_TOS]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(TOS),
+[CMD_PATH_SET_IP6_TOS]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(TOS),
+[CMD_PATH_SET_IP4_TTL]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(TTL),
+[CMD_PATH_SET_IP6_TTL]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(TTL),
+[CMD_PATH_SET_IP4_SRC]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(ADDR4),
+[CMD_PATH_SET_IP6_SRC]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(ADDR6),
+[CMD_PATH_SET_IP4_DST]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(ADDR4),
+[CMD_PATH_SET_IP6_DST]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(ADDR6),
+[CMD_PATH_SET_UDP_SRC]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE_MIN(PATH_PORTS),
+[CMD_PATH_SET_UDP_DST]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE_MIN(PATH_PORTS),
+[CMD_PATH_SET_TCP_SRC]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE_MIN(PATH_PORTS),
+[CMD_PATH_SET_TCP_DST]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE_MIN(PATH_PORTS),
+[CMD_PATH_SET_PPP_SESSION] = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID)       + CMD_SIZE(PPP_SESSION),
+[CMD_PATH_CLR_NAME]        = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_WEIGHT_NODE] = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_WEIGHT_ACKS] = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_DHCP]        = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_PHYS]        = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_TYPE]        = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_VLAN_PROTO]  = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_VLAN_ID]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_ETH_SRC]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_ETH_DST]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_IP4_TOS]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_IP4_TTL]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_IP4_SRC]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_IP4_DST]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_IP6_TOS]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_IP6_TTL]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_IP6_SRC]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_IP6_DST]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_UDP_SRC]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_UDP_DST]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_TCP_SRC]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_CLR_TCP_DST]     = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_ON]              = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_OFF]             = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_STATUS]          = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_PATH_STATS]           = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(PATH_ID),
+[CMD_STATS]                = CMD_SIZE(CODE),
+[CMD_NMAP]                 = CMD_SIZE(CODE)  + CMD_SIZE(NODE_ID)    + CMD_SIZE(NODE_ID),
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/crypto.c linux-master/drivers/net/xgw/crypto.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/crypto.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/crypto.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,236 @@
+
+// !!!!!! TODO: XGW TO XGW REDIRECT WITHOUT GOING THROUGH IP STACK
+
+static inline u64 bit_rotate_l64 (const u64 x, const uint q) { return (x << q) | (x >> (64 - q)); }
+static inline u64 bit_rotate_r64 (const u64 x, const uint q) { return (x >> q) | (x << (64 - q)); }
+
+static inline u64   swap64 (const u64 x) { return bit_rotate_l64(x, popcount64(x)); }
+static inline u64 unswap64 (const u64 x) { return bit_rotate_r64(x, popcount64(x)); }
+
+#define ENCX(x, s, m) (bit_rotate_l64((x), popcount64(m)) + (s))
+#define DECX(x, s, m) (bit_rotate_r64((x) - s, popcount64(m)))
+
+#define ENC(x) ENCX(ENCX(ENCX(ENCX((x), A, B), C, D), E, F), G, H)
+#define DEC(x) DECX(DECX(DECX(DECX((x), G, H), E, F), C, D), A, B)
+
+// TODO: CHOOSE THE RIGHT ONE HERE
+#define _prefetch_secret __prefetch_r_temporal_low
+
+static inline u64 encrypt (const u64 K[K_LEN], u64* restrict pos, u64* restrict const end, u64 x) {
+
+    ASSERT((end - pos) >= PKT_ALIGN_WORDS);
+    ASSERT((end - pos) <= XGW_PAYLOAD_MAX/sizeof(u64));
+
+    // INITIAL KEYS, PER INTERVAL
+    u64 A = K[0], B = K[1], C = K[2], D = K[3],
+        E = K[4], F = K[5], G = K[6], H = K[7];
+
+    do { //__prefetch_w_temporal_high(pos + 2);
+
+        // READ THE ORIGINAL VALUE
+        x = BE64(*pos);
+
+        // WRITE THE ENCRYPTED VALUE
+        *pos = BE64(ENC(x));
+
+        // AVALANCHE OF ORIGINAL THROUGH KEYS
+        A += C += x += E += G += x;
+        B += D += x += F += H += x;
+
+    } while (++pos != end);
+
+    // RETURN THE HASH
+    return x;
+}
+
+static inline u64 decrypt (const u64 K[K_LEN], u64* restrict pos, u64* restrict const end, u64 x) {
+
+    ASSERT((end - pos) >= PKT_ALIGN_WORDS);
+    ASSERT((end - pos) <= XGW_PAYLOAD_MAX/sizeof(u64));
+
+    // INITIAL KEYS, PER INTERVAL
+    u64 A = K[0], B = K[1], C = K[2], D = K[3],
+        E = K[4], F = K[5], G = K[6], H = K[7];
+
+    do { //__prefetch_w_temporal_high(pos + 2);
+
+        // READ THE ENCRYPTED VALUE AND DECRYPT IT
+        x = DEC(BE64(*pos));
+
+        // WRITE THE ORIGINAL VALUE
+        *pos = BE64(x);
+
+        // AVALANCHE OF ORIGINAL THROUGH KEYS
+        A += C += x += E += G += x;
+        B += D += x += F += H += x;
+
+    } while (++pos != end);
+
+    // RETURN THE HASH
+    return x;
+}
+
+// USING SECRET S, APPLY RANDOM R, AND DERIVE KEY K
+static void secret_derivate_random_as_key (const u64 S[SECRET_KEYS_N][K_LEN], const u64 R[K_LEN], u64 K[K_LEN]) {
+
+    u64 x = 0;
+
+    // LOAD DYNAMIC RANDOM AND ITS SUM
+    for_count (k, K_LEN) {
+        x += K[k] = BE64(R[k]);
+    }   x += x >> 32;
+        x += x >> 16;
+
+    // CHOOSE AND APPLY SECRET
+    const u64* const restrict s = S[x % SECRET_KEYS_N];
+
+    // AS THE TRANSFORMER IS ALL THE RANDOMS ACCUMULATED,
+    // THEN EACH WORD IS AFFECTED BY ALL THE OTHERS
+    for_count (k, K_LEN)
+        // THE TRANSFORMER AFFECTS THE SECRET
+        // THE TRANSFORMER CONTINUES BEING AFFECTED BY
+        //         RANDOM + (SECRET * TRANSFORMER)
+        x += K[k] += s[k] * x;
+}
+
+// GENERATE CONSTANT PING/PONG KEYS
+// REFAZER ISSO AO ALTERAR:
+//  -- SELF ID
+//  -- NODE ID
+//  -- SECRET (PASSWORD)
+// * MUST NOT EXPOSE SECRET.
+// * MUST PROVE SENDER/RECEIVER HOST IDS.
+// * MUST PROVE THE PING WILL GENERATE THE SAME KEYS.
+// * CONSIDERING WE MAY HAVE THOUSANDS OF HOSTS USING THE SAME PASSWORD, MUST NOT BE ABLE TO WATCH ALL AND DISCOVER IT
+// --
+// WILL GENERATE TWO KEYS:
+//      NODE HIGHER WILL USE THEM AS IN/OUT,
+//      NODE LOWER WILL USE THEM AS OUT/IN
+static void reset_node_ping_keys (node_s* const node, const uint self, const uint peer) {
+
+    ASSERT(self < NODES_N);
+    ASSERT(peer < NODES_N);
+    ASSERT(self != peer);
+
+    u64* restrict X; u64 sum;
+    u64* restrict Y;
+
+    // CADA LADO USA OS MESMOS PING/PONG, POREM INVERTIDOS
+    //      SO OS PONTEIROS SAO INVERTIDOS
+    //      AS SOMA SIMPLESMENTE É A MESMA (MAIOR | MENOR)
+    if (self > peer) {
+        sum = 0x0000000100000001ULL * ((self << 16) | peer);
+        X = node->iKeys[I_KEY_PING];
+        Y = node->oKeys[O_KEY_PING];
+    } else {
+        sum = 0x0000000100000001ULL * ((peer << 16) | self);
+        X = node->oKeys[O_KEY_PING];
+        Y = node->iKeys[I_KEY_PING];
+    }
+
+    // INITIALIZE THE KEYS
+    // MESMO QUE USE O MESMO PASSWORD ENTRE VARIOS NODES, NAO DEIXA QUE O PING KEYS SEJA O MESMO
+    for_count (k, 3 * K_LEN) X[k] = sum;
+    for_count (k, 3 * K_LEN) Y[k] = sum;
+    // TODO: SYN, PING, PONG
+
+    // NOW MERGE WITH THE ENTIRE SECRET
+    for_count (s, SECRET_KEYS_N) {
+        for_count (k, K_LEN) {
+            for_count (k2, 3 * K_LEN) sum += swap64(X[k2] += swap64(node->secret[s][k] + swap64(sum)));
+            for_count (k2, 3 * K_LEN) sum += swap64(Y[k2] += swap64(node->secret[s][k] + swap64(sum)));
+        }
+    }
+
+    // SET THE DEFAULT SYN CODES FOR THE PATHS
+    // AN ATTACKER ABLE TO WATCH ONE OF THEM CAN'T KNOW THE OTHER ONES
+    for_count (pid, PATHS_N) {
+        node->syns[pid] = sum + popcount(sum) * sum;
+        sum += swap64(sum);
+    }
+}
+
+// REPETE ELE ATE PREENCHER TODA A ARRAY
+static void copy_and_fill (void* const restrict dst, const uint dstSize, const void* const restrict src, uint srcSize) {
+
+    ASSERT(dstSize >= srcSize);
+
+    // COPY FROM THE ORIGINAL BUFFER, THE ORIGINAL SIZE
+    memcpy(dst, src, srcSize);
+
+    // RECOPY FROM ITSELF, ITSELF'S SIZE
+    uint chunk;
+
+    while ((chunk = dstSize - srcSize)) {
+        if (chunk > srcSize)
+            chunk = srcSize;
+        memcpy(dst + srcSize, dst, chunk);
+        srcSize += chunk;
+    }
+}
+
+// TODO: COLD FUNCTION
+static void secret_derivate_from_password (u64 S[SECRET_KEYS_N][K_LEN], const u8* const restrict password, const uint size) {
+
+    ASSERT(size >= PASSWORD_SIZE_MIN);
+    ASSERT(size <= PASSWORD_SIZE_MAX);
+    ASSERT(PASSWORD_SIZE_MAX <= SECRET_SIZE);
+
+    copy_and_fill(S, SECRET_SIZE, password, size);
+
+#ifndef __BIG_ENDIAN
+    // EM LOCAL ENDIAN
+    for_count (s, SECRET_KEYS_N)
+        for_count (k, K_LEN)
+            S[s][k] =
+       BE64(S[s][k]);
+#endif
+
+    //
+    u64 A = S[0][0], B = S[0][1], C = S[0][2], D = S[0][3];
+
+    // NAO DEIXA SER APENAS UMA REPETICAO
+    for_count (s, SECRET_KEYS_N)
+        for_count (k, K_LEN)
+            A += B += C += D +=
+                S[s][k] =
+                    swap64(swap64(swap64(S[s][k] + D) + C) + B) + A;
+
+    // SHUFFLE
+    for_count (c, PASSWORD_ROUNDS) {
+        for_count (s, SECRET_KEYS_N) {
+            for_count (k, K_LEN) {
+
+                A += S[D % SECRET_KEYS_N][C % K_LEN] * B;
+                B += S[C % SECRET_KEYS_N][A % K_LEN] * D;
+                C += S[B % SECRET_KEYS_N][D % K_LEN] * A;
+                D += S[A % SECRET_KEYS_N][B % K_LEN] * C;
+
+                A += B += C += D +=
+                    S[s][k] =
+                        swap64(swap64(swap64(S[s][k] + D) + C) + B) + A;
+            }
+        }
+    }
+}
+
+// AUTHENTICITY AND INTEGRITY
+// - SRC HOST ID
+// - DST HOST ID
+// - PATH ID
+// - RECEIVER IN SLOT
+// - DATA SIZE
+// AUTHENTICITY, INTEGRITY AND PRIVACY
+// - DATA
+
+// NOTE: QUALQUER ALTERAÇÃO EM UM BIT DO PATH ID OU DO RCOUNTER TEM QUE RESULTAR EM ALGO DIFERENTE AQUI
+#define _PKT_SEED(pkt) BE64(pkt->x.info ^ pkt->x.time)
+
+// A IDÉIA É ASSUMIR QUE O SIZE É SEMPRE MULTIPLO DE 64-BITS.
+// DAÍ O RESTO QUE PASSAR DISSO, É "EXPULSO" DO ALIGN, FAZENDO ELE COMECAR MAIS PARA FRENTE.
+#define _PKT_START(pkt, size) (PTR(pkt->p) + (size % sizeof(pkt->p[0])))
+#define _PKT_END(pkt, size)   (PTR(pkt->p) + PKT_ALIGN_SIZE + size)
+
+// NOTE: TEM QUE FAZER APOS TER SETADO O PKT INFO E RCOUNTER
+#define pkt_encrypt(node, o, pkt, size) encrypt(node->oKeys[o], _PKT_START(pkt, size), _PKT_END(pkt, size), _PKT_SEED(pkt))
+#define pkt_decrypt(node, i, pkt, size) decrypt(node->iKeys[i], _PKT_START(pkt, size), _PKT_END(pkt, size), _PKT_SEED(pkt))
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/crypto.h linux-master/drivers/net/xgw/crypto.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/crypto.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/crypto.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,22 @@
+
+// HOW MANY WORDS IN A KEY
+#define K_LEN 8
+
+// THE SIZE, IN BYTES
+#define K_SIZE 64
+
+// HOW MANY KEYS IN A SECRET
+#define SECRET_KEYS_N 16384
+
+//
+#define SECRET_SIZE 1048576
+
+// DO QUAL DERIVAREMOS O SECRET
+#define PASSWORD_SIZE_MIN     16
+#define PASSWORD_SIZE_MAX 524288
+
+//
+#define PASSWORD_ROUNDS 16
+
+//
+BUILD_ASSERT(SECRET_SIZE == (SECRET_KEYS_N * K_LEN * sizeof(u64)));
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/dev.c linux-master/drivers/net/xgw/dev.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/dev.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/dev.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,91 @@
+
+static int __cold_as_ice __optimize_size dev_up (net_device_s* const dev) {
+
+    // TODO: ATIVA O TIMER
+    printk("XGW: UP\n");
+
+    return 0;
+}
+
+static int __cold_as_ice __optimize_size dev_down (net_device_s* const dev) {
+
+    // TODO: DESATIVA O TIMER
+    printk("XGW: DOWN\n");
+
+    return 0;
+}
+
+static const net_device_ops_s xgwDevOps = {
+    .ndo_init             =  NULL,
+    .ndo_open             =  dev_up,
+    .ndo_stop             =  dev_down,
+    .ndo_start_xmit       =  out,
+    .ndo_set_mac_address  =  NULL,
+    // TODO: SET MTU - NAO EH PARA SETAR AQUI E SIM NO ROUTE
+};
+
+static void __cold_as_ice __optimize_size dev_setup (net_device_s* const dev) {
+
+    dev->netdev_ops      = &xgwDevOps;
+    dev->header_ops      = NULL;
+    dev->type            = ARPHRD_NONE;
+    dev->addr_len        = 0; // TODO: 2 nodeSelf ?
+    dev->hard_header_len = 0;
+//  dev->min_header_len  = 0;
+    dev->needed_headroom = XGW_HEADROOM;
+    dev->min_mtu         = XGW_PAYLOAD_MIN;
+    dev->max_mtu         = XGW_PAYLOAD_MAX;
+    dev->mtu             = XGW_PAYLOAD_MAX; // TODO: DETAULT ETH_MTU - (PKT_X_SIZE + PKT_ALIGN_SIZE)
+    dev->tx_queue_len    = 0; // DEFAULT_TX_QUEUE_LEN
+    dev->flags           = 0
+        | IFF_POINTOPOINT
+        | IFF_NOARP
+        ;
+    dev->priv_flags |= 0
+        | IFF_NO_QUEUE
+        | IFF_NO_RX_HANDLER
+        | IFF_LIVE_ADDR_CHANGE
+        ;
+    dev->lltx = true; // dev->features |= NETIF_F_LLTX
+    dev->features |= 0
+        | NETIF_F_RXCSUM
+        | NETIF_F_HW_CSUM
+#if 0
+        | NETIF_F_HIGHDMA
+#endif
+        ;
+    dev->hw_features |= 0
+        | NETIF_F_RXCSUM
+        | NETIF_F_HW_CSUM
+#if 0
+        | NETIF_F_HIGHDMA
+#endif
+        ;
+    // TODO: hw_enc_features ?
+    //
+}
+
+// TODO: INTERCEPT MTU CHANGES TO ALLOW ONLY THE NODE/GLOBAL MTU
+
+// CREATE A INTERFACE FOR A NODE
+static inline net_device_s* dev_create_node (const char* const name, const uint nid) {
+
+    // CREATE THE VIRTUAL INTERFACE
+    net_device_s* const dev = alloc_netdev(sizeof(uint), name, NET_NAME_USER, dev_setup);
+
+    if (dev == NULL) {
+        printk("XGW: FAILED TO ALLOCATE\n");
+        return NULL;
+    }
+
+    *(uint*)netdev_priv(dev) = nid;
+
+    // MAKE IT VISIBLE IN THE SYSTEM
+    if (register_netdev(dev)) {
+        // TODO: FREE
+        printk("XGW: CREATE FAILED TO REGISTER\n");
+        return NULL;
+    }
+
+    return dev;
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/dhcp.c linux-master/drivers/net/xgw/dhcp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/dhcp.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/dhcp.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,150 @@
+
+#if 0
+
+#define XADDR_MATCH_PHYS       0
+#define XADDR_MATCH_IF_IDX     1
+#define XADDR_MATCH_ETH_DST    2
+#define XADDR_MATCH_ETH_PROTO  3
+#define XADDR_MATCH_VLAN_PROTO 4
+#define XADDR_MATCH_VLAN_ID    5
+#define XADDR_MATCH_IP_PROTO   6
+#define XADDR_MATCH_IP_DST     7
+#define XADDR_MATCH_TRANSP_DST 8
+
+struct x_addr_s {
+    net_device_s* phys;
+    u64 ipDst [2];
+    union {
+        struct {
+            u16 ethDst [3];
+            u16 ethProto; // IPV4 / IPV6
+        };  u64 ethDst_; // FOR FAST ACCESS
+    };
+    u16 vProto;
+    u16 vID;
+    u16 ipProto; // UDP / TCP
+    u16 transpDst; // TRANSPORT DST
+    u16 code; // FOR IDENTIFICATION
+    u16 dhcpID; // DHCP ID
+    u16 matchesYes; // MATCHES NEEDED
+    u16 matchesNot;
+};
+
+#define ADDRS_N 127
+
+static uint addrsN;
+static x_addr_s xaddrs [ADDRS_N + 1];
+
+// TODO: E QUANTO AO VLAN?
+static int testa (dhcp_s* const entry, skb_s* const skb) {
+
+    if (entry->dev == skb->dev) {
+
+        if (entry->neighProtocol == skb->protocol
+         && entry->neighSize     == skb->len) { // NOTA: SO SETA ESSE NEIGHPROTOCOL  E NEIGHSIZE QUANDO OBTER O IP VALIDO
+            // NEIGH
+
+            if (entry->neighProtocol == BE16(ETH_P_ARP)) {
+                // ARP
+
+                if (entry->v4.ip != msg->askedForThisIP)
+                    return DHCP_NOT_HANDLED;
+
+        // build response
+
+            } else {
+                // RA
+
+                if (memcmp(entry->v6.ip, msg->askedForThisIP, 16))
+                    return DHCP_NOT_HANDLED;
+
+        // build response
+            }
+
+        if (atomic_inc(limitreached, 1) < 32) {
+
+            // ALLOC SKB
+            // NOTE: AQUI ESQUECEMOS O SKB RECEBIDO
+            skb_s* const skb = skb_alloc();
+
+            // COPY MSG
+            memcpy();
+
+            // ADJUST SKB
+            skb->dev = entry->dev;
+
+                    // SEND SKB
+            sendkb(skb);
+        }
+
+        return DHCP_HANDLED;
+
+        } elif (entry->leaseProtocol == skb->protocol
+                && entry->leaseMinSize <= skb->len) {
+
+            if (entry->flags & TEMQUE_SER_SRV_MAC)
+                if (memcmp(entry->srvMAC, seila, ETH_ALEN))
+                    return 0;
+
+            // NOTE: AQUI SO COPIA A RESPOSTA, E APLICA SO NO KEEPER
+            if (enry->flags & IS_DHCP4)  {
+                // DHCP 4
+
+                if (entry->xid != msg->xid)
+                    return 0;
+
+                if (entry->flags & TEMQUE_SER_SRV_IP)
+                    if (entry->v4.srv != msg->sip)
+                        return 0;
+
+            } else {
+                // DHCP 6
+
+                if (entry->xid != msg->xid)
+                    return 0;
+
+                if (entry->flags & TEMQUE_SER_SRV_IP)
+                    if (memcmp(entry->v6.srv, msg->sip, 16))
+                        return 0;
+
+                if (entry->flags & TEMQUE_SER_LLP)
+                    if (memcmp(entry->v6.ll, msg->dip, 16))
+                        return 0;
+            }
+
+
+    // NO KEEPER:
+            switch (entry->status) {
+
+                case LEASE_STATUS_DHCP_4_0:
+
+                    break;
+
+                case LEASE_STATUS_DHCP_4_1:
+
+                    break;
+
+                case LEASE_STATUS_DHCP_6_1:
+
+                    break;
+
+                case LEASE_STATUS_DHCP_6_2:
+
+                    break;
+
+                case LEASE_STATUS_RA:
+
+                    if () {
+                        // ALGO MUDOU:
+                        // gw6, gwmac, prefixo, prefix length, mtu
+                            // APRENDE
+                    }
+
+                    break;
+            }
+        }
+    }
+
+}
+
+#endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/dhcp.h linux-master/drivers/net/xgw/dhcp.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/dhcp.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/dhcp.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,44 @@
+
+#define DHCP_NAME_SIZE 32
+
+#define DHCP_SIZE 128
+
+typedef struct dhcp_s {
+// 16
+    net_device_s* dev;
+    u16 neighProtocol;
+    u16 leaseProtocol;
+    u8 neighSize;
+    u8 netmask; // NETMASK OBTIDO
+    u8 status; // DHCP4_* / DHCP6_* / RA_*
+    u8 flags; //  BROADCAST ARP? FORCE gw6? force gwMAC?
+// 24
+    u32 xid; // DHCP
+    u16 mtu; // MTU OBTIDO
+    u8 myMAC [ETH_ALEN];
+    u8 gwMAC [ETH_ALEN];
+    u8 srvMAC [ETH_ALEN];
+// 24
+    skb_s* skb; // SO NO CASO DE SER BROADCAST
+    u64 broadcastLast;
+    u64 reserved;
+// 64
+    union {
+    // 12
+        struct { // IPV4
+            u32 ip; // IP (AND NETWORK) GOT
+            u32 gw; // IP OF GATEWAY
+            u32 srv; // IP OF SERVER
+        } v4;
+    // 64
+        struct { // IPV6
+            u16 ip [8]; // IP (AND NETWORK) GOT
+            u16 ll [8];
+            u16 gw [8]; // IP OF GATEWAY
+            u16 srv [8]; // IP OF SERVER
+        } v6;
+    };
+} dhcp_s;
+
+#define DHCP_NOT_HANDLED 0
+#define DHCP_HANDLED     1 // E DROP O SKB
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/in.c linux-master/drivers/net/xgw/in.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/in.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/in.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,430 @@
+
+// IT MUST BE NOT INLINED, AS THE WHOLE INTENTION OF SEPARATING IT AS A FUNCTION IS TO MINIMIZE THE IN FUNCTION
+// WE DARE TO REDO SOME THINGS HERE, SO IF WE INLINE, THOSE WILL BE SURPLEFUOUS.
+static noinline uint in_ping (node_s* const node, const skb_s* const skb, pkt_s* const pkt) {
+
+    pkt_s* skel; pkt_s temp_skel;
+
+    const ping_s* const ping = PKT_DATA(pkt);
+
+    const uint pid  = BE8(pkt->x.path);
+    const uint i    = BE8(pkt->x.version);
+    const u64 ltime = BE64(pkt->x.time);
+    const u64 rtime = BE64(ping->time);
+
+    ASSERT(pid <= PID_MAX);
+    ASSERT(i == I_KEY_PING
+        || i == I_KEY_PONG
+        || i == I_KEY_SYN);
+    ASSERT(rtime >= PTIME_MIN);
+    ASSERT(rtime <= PTIME_MAX);
+
+    path_s* const path = &node->paths[pid];
+
+    const u64 now = path->mask + get_current_ms();
+
+    ASSERT(now >= PTIME_MIN);
+    ASSERT(now <= PTIME_MAX);
+
+    s64 tdiff;
+
+    if (i == I_KEY_SYN) {
+
+        ASSERT(ltime == path->syn);
+
+        // ESTE RTIME NÃO CONSIDERA O ATRASO
+        tdiff = LTIME_DIFF_RTIME(now, rtime);
+
+        ASSERT(tdiff >= TDIFF_MIN);
+        ASSERT(tdiff <= TDIFF_MAX);
+
+    } else {
+
+        ASSERT(ltime >= PTIME_MIN);
+        ASSERT(ltime <= PTIME_MAX);
+
+        // HIS RAW TIME MUST ADVANCE
+        // SEPARATE PING AND PONG
+        volatile u64* const ptr = &path->pseen[i == I_KEY_PONG];
+
+        u64 seen = atomic_get(ptr);
+
+        ASSERT((seen >= PTIME_MIN &&
+                seen <= PTIME_MAX) ||
+                seen == 0);
+
+        // CONSIDERA QUE PODE TER PERDIDO ALGUNS PINGS
+        if (seen && (rtime - seen) > 49152)
+            // BACKWARD / REPEATED / BIG JUMP
+            return PSTATS_I_RTIME_MISMATCH;
+
+        if (!__atomic_compare_exchange_n(ptr, &seen, rtime + 1, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED))
+            // RACE CONDITION
+            return PSTATS_I_RTIME_MISMATCH;
+
+        // TODO: USAR UM VALOR QUE NAO SEJA 0 PARA TDIFFS NAO INICIALIZADOS
+        tdiff = __atomic_load_n(&path->tdiff, __ATOMIC_RELAXED);
+
+        ASSERT(tdiff >= TDIFF_MIN);
+        ASSERT(tdiff <= TDIFF_MAX);
+
+        tdiff = (
+            // CONSIDERA O MEU
+            tdiff * (tdiff != 0) +
+            // SE NIVELA AO PEER
+            // O SYN USA O CODIGO, E O PONG DE UM SYN NAO CONSIDERA O LATENCY; ENTAO SO PODE CONSIDERAR ESTA RELACAO DE UM PING
+            LTIME_DIFF_RTIME(ltime, rtime) * (i == I_KEY_PING) +
+            // NOTE: CUIDADO COM ESTE LAG AQUI, POIS TALVEZ NAO FOI DESCOBERTO O REAL
+            // NOTE: O KEEPER INICIA O PATH->RTT COM UM PATH->RTT_INITIAL
+            LTIME_DIFF_RTIME(now, rtime + atomic_get(&path->rtt)/2)
+        ) / ((tdiff != 0) + (i == I_KEY_PING) + 1);
+
+        ASSERT(tdiff >= TDIFF_MIN);
+        ASSERT(tdiff <= TDIFF_MAX);
+
+        //
+        __atomic_store_n(&path->tdiff, tdiff, __ATOMIC_SEQ_CST);
+
+        //
+        ping_receive(node, ping);
+
+        if (i == I_KEY_PONG) {
+            // CONNECTING -> ESTABLISHED
+            __atomic_store_n(&path->answered, now, __ATOMIC_SEQ_CST);
+            return PSTATS_I_PONG_GOOD;
+        }
+    }
+
+    u64 answered = __atomic_load_n(&path->answered, __ATOMIC_SEQ_CST);
+
+    if (answered >= PTIME_MIN) {
+        // IF I AM A CLIENT, I ALREADY RECEIVED A PONG
+        // IF I AM A SERVER, I ALREADY RECEIVED A SYN AND A SYN-ACK
+
+        // USE THE KNOWN PATH
+        skel = &path->skel;
+
+    } elif (answered == ANSWERED_LISTENING) {
+
+        if (i == I_KEY_SYN) {
+            // LEARN O PATH NA STACK
+            skel = &temp_skel;
+        } else { // SYN-ACK
+            if (!__atomic_compare_exchange_n(&path->answered, &answered, ANSWERED_ACCEPTING, 0, __ATOMIC_SEQ_CST, __ATOMIC_RELAXED))
+                // COULD NOT LOCK THE PATH
+                return PSTATS_I_SYN_ACK_RACED;
+            // LEARN O PATH NO PATH
+            skel = &path->skel;
+        }
+
+        in_discover(path, skb, skel);
+
+        if (skel == &path->skel)
+            // UNLOCK PATH
+            __atomic_store_n(&path->answered, now, __ATOMIC_SEQ_CST);
+
+    } else
+        // STILL ACCEPTING
+        return PSTATS_I_SYN_ACK_RACED;
+
+    // RESPONDE COM UM PONG
+    ping_send(node, path, skel, now, RTIME(now, tdiff), O_KEY_PONG);
+
+    return PSTATS_I_PING_GOOD;
+}
+
+// TODO: FIXME: PROTECT THE REAL SERVER TCP PORTS SO WE DON'T NEED TO BIND TO THE FAKE INTERFACE
+int in (skb_s* const skb) {
+
+    uint stat; volatile stat_s* _stat;
+
+    if (skb_linearize(skb))
+        ret_dev(DSTATS_I_NON_LINEAR);
+
+    const void* hdr;
+
+    void*       ptr = SKB_NETWORK(skb);
+    void* const end = SKB_TAIL(skb);
+
+    //
+    uint proto = skb->protocol;
+
+    // NOTE: FICAR DE OLHO NO QUE O skb_vlan_untag() FAZ
+    switch (proto) {
+        case BE16(ETH_P_8021Q):
+        case BE16(ETH_P_8021AD): {
+            const hdr_vlan_s* const vlan = ptr;
+            if ((ptr += sizeof(*vlan)) > end)
+                ret_dev(DSTATS_I_INCOMPLETE);
+            proto = vlan->proto;
+        } break;
+    }
+
+    switch (proto) {
+
+        case BE16(ETH_P_PPP_SES): {
+            const hdr_ppp_s* const ppp = ptr;
+            if ((ptr += sizeof(*ppp)) > end)
+                ret_dev(DSTATS_I_INCOMPLETE);
+            switch (ppp->proto) {
+                case BE16(PPP_PROTO_IP4):
+                    hdr = ptr + offsetof(hdr_ip4_s, proto);
+                    proto = sizeof(hdr_ip4_s);
+                    break;
+                case BE16(PPP_PROTO_IP6):
+                    hdr = ptr + offsetof(hdr_ip6_s, proto);
+                    proto = sizeof(hdr_ip6_s);
+                    break;
+                case BE16(PPP_PROTO_XGW):
+                    goto _is_xgw;
+                default:
+                    goto _not_xgw;
+            }
+        } break;
+
+        case BE16(ETH_P_IP):
+            hdr = ptr + offsetof(hdr_ip4_s, proto);
+            proto = sizeof(hdr_ip4_s);
+            break;
+        case BE16(ETH_P_IPV6):
+            hdr = ptr + offsetof(hdr_ip6_s, proto);
+            proto = sizeof(hdr_ip6_s);
+            break;
+        case BE16(ETH_P_XGW):
+            goto _is_xgw;
+        default:
+            goto _not_xgw;
+    }
+
+    // PTR POINTS TO IP
+    // HDR POINTS TO IP PROTOCOL
+    // PROTO IS IP SIZE
+
+    if ((ptr += proto) > end)
+        ret_dev(DSTATS_I_INCOMPLETE);
+
+    proto = *(u8*)hdr;
+
+    switch (proto) {
+        case BE8(IPPROTO_UDP):
+            proto = sizeof(hdr_udp_s);
+            break;
+        case BE8(IPPROTO_TCP):
+            proto = sizeof(hdr_tcp_s);
+            break;
+        case BE8(IPPROTO_XGW):
+            goto _is_xgw;
+        default:
+            goto _not_xgw;
+    }
+
+    // PTR POINTS TO TRANSPORT
+    // PROTO IS TRANSPORT SIZE
+
+    hdr = ptr;
+
+    if ((ptr += proto) > end)
+        ret_dev(DSTATS_I_INCOMPLETE);
+
+    if (!ports_is_enabled(BE16(((u16*)hdr)[1])))
+        goto _not_xgw;
+
+_is_xgw:
+
+    // AGORA SABE ONDE COMECA O PKT
+    pkt_s* const pkt = (ptr + sizeof(hdr_x_s)) - sizeof(pkt_s);
+
+    if (PKT_DATA(pkt) > end)
+        // MISSING HEADER + ALIGN
+        ret_dev(DSTATS_I_INCOMPLETE);
+
+    const uint nid    = BE16 (pkt->x.src);
+    const uint dst    = BE16 (pkt->x.dst);
+    const uint pid    = BE8  (pkt->x.path);
+    const uint i      = BE8  (pkt->x.version);
+    const uint size   = BE16 (pkt->x.dsize);
+    const u64  ltime  = BE64 (pkt->x.time);
+    const u64  hash   = BE64 (pkt->x.hash);
+
+    if (nid == nodeSelf)
+        ret_dev(DSTATS_I_FROM_SELF);
+
+    if (dst != nodeSelf)
+        ret_node(NSTATS_I_FORWARD);
+
+    // TODO: UMA FLAG GLOBAL XGW IS DISABLED
+    // TODO: UMA STAT GLOBAL XGW IN IS DISABLED
+    // TODO: UMA STAT GLOBAL XGW OUT IS DISABLED
+
+    node_s* const node = nodes_get_unlocked(nid);
+
+    if (node == NULL)
+        ret_node(NSTATS_I_INEXIST);
+
+    if (node_is_off(node))
+        ret_node(NSTATS_I_DISABLED);
+
+    if (!(node->dev->flags & IFF_UP))
+        ret_dev(NSTATS_I_DOWN);
+
+    if (pid >= PATHS_N)
+        ret_node(NSTATS_I_PATH_INVALID);
+
+    path_s* const path = &node->paths[pid];
+
+    if (!(__atomic_load_n(&node->ipaths, __ATOMIC_SEQ_CST) & IPATH(pid)))
+        ret_path(PSTATS_I_DISABLED);
+
+    if (i < I_KEYS_DYNAMIC) {
+        if (size < XGW_PAYLOAD_MIN)
+            // BAD SIZE FOR A NORMAL PACKET
+            ret_path(PSTATS_I_SIZE_SMALL);
+    } elif (size != PING_SIZE)
+            // BAD SIZE FOR A PING PACKET
+            ret_path(PSTATS_I_SIZE_NOT_PING);
+
+    if ((PKT_DATA(pkt) + size) > end)
+            // WE DON'T HAVE THE ENTIRE PACKET
+            ret_path(PSTATS_I_SIZE_TRUNCATED);
+
+    // SITUATION VS PACKET TYPE
+    switch (atomic_get(&path->answered)) {
+
+        default: // >= PTIME_MIN
+            if (i == I_KEY_SYN)
+                // ESTABLISHED RECEBE TUDO MENOS SYN
+                ret_path(PSTATS_I_ESTABLISHED_REFUSE_SYN);
+            break;
+
+        case ANSWERED_CONNECTING:
+            if (i != I_KEY_PONG)
+                // CONNECTING SO RECEBE PONGS
+                ret_path(PSTATS_I_CONNECTING_REQUIRE_PONG);
+            break;
+
+        case ANSWERED_LISTENING:
+            if (i == I_KEY_SYN) {
+                if (0)
+                    // LIMITAR A QUANTIDADE DE SYNS RECEBIVEIS A CADA KEEPER INTERVAL
+                    ret_path(PSTATS_I_LISTENING_SYN_TOO_MANY);
+                if (ltime != atomic_get(&path->syn))
+                    // ELE NAO CONHECE NOSSO CODIGO
+                    ret_path(PSTATS_I_LISTENING_SYN_WRONG);
+            } elif (i != I_KEY_PING)
+                    // LISTENING SO RECEBE SYN E PING
+                    ret_path(PSTATS_I_LISTENING_REFUSE_DATA_AND_PONG);
+            break;
+
+        case ANSWERED_ACCEPTING:
+            // LISTENING, MAS EM ESTADO DE ACCEPTING
+            ret_path(PSTATS_I_ACCEPTING);
+            break;
+    }
+
+    if (i != I_KEY_SYN)
+        // NOTE: CONSIDERA QUE O PEER ESTIMOU NOSSO TIME A PARTIR DO RTT CALCULADO POR ELE, QUE PODE SER ATE RTT_MAX (E QUE ESTES SAO DIFERENTES DOS NOSSOS)
+        // NOTE: CONSIDERA CLOCK SKELS LOCAL/REMOTE
+        // NOTE: CONSIDERA QUE LEVOU UM LATENCY ATÉ CHEGAR AQUI
+        // NOTE: CONSIDERA CPU BUSY TIMES
+        if (ABS_DIFF(ltime + atomic_get(&path->rtt)/2, path->mask + get_current_ms()) > atomic_get(&path->rtt_var)/2)
+            // ELE NAO CONHECE NOSSO TIME (OU TEM UM SKEW GRANDE)
+            ret_path(PSTATS_I_LTIME_MISMATCH);
+
+    // DECRYPT
+    if (pkt_decrypt(node, i, pkt, size) != hash)
+        // CORRUPT
+        ret_path(PSTATS_I_HASH_MISMATCH);
+
+    // IS A EXPECTED TYPE FOR OUR STATUS
+    // IS AUTHENTIC (hash)
+    // IS SYNCED (time)
+
+    if (i >= I_KEY_PING)
+        ret_path(in_ping(node, skb, pkt));
+
+    // NORMAL PACKET
+
+    // AVANCA O ALIGNMENT
+    void* const orig = PKT_DATA(pkt);
+
+    if (BE8(*(u8*)orig) == 0x45) { // TODO:
+
+        // NOTE: AQUI CONSIDERA O IP4 + PORTAS
+        if ((orig + sizeof(ip4_s)) > end)
+            ret_path(PSTATS_I_DATA_IP4_TRUNCATED);
+
+#ifdef CONFIG_XGW_GATEWAY_TCP_PROXY
+        ip4_s* const ip = orig;
+
+        if (ip->proto == BE8(IPPROTO_TCP)) {
+            // TODO: SE FOR SYN/SYN-ACK, ADJUST MSS
+            if (BE32(ip->saddr ^ ip->daddr) >> 8) { // TODO:
+                // XGW -> INTERNET
+                // WILL BE TREATED AS SELF, SO NO NEED FOR TCP CHECKSUM
+                skb->mark  = XGW_TCP_PROXY_MARK_4 | BE16(ip->dport);
+                ip->dport  = BE16(CONFIG_XGW_GATEWAY_TCP_PROXY_PORT);
+            }
+        }
+#endif
+
+        skb->protocol = BE16(ETH_P_IP);
+
+    } else { ASSERT((BE8(*(u8*)orig) >> 4) == 6);
+
+        if ((orig + sizeof(ip6_s)) > end)
+            ret_path(PSTATS_I_DATA_IP6_TRUNCATED);
+
+#ifdef CONFIG_XGW_GATEWAY_TCP_PROXY
+        ip6_s* const ip = orig;
+
+        if (ip->proto == BE8(IPPROTO_TCP)) {
+            // TODO: SE FOR SYN/SYN-ACK, ADJUST MSS
+            if (BE64(ip->saddr[0] ^ ip->daddr[0])) { // TODO:
+                // XGW -> INTERNET
+                // WILL BE TREATED AS SELF, SO NO NEED FOR TCP CHECKSUM
+                skb->mark  = XGW_TCP_PROXY_MARK_6 | BE16(ip->dport);
+                ip->dport  = BE16(CONFIG_XGW_GATEWAY_TCP_PROXY_PORT);
+            }
+        }
+#endif
+
+        skb->protocol = BE16(ETH_P_IPV6);
+    }
+
+    //
+    skb->len            = size;
+    skb->data           = orig;
+    skb->network_header = orig        - SKB_HEAD(skb);
+#ifdef NET_SKBUFF_DATA_USES_OFFSET // SKB TRIM QUE NEM É FEITO NO ip_rcv_core()
+    skb->tail           = orig + size - SKB_HEAD(skb);
+#else
+    skb->tail           = orig + size;
+#endif
+ // skb->mac_header
+ // skb->mac_len
+#if 0
+    skb->ip_summed      = CHECKSUM_COMPLETE;
+    skb->csum_valid     = 1;
+    skb->csum_complete_sw = 1;
+#else // LIKE WIREGUARD
+    skb->ip_summed      = CHECKSUM_UNNECESSARY;
+    skb->csum_level     = ~0;
+#endif
+    skb->dev            = node->dev;
+    skb->pkt_type       = PACKET_HOST; // WE MAY BE RECEIVING VIA MULTICAST/BROADCAST
+    // TODO: ON OUT: skb->type = PACKET_BROADCAST | PACKET_MULTICAST | PACKET_OTHERHOST | PACKET_OUTGOING
+
+    stat = PSTATS_I_DATA_GOOD;
+
+_ret_path: _stat = path->stats;       goto _ret;
+_not_xgw:   stat = DSTATS_I_NOT_XGW; // JUST SOME PACKET, TRAVELING AROUND THE WORLD IN 80 HOPS
+_ret_dev:  _stat = dstats;            goto _ret;
+_ret_node: _stat = nstats[nid];
+_ret:
+
+    stat_inc_count(&_stat[stat].count);
+    stat_inc_bytes(&_stat[stat].bytes, skb->len);
+
+    // NOTE QUE TODOS OS STATS PASS SAO 0
+    return stat;
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/in_discover.c linux-master/drivers/net/xgw/in_discover.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/in_discover.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/in_discover.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,130 @@
+
+enum PPP_PROTO {
+    PPP_PROTO_IP4   = 0x0021,
+    PPP_PROTO_IP6   = 0x0057,
+    PPP_PROTO_LCP   = 0xC021, // Protocol: Link Control Protocol (0xc021)
+    PPP_PROTO_PAP   = 0xC023, // Protocol: Password Authentication Protocol (0xc023)
+    PPP_PROTO_IPCP4 = 0x8021, // Protocol: Internet Protocol Control Protocol (0x8021)
+    PPP_PROTO_IPCP6 = 0x8057, // Protocol: IPv6 Control Protocol (0x8057)
+    PPP_PROTO_XGW   = 0x2562,
+};
+
+// ASSERT: IPPROTO_UDP != PPP_PROTO_IP4
+// ASSERT: IPPROTO_UDP != PPP_PROTO_IP6
+BUILD_ASSERT(IPPROTO_UDP != ETH_P_IP);
+BUILD_ASSERT(IPPROTO_UDP != ETH_P_IPV6);
+
+// ASSERT: IPPROTO_TCP != PPP_PROTO_IP4
+// ASSERT: IPPROTO_TCP != PPP_PROTO_IP6
+BUILD_ASSERT(IPPROTO_TCP != ETH_P_IP);
+BUILD_ASSERT(IPPROTO_TCP != ETH_P_IPV6);
+
+static inline void in_discover (const path_s* const path, const skb_s* const skb, pkt_s* const skel) {
+
+    const void* orig = SKB_NETWORK(skb);
+
+    // POR SEGURANCA VAMOS EXIGIR ETH_HLEN
+    // É MELHOR FICAR SEM HARDWARE HEADER DO QUE PROBLEMAS MAIORES
+    uint T = skb->mac_len == ETH_HLEN ? __ETH : 0;
+
+    uint proto = skb->protocol;
+
+    switch (proto) {
+        case BE16(ETH_P_8021Q):
+        case BE16(ETH_P_8021AD): // NOTE: PODE ACABAR VIRANDO __VLAN SEM __ETH
+            T |= __VLAN;
+            proto = ((hdr_vlan_s*)orig)->proto;
+            orig += sizeof(hdr_vlan_s);
+            break;
+    }
+
+    switch (proto) {
+        case BE16(ETH_P_PPP_SES):
+            T |= __PPP;
+            proto = ((hdr_ppp_s*)orig)->proto;
+            orig += sizeof(hdr_ppp_s);
+            break;
+    }
+
+    switch (proto) {
+        case BE16(PPP_PROTO_IP4):
+        case BE16(ETH_P_IP):
+            T |= __IP4;
+            proto = ((hdr_ip4_s*)orig)->proto;
+            orig += sizeof(hdr_ip4_s);
+            break;
+        case BE16(PPP_PROTO_IP6):
+        case BE16(ETH_P_IPV6):
+            T |= __IP6;
+            proto = ((hdr_ip6_s*)orig)->proto;
+            orig += sizeof(hdr_ip6_s);
+            break;
+    }
+
+    switch (proto) {
+        case BE8(IPPROTO_UDP):
+            T |= __UDP;
+            orig += sizeof(hdr_udp_s);
+            break;
+        case BE8(IPPROTO_TCP):
+            T |= __TCP;
+            orig += sizeof(hdr_tcp_s);
+            break;
+    }
+
+    //
+    orig -= offsetof(pkt_s, x);
+
+    memcpy(skel, &models[T], sizeof(pkt_s));
+
+    ASSERT(skel->type == T);
+
+    if (T & __ETH) {
+        memcpy(PTR(skel) + skel->moffset + 6, orig + skel->moffset + 0, 6);
+        memcpy(PTR(skel) + skel->moffset + 0, orig + skel->moffset + 6, 6);
+    }
+
+    if (T & __VLAN) // COPIA O VPROTO E O VID
+        memcpy(PTR(skel) + skel->moffset + 12, orig + skel->moffset + 12, 4);
+
+    if (T & __PPP)
+        // COPIA O CODE, SESSION, SIZE E PROTOCOL
+        // O SIZE OVERWRITED DEPOIS
+        memcpy(PTR(skel) + skel->_reserved, orig + skel->_reserved, 8);
+
+    if (T & __IP4) {
+        memcpy(PTR(skel) + skel->Noffset + 16, orig + skel->Noffset + 12, 4);
+        memcpy(PTR(skel) + skel->Noffset + 12, orig + skel->Noffset + 16, 4);
+    } elif (T & __IP6) {
+        memcpy(PTR(skel) + skel->Noffset + 24, orig + skel->Noffset +  8, 16);
+        memcpy(PTR(skel) + skel->Noffset +  8, orig + skel->Noffset + 24, 16);
+    }
+
+    if (T & (__UDP | __TCP)) {
+        memcpy(PTR(skel) + skel->toffset + 0, orig + skel->toffset + 2, 2);
+        memcpy(PTR(skel) + skel->toffset + 2, orig + skel->toffset + 0, 2);
+    }
+
+    // TEM QUE FAZER ISSO AQUI
+    skel->x.dst  = ((pkt_s*)orig)->x.src;
+    skel->x.src  = ((pkt_s*)orig)->x.dst;
+    skel->x.path = ((pkt_s*)orig)->x.path;
+ // skel->x.version --> ON encrypt()
+ // skel->x.dsize   --> ON encrypt()
+ // skel->x.seed    --> ON encrypt()
+ // skel->x.hash    --> ON encrypt()
+
+    // PRECISA DISSO POIS SE FOR VLAN AI DIFERE
+    skel->protocol = skb->protocol;
+    skel->phys     = skb->dev;
+
+    // SET TOS/TTL FROM PATH
+    if (T & __IP4) { hdr_ip4_s* const ip4 = PKT_IP4(skel);
+        ip4->tos = BE8(path->tos);
+        ip4->ttl = BE8(path->ttl);
+    } elif (T & __IP6) { hdr_ip6_s* const ip6 = PKT_IP6(skel);
+        ip6->tos = BE8(path->tos);
+        ip6->ttl = BE8(path->ttl);
+        ip6->flow = BE16(SKEL_IP6_FLOW(path->node, path));
+    }
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/Kconfig linux-master/drivers/net/xgw/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/Kconfig	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,100 @@
+
+menuconfig XGW
+    bool  "XGW"
+    default n
+
+if XGW
+
+    config    XGW_ASSERT
+        bool "XGW_ASSERT"
+        default n
+
+    config    XGW_DEBUG
+        bool "XGW_DEBUG"
+        default n
+
+if XGW_DEBUG
+
+    config    XGW_DEBUG_IDROP
+        bool "XGW_DEBUG_IDROP"
+        default n
+
+    config    XGW_DEBUG_ODROP
+        bool "XGW_DEBUG_ODROP"
+        default n
+
+endif
+
+    config    XGW_NMAP
+        bool "XGW_NMAP"
+        default n
+
+    config    XGW_GATEWAY
+        bool "XGW_GATEWAY"
+        default n
+
+    config    XGW_GATEWAY_TCP_PROXY
+        bool "XGW_GATEWAY_TCP_PROXY"
+        depends on XGW_GATEWAY
+        default n
+
+    config   XGW_GATEWAY_TCP_PROXY_PORT
+        int "XGW_GATEWAY_TCP_PROXY_PORT"
+        depends on XGW_GATEWAY_TCP_PROXY
+        default 80
+
+    config    XGW_RDRAND
+        bool "XGW_RDRAND"
+        default n
+
+    config    XGW_RDTSC
+        bool "XGW_RDTSC"
+        default y
+
+    config    XGW_BEEP
+        bool "XGW_BEEP"
+        default n
+
+    config   XGW_BEEP_BASE
+        int "XGW_BEEP_BASE"
+        default 2000
+        depends on XGW_BEEP
+
+    config   XGW_BEEP_MAX
+        int "XGW_BEEP_MAX"
+        default 2500
+        depends on XGW_BEEP
+
+    config XGW_CONNS_MIN
+      int "XGW_CONNS_MIN"
+        default 1
+
+    config XGW_CONNS_MAX
+      int "XGW_CONNS_MAX"
+        default 524288
+
+    config XGW_RANDOM_INIT_IPAIRS
+      hex "XGW_RANDOM_INIT_IPAIRS"
+        default 0x7f8e60fe040b73a1
+
+    config XGW_RANDOM_INIT_OPAIRS
+      hex "XGW_RANDOM_INIT_OPAIRS"
+        default 0xbd86b79f3de791dc
+
+    config XGW_RANDOM_ENCRYPT_SEED
+      hex "XGW_RANDOM_ENCRYPT_SEED"
+        default 0xb9f3acba3f6efdcf
+
+    config XGW_RANDOM_ENCRYPT_ALIGN
+      hex "XGW_RANDOM_ENCRYPT_ALIGN"
+        default 0x625185f5756462d8
+
+    config XGW_RANDOM_PING
+      hex "XGW_RANDOM_PING"
+        default 0x59114f654f2185ad
+
+    config XGW_RANDOM_INIT
+      hex "XGW_RANDOM_INIT"
+        default 0xb5bea7cb62e5ffd4
+
+endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/kconfig.h linux-master/drivers/net/xgw/kconfig.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/kconfig.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/kconfig.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,38 @@
+//
+
+#define _CONNS_MIN       1
+#define _CONNS_MAX 4194304 // 4MB
+
+// VALIDATE CONFIG
+
+#if CONFIG_XGW_CONNS_MIN < _CONNS_MIN \
+ || CONFIG_XGW_CONNS_MIN > _CONNS_MAX
+#error    "BAD CONNS MIN"
+#endif
+
+#if CONFIG_XGW_CONNS_MAX < _CONNS_MIN \
+ || CONFIG_XGW_CONNS_MAX > _CONNS_MAX
+#error    "BAD CONNS MAX"
+#endif
+
+#if CONFIG_XGW_CONNS_MIN \
+  > CONFIG_XGW_CONNS_MAX
+#error    "BAD CONNS MIN/MAX"
+#endif
+
+#ifdef CONFIG_XGW_BEEP
+
+#if CONFIG_XGW_BEEP_BASE < 100
+#error    "BAD BEEP BASE"
+#endif
+
+#if CONFIG_XGW_BEEP_MAX > 5000
+#error    "BAD BEEP MAX"
+#endif
+
+#if ((CONFIG_XGW_BEEP_BASE >= CONFIG_XGW_BEEP_MAX) && (CONFIG_XGW_BEEP_BASE - CONFIG_XGW_BEEP_MAX) >  1000) \
+ || ((CONFIG_XGW_BEEP_BASE <= CONFIG_XGW_BEEP_MAX) && (CONFIG_XGW_BEEP_BASE - CONFIG_XGW_BEEP_MAX) < -1000)
+#error    "BAD BEEP BASE/MAX"
+#endif
+
+#endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/keeper.c linux-master/drivers/net/xgw/keeper.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/keeper.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/keeper.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,431 @@
+
+static inline void keeper_send_pings (void) {
+
+    // SEND PINGS
+    for_count (q, PING_QUEUES_N) {
+
+        path_s** ptr = &pings[q]; path_s* path;
+
+        while ((path = *ptr)) {
+            if (path->info & K_ESTABLISHED) {
+
+                ASSERT((path->asked    >= PTIME_MIN &&
+                        path->asked    <= PTIME_MAX) ||
+                        path->asked    == 0);
+                ASSERT((path->answered >= PTIME_MIN && 
+                        path->answered <= PTIME_MAX) ||
+                        path->answered == ANSWERED_CONNECTING);
+                ASSERT(path->mask     >= PMASK_MIN);
+                ASSERT(path->mask     <= PMASK_MAX);
+                ASSERT(path->tdiff    >= TDIFF_MIN);
+                ASSERT(path->tdiff    <= TDIFF_MAX);
+
+                const u64 now = path->mask + get_current_ms();
+
+                ASSERT(now >= PTIME_MIN);
+                ASSERT(now <= PTIME_MAX);
+
+                __atomic_store_n(&path->asked, now, __ATOMIC_RELAXED);
+
+                const uint o =
+                    atomic_get(&path->answered) == ANSWERED_CONNECTING ?
+                        O_KEY_SYN :
+                        O_KEY_PING;
+
+                const u64 rtime = (o == O_KEY_SYN) ?
+                    path->syn : RTIME(now, atomic_get(&path->tdiff));
+
+#if 0
+                ASSERT((rtime >= PTIME_MIN &&
+                        rtime <= PTIME_MAX) ||
+                        rtime == path->syn);
+#endif
+                if (!((rtime >= PTIME_MIN &&
+                        rtime <= PTIME_MAX) ||
+                        rtime == path->syn)) {
+                    printk("XGW: CRAZY: NODE [%s] PATH [%s] now = 0x%016llX rtime = 0x%016llX tdiff %lld \n",
+                            path->node->name,
+                            path->name,
+                            (uintll)now,
+                            (uintll)rtime,
+                            (long long int)path->tdiff
+                        );
+                }
+
+                // NOTE: RESERVA HEAD AND TAIL ROOM POIS PODE TER MAIS ENCAPSULAMENTOS NO PHYS
+                ping_send(path->node, path, &path->skel, now, rtime, o);
+
+                ptr = &path->next;
+            } else // NOTE: NOW PATH->NEXT IS INVALID
+               *ptr =  path->next;
+        }
+    }
+}
+
+static void keeper (struct timer_list* const timer) {
+
+    // jiffies +
+    timer->expires += KEEPER_INTERVAL_JIFFIES;
+
+#ifdef CONFIG_XGW_BEEP
+    uint beep = 0; // O OBJETIVO É BEEPAR CONFORME A SITUAÇÃO DO PIOR node
+    // CONFORME OS NODES
+#endif
+
+    // LOCK
+    unsigned long iflags;
+
+    spin_lock_irqsave(&xlock, iflags);
+
+    const u64 _now = get_current_ms();
+
+    for (node_s* node = knodes; node; node = node->next) {
+
+        ASSERT(!node_is_off(node));
+        ASSERT(*node->ptr == node);
+        ASSERT(node->info & N_CONNS_N);
+        ASSERT(node->info & N_MTU);
+        ASSERT(node->info & N_NAME);
+     // ASSERT(node->info & N_OADD);
+        ASSERT(node->mtu >= MTU_MIN);
+        ASSERT(node->mtu <= MTU_MAX);
+        ASSERT(node->connsN >= CONNS_MIN);
+        ASSERT(node->connsN <= CONNS_MAX);
+        ASSERT((node->info   & N_INFO) == node->info);
+        ASSERT((node->opaths & OPATHS) == node->opaths);
+        ASSERT((node->ipaths & IPATHS) == node->ipaths);
+        ASSERT((node->kpaths & KPATHS) == node->kpaths);
+        ASSERT((node->opaths & (node->kpaths * OPATH_0)) == node->opaths);
+        ASSERT((node->ipaths & (node->kpaths * IPATH_0)) == node->ipaths);
+        ASSERT(node->oVersions[O_KEY_PING] == I_KEY_PING);
+
+#ifdef CONFIG_XGW_BEEP // SITUACAO DESTE NODE, CONFORME OS PATHS
+        uint stableWeights = 0, stableSum = 0;
+#endif
+
+        // BUILD
+        u64 opaths = 0;
+
+        // ITERATE
+        uint kpaths = node->kpaths;
+
+        while (kpaths) { const uint pid = __ctz(kpaths); kpaths ^= KPATH(pid);
+
+            path_s* const path = &node->paths[pid];
+
+            ASSERT(path->node == node);
+            ASSERT(path->rtt <= RTT_MAX);
+            ASSERT(path->rtt_max <= RTT_MAX);
+            ASSERT(path->rtt <= path->rtt_max);
+            ASSERT(path->rtt_var_ >= RTT_VAR_MIN);
+            ASSERT(path->rtt_var_ <= RTT_VAR_MAX);
+            ASSERT(path->rtt_var >= RTT_VAR_MIN);
+            ASSERT(path->rtt_var <= RTT_VAR_MAX_INIT);
+            ASSERT(path->rtt_var >= path->rtt_var_);
+            ASSERT(path->cdown <= RTT_VAR_STEPS);
+            ASSERT(path->tdiff >= TDIFF_MIN);
+            ASSERT(path->tdiff <= TDIFF_MAX);
+            ASSERT((path->asked    >= PTIME_MIN &&
+                    path->asked    <= PTIME_MAX) ||
+                    path->asked    == 0);
+            ASSERT((path->answered >= PTIME_MIN && 
+                    path->answered <= PTIME_MAX) ||
+                    path->answered == ANSWERED_LISTENING || 
+                    path->answered == ANSWERED_ACCEPTING || 
+                    path->answered == ANSWERED_CONNECTING);
+            ASSERT(path->mask >= PMASK_MIN);
+            ASSERT(path->mask <= PMASK_MAX);
+            ASSERT(path->oadd >= PATH_OADD_MIN);
+            ASSERT(path->oadd <= PATH_OADD_MAX);
+
+            if (path->info & K_START) { //231956
+
+                if (path->info & P_CLIENT) {
+
+#if 0
+                    if (path->info & P_DHCP) {
+
+                        if (1) {
+                          // DHCP IS DONE
+                          if (path_is_ip4(path)) {
+                              ASSERT(dhcp->type == ipv4);
+                              // copy ipv4 address to src
+                          } elif (path_is_ip6(path)) {
+                              ASSERT(dhcp->type == ipv6);
+                              // copy ipv6 address to src
+                          }
+                          // copy phys
+                          // copy smac
+                          // copy dmac
+                          // copy eth protocol
+                          // copy vlan id
+                        } else
+                            // CANNOT START YET
+                            goto _skip;
+                    }
+#endif
+
+                    // THE TTL AND TOS ARE STORED OUTSIDE THE SKEL, OTHERWISE WE LOSE THEM ON EVERY IN-DISCOVER.
+                    // SO, THE CMD ALSO STORED THEM DIRECTLY ON PATH.
+                    // HERE WE COPY THEM TO THE SKEL
+                    if (path_is_ip4(path)) { hdr_ip4_s* const ip4 = PKT_IP4(&path->skel);
+                        ip4->tos = BE8(path->tos);
+                        ip4->ttl = BE8(path->ttl);
+                    } elif (path_is_ip6(path)) { hdr_ip6_s* const ip6 = PKT_IP6(&path->skel);
+                        ip6->tos = BE8(path->tos);
+                        ip6->ttl = BE8(path->ttl);
+                        ip6->flow = BE16(SKEL_IP6_FLOW(node, path));
+                    }
+
+                    // TODO: PRECOMPUTE TCP CHECKSUM
+                    // TODO: PRECOMPUTE UDP CHECKSUM (FOR IPV6)
+                    if (path_is_udp_tcp(path)) {
+                        path->sPortIndex = ((uint)path->sPortIndex + 1                      ) % path->sPortsN;
+                        path->dPortIndex = ((uint)path->dPortIndex + (path->sPortIndex == 0)) % path->dPortsN;
+                        // BOTH UDP AND TCP PORTS START ON TRANSPORT
+                        hdr_udp_s* const udp = PKT_UDP(&path->skel);
+                        udp->sport = BE16(path->sPorts[path->sPortIndex]);
+                        udp->dport = BE16(path->dPorts[path->dPortIndex]);
+                    }
+
+                    // TODO: FAZER ISSO A TODOS OS NODES-PATHS AO SETAR O SELF
+                    // TODO: TEM QUE REPENSAR O CRYPTO DERIVATE, POIS SENAO SE MUDAR O SELF, TERA DE SETAR NOVAMENTE O SECRET
+                    path->skel.x.src   = BE16(nodeSelf);
+                    path->acks         = ACKS_CLIENT;
+                    path->answered     = ANSWERED_CONNECTING;
+                } else {
+                    printk("XGW: %s [%s]: LISTENING\n", node->name, path->name);
+                    path->skel.type    = 0; //
+                    path->acks         = ACKS_SERVER;
+                    path->answered     = ANSWERED_LISTENING;
+                }   path->asked        = 0; // AINDA NAO ENVIEI PING
+                    path->pseen[0]     = 0;
+                    path->pseen[1]     = 0;
+                    path->rtt          = path->rtt_max / 2;
+                    path->rtt_var      = path->rtt_var_ + RTT_VAR_STEPS * RTT_VAR_STEP;
+                    path->cdown        = RTT_VAR_STEPS;
+                    path->info        ^= K_START | K_LISTEN;
+                    path->since        = 0;
+                    path->tdiff        = 0;
+                    path->mask         = PMASK_MIN + (random64(_now) % (PMASK_MAX - PMASK_MIN));
+                 // path->olatency   == ?
+
+                // ENABLE IN
+                // NOTE: AQUI ENTAO TEM UM RACE CONDITION, ELE PODE RECEBER UM PING/PONG E COMO SERÁ INTERPRETADO?
+                __atomic_store_n(&node->ipaths, node->ipaths | IPATH(pid), __ATOMIC_SEQ_CST);
+            }
+
+            if (path->info & K_LISTEN) {
+
+                if (__atomic_load_n(&path->answered, __ATOMIC_SEQ_CST) >= ANSWERED_CONNECTING) {
+
+                    printk("XGW: %s [%s]: %s ON PHYS %s WITH RTT %u +%u\n",
+                        node->name, path->name, (path->info & P_SERVER) ? "ACCEPTED" : "CONNECTING", path->skel.phys->name, (uint)path->rtt, (uint)path->rtt_var);
+
+             ASSERT(path->since    == 0);
+                    path->info     ^= K_LISTEN | K_ESTABLISHED;
+                    path->since     = _now;
+                 // AT THIS POINT, THE PATH->SKEL WAS BUILT
+                 //      a) FROM USER (CMD)
+                 //      b) FROM IN (DISCOVER)
+             ASSERT(path->skel.x.src  == BE16(nodeSelf));
+             ASSERT(path->skel.x.dst  == BE16(node->nid));
+             ASSERT(path->skel.x.path == BE8 (PATH_ID(node, path)));
+                 // path->skel.x.version --> ON encrypt()
+                 // path->skel.x.dsize   --> ON encrypt()
+                 // path->skel.x.time    --> ON encrypt()
+                 // path->skel.x.hash    --> ON encrypt()
+             ASSERT(path->skel.phys);
+
+                    // PASSA A ENVIAR PINGS
+                    const uint q = path->skel.phys->ifindex % PING_QUEUES_N;
+
+                    path->next = pings[q];
+                                 pings[q] = path;
+                }
+            }
+
+            if (path->info & K_ESTABLISHED) {
+
+                u64 acks;
+
+                const u64 answered = atomic_get(&path->answered);
+
+                ASSERT((answered >= PTIME_MIN && 
+                        answered <= PTIME_MAX) ||
+                        answered == ANSWERED_CONNECTING);
+
+                // SE NAO RECEBEU UM PONG, ESTE RTT SERÁ UM OVERFLOW
+                // É POR ISSO QUE ANSWERED_CONNECTING TEM QUE SER MAIOR DO QUE O RTT_MAX,
+                // POIS SE O ASKED ESTIVER ZERADO,
+                // QUALQUER PATH->ANSWERED QUE NAO SEJA O LAST PING ENVIADO,
+                // TEM QUE RESULTAR EM > RTT_MAX
+                const uint took = answered - path->asked;
+
+                if (took <= RTT_MAX) {
+                    // AVERAGE, CAPPED TO LIMITS
+                    uint rtt = ((uint)path->rtt*7 + took*1) / (7 + 1);
+                    if (rtt > path->rtt_max)
+                        rtt = path->rtt_max;
+                    // SAVE THE NEW AVERAGE
+                    if (path->cdown) {
+                        path->cdown--;
+                        __atomic_store_n(&path->rtt_var, path->rtt_var - RTT_VAR_STEP, __ATOMIC_RELAXED);
+                    }  // __atomic_store_n(&path->olatency, (rtt + path->rtt_var)/2 + path->oadd, __ATOMIC_RELAXED);
+                        __atomic_store_n(&path->rtt, rtt, __ATOMIC_RELAXED);
+                    // A SECOND ELAPSED
+                    acks = (path->acks >> 1) | ((u64)(took <= (rtt + path->rtt_var)) << (ACKS_N - 1));
+                } else
+                    acks = (path->acks >> 1);
+
+                if (path->acks != acks) {
+                    path->acks = acks;
+                    // CHANGED
+
+                    const char* str;
+
+                    switch (acks) {
+                        case 0b0000000000000000000000000000000000000000000000000000000000000000ULL: str = "LOST";       break;
+                        case 0b1000000000000000000000000000000000000000000000000000000000000000ULL: str = "RECOVERING"; break;
+                        case 0b0111111111111111111111111111111111111111111111111111111111111111ULL: str = "UNSTABLE";   break;
+                        case 0b1111111111111111111111111111111111111111111111111111111111111111ULL: str = "STABLE";     break;
+                        default:                                                                    str = NULL;
+                    }
+
+                    if (str) {
+                        if (took <= RTT_MAX)
+                            printk("XGW: %s [%s]: RTT %u +%u; %s; PONG TOOK %u\n", node->name, path->name, (uint)path->rtt, (uint)path->rtt_var, str, took);
+                        else
+                            printk("XGW: %s [%s]: RTT %u +%u; %s; PONG LOST\n", node->name, path->name, (uint)path->rtt, (uint)path->rtt_var, str);
+                    }
+
+                } elif (!acks) {
+                    // TIMED OUT WAITING FOR PONGS
+                    printk("XGW: %s [%s]: TIMED OUT\n", node->name, path->name);
+                    goto _suspend;
+                }
+
+                // DOS PIORES AOS MELHORES
+                opaths |= ( // TEM QUE CONSIDERAR QUE ELE VAI ENTRAR NA FRENTE DOS OUTROS ENTAO PERDER 1 PONG E RECEBER UM VAI FORCAR A TROCA E FERRAR A ESTABILIDADE DAS STREAMS
+                    ((u64)(acks >= 0b000000010000000000000000000000000000000000000000ULL) << (3*PATHS_N)) | // BASTA QUE ESTEJA FUNCIONANDO ENTAO
+                    ((u64)(acks >= 0b010111111110000000000000000000000000000000000000ULL) << (2*PATHS_N)) |
+                    ((u64)(acks >= 0b111111111111111111110000000000000000000000000000ULL) << (1*PATHS_N)) | // NOTE: THIS ONE SHOULD BE REPEATED
+                    ((u64)(acks >= 0b111111111111111111110000000000000000000000000000ULL) << (0*PATHS_N)) // TODO: REMOVE THIS REPETITION LIMITATION
+                ) << pid;
+            }
+
+            if (path->info & K_SUSPEND) { // NOTE: WILL EXECUTE TWICE BECAUSE THE ATOMIC EXCHANTE BELOW
+_suspend:
+                // STOP IN
+                // STOP PING (BY REMOVING K_ESTABLISHED)
+                // STOP OUT (BY NOT INCLUDING IN OPATHS)
+                path->info  = (path->info & P_INFO) | K_SUSPENDING;
+                path->acks  = 0; // PARA JA ATUALIZAR O BEEP
+                path->since = 0;
+
+                __atomic_store_n(&node->ipaths, node->ipaths & ~IPATH(pid), __ATOMIC_RELAXED);
+
+            } elif (path->info & K_SUSPENDING) { BUILD_ASSERT(N_ON == P_ON);
+                if ((path->info ^= K_SUSPENDING) & node->info & N_ON & P_ON) {
+                     path->info |= K_START;
+                } else {
+                    printk("XGW: %s [%s]: STOPPED\n", node->name, path->name);
+                    // NOW THE PATH IS STOPPED
+                    // NOTE: THE PATH MAY BE ON, FOR EXAMPLE IF THE PATH STOPPED BECAUSE THE NODE STOPED
+                    node->kpaths ^= KPATH(pid);
+                }
+            }
+
+#ifdef CONFIG_XGW_BEEP
+            // NOTE: TEM QUE FAZER ISSO ENQUANTO O NODE E O PATH ESTIVEREM ATIVADOS
+            // TODO: MULTIPLICAR POR UM FATOR PARA NAO DEIXAR FICAR UM VALOR PEQUENO, JA QUE NAO PODE USAR FLOAT
+            // ASSIM MELHORARA A PRECISAO DO RESULTADO
+            if ((uint)(node->info & path->info & N_ON & P_ON) * path->weight * path->weight_acks) {
+                stableWeights += (1024 * path->weight);
+                stableSum += (popcount(path->acks & ((1ULL << path->weight_acks) - 1)) * (1024 * path->weight)) / path->weight_acks;
+            }
+#endif
+        }
+
+        if (node->info & N_ON) {
+            // SALVA
+
+            if (node->opaths != opaths) {
+#ifdef CONFIG_XGW_NMAP
+                if (!opaths)
+                    // O NODE AGORA VAI FICAR SEM PATHS FUNCIONANDO; PASSA A USAR O GW
+                    __atomic_store_n(&nmap[node->nid], node->gw, __ATOMIC_SEQ_CST);
+                elif (!node->opaths)
+                    // O NODE NÃO TINHA PATHS FUNCIONANDO E AGORA TEM; DEIXA DE USAR O GW
+                    __atomic_store_n(&nmap[node->nid], node->nid, __ATOMIC_SEQ_CST);
+#endif
+                __atomic_store_n(&node->opaths, opaths, __ATOMIC_SEQ_CST);
+            }
+
+#ifdef CONFIG_XGW_BEEP
+            if (node->weights) {
+                // (0 ... 1) * BEEP MAX
+                const uint q = CONFIG_XGW_BEEP_BASE + (((node->weights - wstable) * (CONFIG_XGW_BEEP_MAX - CONFIG_XGW_BEEP_BASE)) / node->weights);
+                if (beep > q)
+                    beep = q;
+            }
+#endif
+
+        } elif (nodes[node->nid] == node) {
+            // VAI FORCAR UM INTERVALO SEM O IN/OUT ACESSAR O NODE
+            // ALSO NEEDS A BREAK TIME FOR CHANGING COUNTERS
+
+#ifdef CONFIG_XGW_NMAP
+            // O NODE AGORA VAI FICAR OFF; PASSA A USAR O GW
+            __atomic_store_n(&nmap[node->nid], node->gw, __ATOMIC_SEQ_CST);
+#endif
+            __atomic_store_n(&node->opaths, 0, __ATOMIC_SEQ_CST);
+
+            ASSERT(!opaths);
+            ASSERT(!node->opaths);
+            ASSERT(!node->ipaths);
+
+            nodes_set_off(node->nid, node);
+
+        } elif (!node->kpaths) {
+
+            ASSERT(!opaths);
+            ASSERT(!node->opaths);
+            ASSERT(!node->ipaths);
+
+            __unlink(node);
+
+            printk("XGW: %s: STOPPED\n", node->name);
+        }
+
+#ifdef CONFIG_XGW_BEEP // SITUACAO DESTE NODE, CONFORME OS PATHS
+        if (node->info & N_ON) {
+            stableSum /= stableWeights;
+            if (beep < stableSum)
+                beep = stableSum;
+        }
+#endif
+    }
+
+    spin_unlock_irqrestore(&xlock, iflags);
+
+    keeper_send_pings();
+
+    // TODO: IF XGW IS DOWN, STOP BEEP
+#ifdef CONFIG_XGW_BEEP
+    if (beepStatus != BEEP_STATUS_DISABLED) {
+        // BEEP IS NOT DISABLED
+        if (beepStatus != BEEP_STATUS_SILENT)
+            // ESTAVA TOCANDO AGORA PAUSA
+            beep = BEEP_STATUS_SILENT;
+        if (beepStatus != beep)
+            beep_do((beepStatus = beep));
+    }
+#endif
+
+    add_timer_on(timer, 0);
+}
+
+static DEFINE_TIMER(kTimer, keeper);
+
+// TODO: CONFIRMAR QUE NAO ESTA REPETINDO O LINKING DO PING NO LINKED LIST
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/Makefile linux-master/drivers/net/xgw/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,45 @@
+
+CFLAGS_REMOVE_xgw.o += -Wno-unused-label
+
+CFLAGS_xgw.o += -Wfatal-errors
+CFLAGS_xgw.o += -Werror
+CFLAGS_xgw.o += -Wall
+CFLAGS_xgw.o += -Wextra
+CFLAGS_xgw.o += -Wunused-label
+CFLAGS_xgw.o += -Wsizeof-array-argument
+CFLAGS_xgw.o += -Wno-declaration-after-statement
+CFLAGS_xgw.o += -Wno-missing-declarations
+CFLAGS_xgw.o += -Wno-missing-prototypes
+CFLAGS_xgw.o += -Wno-error=sign-compare
+CFLAGS_xgw.o += -Wno-error=unused-parameter
+CFLAGS_xgw.o += -Wno-error=unused-function
+CFLAGS_xgw.o += -Wno-error=unused-label
+CFLAGS_xgw.o += -Wno-error=unused-variable
+CFLAGS_xgw.o += -Wno-error=date-time
+CFLAGS_xgw.o += -Wno-type-limits
+CFLAGS_xgw.o += -Wno-unused-parameter
+CFLAGS_xgw.o += -Wno-sign-compare
+ifeq ($(CONFIG_CC_IS_CLANG),y)
+CFLAGS_xgw.o += -Wno-c23-extensions
+endif
+
+CFLAGS_xgw.o += -mpopcnt
+
+# -mabm
+# -mbmi
+# -mbmi2
+# -mf16c
+# -mfma
+# -mfma4
+# -mpclmul
+# -mtbm
+
+ifneq ($(CONFIG_XGW_RDRAND),)
+CFLAGS_xgw.o += -mrdrnd
+endif
+
+
+# -moutline-atomics
+# -mno-outline-atomics
+
+obj-$(CONFIG_XGW) += xgw.o
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/nodes.h linux-master/drivers/net/xgw/nodes.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/nodes.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/nodes.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,267 @@
+
+//
+#define CONNS_MIN CONFIG_XGW_CONNS_MIN
+#define CONNS_MAX CONFIG_XGW_CONNS_MAX
+
+//
+#define CONNS_SIZE(connsN) ((connsN) * sizeof(u64))
+
+//
+#define NODE_NAME_SIZE 32
+#define PATH_NAME_SIZE 16 // "broad-bandz-p4u\0"
+
+//
+#define NODES_N 65536
+
+// MANY PATHS ARE GOOD FOR:
+//  - TRAFFIC SHAPING
+//  - TRAFFIC RATING (ISP WON'T SEE A SINGLE CONNECTION WITH TOO MANY SPEED/CUMULATIVE USAGE)
+//  - MORE SECURITY (MORE CODES USED) --- NOT ANYMORE
+//  - MORE SECURITY (MORE KEYS GENERATED)
+//  - MORE SECURITY (MORE KEYS GENERATED THUS EXPIRATION IS FASTER)
+//  - RESILIENCY AGAINST BROKEN PATHS
+//  - NIC HASHING
+//  - RECEIVE CAN BE DISTRIBUTED TO MORE CPUS
+#define PATHS_N 16
+
+//
+#define NID_MAX (NODES_N - 1)
+#define PID_MAX (PATHS_N - 1)
+
+//
+#define PATH_PORTS_N 4
+
+// TODO: ASSERT( (typeof(node->weights))(PATH_WEIGHT_MAX * PATHS_N) == (PATH_WEIGHT_MAX * PATHS_N) )
+#define PATH_WEIGHT_MAX 255
+
+// TODO: AUMENTAR ESTE PMASK_MIN, E AI O RTIME_MIN SERA 0
+#define PMASK_MIN ((u64)0x0000000000010000ULL)
+#define PMASK_MAX ((u64)0x2000000000000000ULL)
+
+// HOW MANY ACKS IN HISTORY (WORD WIDTH IN BITS)
+#define ACKS_N 64
+
+// NOTE: NAO ADIANTA SER MUITO LONGO POIS OS KEYS FICAM SENDO INUTILIZADOS
+// NOTE: NAO ADIANTA SER MUITO LONGO POIS FICA SEM SINCRONIA
+#define ACKS_SERVER (((u64)1) << 32)
+#define ACKS_CLIENT (((u64)1) << 63)
+
+// NODE INFO
+#define N_ON      (1U << 0)
+#define N_NAME    (1U << 1)
+#define N_MTU     (1U << 2)
+#define N_CONNS_N (1U << 3)
+#define N_SECRET  (1U << 4)
+#define N_INFO   ((1U << 5) - 1)
+
+// PATH STATUS/INFO
+#define P_ON                  (1U <<  0)
+#define P_CLIENT              (1U <<  1)
+#define P_SERVER              (1U <<  2)
+#define P_PHYS                (1U <<  3)
+#define P_MAC_SRC             (1U <<  4)
+#define P_MAC_DST             (1U <<  5)
+#define P_ADDR_SRC            (1U <<  6)
+#define P_ADDR_DST            (1U <<  7)
+#define P_PORT_SRC            (1U <<  8)
+#define P_PORT_DST            (1U <<  9)
+#define P_TOS                 (1U << 10)
+#define P_TTL                 (1U << 11)
+#define P_VPROTO              (1U << 12)
+#define P_VID                 (1U << 13)
+#define P_RTT_VAR             (1U << 14)
+#define P_NAME                (1U << 15)
+#define P_DHCP                (1U << 16)
+#define P_DHCP_MAC_DST_SERVER (1U << 17)
+#define P_DHCP_MAC_DST_GW     (1U << 18)
+#define P_EXIST               (1U << 19)
+// TODO: P_INFO_WEIGHT_NODE
+// TODO: P_INFO_WEIGHT_ACKS
+#define P_INFO               ((1U << 20) - 1)
+#define K_START               (1U << 20)
+#define K_SUSPEND             (1U << 21)
+#define K_SUSPENDING          (1U << 22)
+#define K_LISTEN              (1U << 23) // TODO: RENAME TO K_DISCOVERING
+#define K_ESTABLISHED         (1U << 24) // TODO: RENAME TO K_PINGING
+#define P_ALL                ((1U << 25) - 1)
+
+// P_VPROTO -> NOTE: IT IS THE ETH->PROTO, NOT THE VLAN->PROTO
+
+// INFORMACOES QUE SAO PERDIDAS AO MUDAR O TIPO DE ENCAPSULAMENTO
+// TODO: P_DHCP ?
+#define __P_TYPE_CLR (P_MAC_SRC | P_MAC_DST | P_ADDR_SRC | P_ADDR_DST | P_VPROTO | P_VID | P_DHCP)
+
+#define RTT_MAX 768
+
+//
+#define RTT_VAR_MIN    0
+#define RTT_VAR_MAX 2048
+
+// TEM QUE CONSIDERAR A DEMORA PARA IR ATUALIZANDO O RTT
+// 20 * 300 = 6000 (MAX SKEW FOR RTT)
+// 6000 / 2 = 3000 (MAX SKEW FOR RTT/2)
+#define RTT_VAR_STEPS 20
+#define RTT_VAR_STEP 300
+
+//
+#define RTT_VAR_MAX_INIT (RTT_VAR_MAX + RTT_VAR_STEPS * RTT_VAR_STEP)
+
+//
+#define PATH_OADD_MIN   1
+#define PATH_OADD_MAX 255
+
+// TODO: REMOVER ISSO
+// TODO: N_OADD
+// TODO: CMD_NODE_OADD_SET
+#define PATH_OADD_DEFAULT 64
+
+//
+#define PATH_SIZE 768
+
+struct path_s {
+// 64 -- KEEPER
+    u32 info;        // KEEPER (RW)
+    u16 weight;      // KEEPER (RO)
+    u16 weight_acks; // KEEPER (RO)
+    u16 rtt_max;     // KEEPER (RO) -- TODO: REIMPLEMENT THE COMMAND
+    u16 rtt;         // KEEPER (RW) / IN (R)
+    u16 rtt_var;     // KEEPER (RW) / IN (R) -- CURRENT ONE, BEING REDUCED UNTIL THE CONFIGURED BY USER
+    u8 cdown;        // KEEPER (RW)
+    u8 oadd;         // KEEPER (RO)
+    u64 acks;        // KEEPER (RW) -- HISTORY
+    u64 asked;       // KEEPER (RW) -- WHEN I ASKED - PARA MEDIR O RTT
+    node_s* node;    // KEEPER_SEND_PINGS
+    path_s* next;    // KEEPER_SEND_PINGS -- NA LISTA DE PINGS - ONLY VALID WHEN PATH STATUS >= K_UNSTABLE
+    u64 answered;    // KEEPER (R) / IN_PING (W) -- WHEN I RECEIVED ANSWER - PARA PARA MEDIR O RTT E SABER QUE A CONEXÃO ESTÁ VIVA
+    u64 pseen[2];    // IN_PING -- LAST PING/PONG->TIME RECEIVED (HIS RAW TIME) - SO WE DON'T ACCEPT REPEATED/GOINGBACKS
+    s64 tdiff;       // KEEPER (R) / IN [IF SYN/PING/PONG] (RW) / OUT (R)
+    u64 mask;        // KEEPER (R) / KEEPER [ON START] (W) / IN (R) / OUT (R)
+    u64 syn;         // KEEPER_SEND_PINGS [IF SYN] (R) / IN [IF SYN] (R) -- O PKT->TIME QUE O CLIENTE VAI USAR, ENQUANTO NAO DESCOBRE ELE
+    u64 since;       // KEEPER [ON START] (RW)
+// RO -- QUASE NAO USADO
+    char name [PATH_NAME_SIZE]; // 24
+    u16 sPorts [PATH_PORTS_N]; // 8 EM BIG ENDIAN
+    u16 dPorts [PATH_PORTS_N]; // 8
+    u8  sPortIndex:4, sPortsN:4;
+    u8  dPortIndex:4, dPortsN:4;
+    u8  tos;         // KEEPER / IN_DISCOVER
+    u8  ttl;         // KEEPER / IN_DISCOVER
+    u16 rtt_var_;    // KEEPER (RO) -- CONFIGURED BY USER
+    u16 olatency;    // KEEPER (WRITE) / OUT (READ) -- TODO: RETIRAR ISSO
+// 112 -- IN READ, OUT READ, IN WRITE (ON RECEIVE PING, WHILE OUT IS DISABLED)
+    pkt_s skel;
+// 512
+    volatile stat_s stats [32];
+};
+
+// A ARRAY DE INPUT É PARA AGUENTAR DEMORA/PERDA DE PACOTES
+// A CADA INTERVALO SAO ENVIADOS UM PING POR PATH *ATIVO*
+#define I_KEYS_ALL     256
+#define I_KEYS_DYNAMIC 253 // NAO TEM QUE CONSIDERAR O OVERFLOW POIS NO KEEPER NAO PRECISA SER ATOMIC
+#define I_KEY_PING     253
+#define I_KEY_PONG     254 // TEM QUE CABER E PREENCHER O PKT->VERSION
+#define I_KEY_SYN      255
+#define I_KEY_MAX      255
+
+// A ARRAY DE OUTPUT É PARA NAO PRECISAR DE LOCK
+#define O_KEYS_ALL     11
+#define O_KEYS_DYNAMIC  8 // TEM QUE SER DAR OVERFLOW CONFORME NODE->OCYCLE
+#define O_KEY_PING      8
+#define O_KEY_PONG      9
+#define O_KEY_SYN      10
+#define O_KEY_MAX      10
+
+//
+#define OPATH_0 0x0001000100010001ULL
+#define IPATH_0 0x0001U
+#define KPATH_0 0x0001U
+
+#define OPATHS  0xFFFFFFFFFFFFFFFFULL
+#define IPATHS  0xFFFFU
+#define KPATHS  0xFFFFU
+
+#define OPATH(pid) (OPATH_0 << (pid))
+#define IPATH(pid) (IPATH_0 << (pid))
+#define KPATH(pid) (KPATH_0 << (pid))
+
+// FOR THE NODE
+#define NODE_WEIGHTS_MAX (PATHS_N * PATH_WEIGHT_MAX)
+
+// TODO: USE ATTRIBUTES ALIGNMENT CACHE
+// THIS IS NOT CLEARED ON START
+#define NODE_SIZE_INIT offsetof(node_s, oKeys)
+
+struct node_s { // DEIXA TUDO NO MESMO CACHE LINE PARA A ITERACAO DO KEEPER
+// 64 -- KEEPER / IN / OUT
+    u64 opaths; // PATHS ALLOWED TO OUT
+    u16 kpaths; // PATHS TO KEEP
+    u16 ipaths; // PATHS ALLOWED TO IN
+    u16 mtu;
+    u16 weights;
+    u64* conns; // JIFFIES (60) | PID (4) -- GROUPS OF CONNECTIONS WITH SAME HASH
+    u32 connsN; // O OUT PRECISA DISSO  ((((1 << node->order) * PAGE_SIZE) - offsetof(node_s, conns)) / sizeof(conn_s))
+    u32 iCycle; // NOTE: O OVERFLOW VAI SER AOS BILHOES
+    u8  oCycle; // O OVERFLOW TEM QUE SER MULTIPLO DE O_KEYS_DYNAMIC
+    u8  oIndex; // QUAL SERA USADO PARA ENCRIPTAR
+    u8  oVersions [O_KEYS_ALL];
+    u8 info;
+    u16 sdsdsd; //
+    u64 aaaaaaa[2];
+// 32 -- RO - KEEPER/CMD
+    u16 nid;
+#ifdef CONFIG_XGW_NMAP
+    u16 gw;
+#else
+    u16 _gw;
+#endif
+    u32 reserved32;
+    node_s** ptr;
+    node_s* next;
+    net_device_s* dev; // TODO: USA MUITO NO IN, E TALVEZ NO OUT E NO CMD
+// 32 -- RO - NAME
+    char name [NODE_NAME_SIZE];
+// 128 --
+    u64 syns [PATHS_N]; // THE DEFAULT ONES
+// 14336 -- PATHS
+    path_s paths [PATHS_N];
+// ---------------------- NODE_SIZE_INIT -----------------------------
+// -- KEEPER/OUT READ, IN WRITE
+    u64 oKeys [O_KEYS_ALL] [K_LEN];
+// -- IN READ, KEEPER WRITE
+    u64 iKeys [I_KEYS_ALL] [K_LEN];
+// -- RO
+    u64 secret [SECRET_KEYS_N] [K_LEN]; // TODO: PARA SER DINAMICO, TERA QUE RESETAR TAMBEM O node->paths[*].pstats
+};
+
+#define node_is_off(node)  (((uintptr_t)(node)) & 1)
+
+#define nodes_set_on(nid, node)  __atomic_store_n(&nodes[nid], node, __ATOMIC_SEQ_CST)
+#define nodes_set_off(nid, node) __atomic_store_n(&nodes[nid], (node_s*)((uintptr_t)(node) | 1), __ATOMIC_SEQ_CST)
+
+// GETS A NODE WHILE THE LOCK IS NOT HOLD
+// NOTE: CALLER MUST THEN HANDLE THE OFF BIT
+#define nodes_get_unlocked(nid) __atomic_load_n(&nodes[nid], __ATOMIC_SEQ_CST)
+
+// GETS A NODE WHILE THE LOCK IS HOLD, WITH THE STATUS
+// NOTE: CALLER MUST THEN HANDLE THE OFF BIT
+#define nodes_get_locked_suspended(nid) (nodes[nid])
+
+// GETS A NODE WHILE THE LOCK IS HOLD, WITHOUT THE STATUS
+#if 1
+#define nodes_get_locked_unsuspended(nid) ((node_s*)((uintptr_t)nodes[nid] & ~((uintptr_t)1)))
+#else
+#define nodes_get_locked_unsuspended(nid) ((node_s*)(((uintptr_t)nodes[nid] >> 1) << 1))
+#endif
+
+//
+#define path_is_eth(path)  (path->skel.type & __ETH)
+#define path_is_vlan(path) (path->skel.type & __VLAN)
+#define path_is_ppp(path)  (path->skel.type & __PPP)
+#define path_is_ip4(path)  (path->skel.type & __IP4)
+#define path_is_ip6(path)  (path->skel.type & __IP6)
+#define path_is_udp(path)  (path->skel.type & __UDP)
+#define path_is_tcp(path)  (path->skel.type & __TCP)
+
+#define path_is_udp_tcp(path) (path->skel.type & (__UDP | __TCP))
+
+#define PATH_ID(node, path) ((path) - (node)->paths)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/out.c linux-master/drivers/net/xgw/out.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/out.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/out.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,192 @@
+
+static netdev_tx_t out (skb_s* const skb, net_device_s* const dev) {
+
+    // NOTE: THIS SIZE MAY BE WRONG, AS WE DIDNT LINEARIZE IT YET
+    uint stat; volatile stat_s* _stat;
+
+    if (skb_is_nonlinear(skb))
+        ret_dev(DSTATS_O_DATA_NON_LINEAR);
+
+    const size_t size = skb->len;
+
+    if (size < XGW_PAYLOAD_MIN)
+        ret_dev(DSTATS_O_DATA_SIZE_SMALL);
+
+    if (size > XGW_PAYLOAD_MAX)
+        ret_dev(DSTATS_O_DATA_SIZE_BIG);
+
+#ifdef CONFIG_XGW_GATEWAY_TCP_PROXY
+    switch (skb->mark & 0xFFFF0000U) { // TODO: TEM QUE IMPEDIR DE SETAR MANUALMENTE ESTES MARKS NO SETSOCKOPT, IPTABLES ETC
+
+        case XGW_TCP_PROXY_MARK_4: {
+
+            ASSERT(skb->protocol == BE16(ETH_P_IP));
+
+            ip4_s* const ip = SKB_NETWORK(skb);
+
+            ASSERT(ip->proto == BE8(IPPROTO_TCP));
+
+            // TODO: SE FOR SYN/SYN-ACK, ADJUST MSS
+            ip->sport  = BE16(skb->mark & 0xFFFFU);
+
+        } break;
+
+        case XGW_TCP_PROXY_MARK_6: {
+
+            // TODO:
+            ASSERT(skb->protocol == BE16(ETH_P_IPV6));
+
+            ip6_s* const ip = SKB_NETWORK(skb);
+
+            ASSERT(ip->proto == BE8(IPPROTO_TCP));
+
+            // TODO: SE FOR SYN/SYN-ACK, ADJUST MSS
+            ip->sport  = BE16(skb->mark & 0xFFFFU);
+
+        } break;
+    }
+#endif
+
+    // THE PAYLOAD (THIS WILL POINT TO THE NETWORK HEADER)
+    u64* const p = SKB_NETWORK(skb);
+
+    // WILL GET DESTINATION NODE AND HASH THE PATH
+    u64 nid, cid;
+
+    // NOTE: ASSUMINDO QUE O SKB->LEN TEM AO MENOS ESTES CABECALHOS
+    // NOTE: ASSUMINDO QUE NAO TEM IPV4/IPV6 OPTIONS
+    // NOTE: SE ATRAPALHA COM ICMP
+    if ((cid = BE64(p[0]) >> 56) == 0x45) { ASSERT(skb->protocol == BE16(ETH_P_IP));
+        // IPV4 (NOTE: ASSUMING NO IP OPTION/FRAGMENTATION)
+        // PROTO, SADDR, DADDR SPORT DPORT
+        cid = (p[1] & BE64(0x00FF0000FFFFFFFFULL)) + p[2];
+        // DEIXA SO O PREFIXO E O NODE
+        // THIS 32 IS BECAUSE WE HAVE ALSO READ THE PORTS
+        nid = ((BE64(p[2]) >> 32) ^ V4_PREFIX) >> (32 - V4_WIDTH_PREFIX - V4_WIDTH_NODE);
+        // OS BITS DA REDE QUE DIFERIREM DARAO 1, FAZENDO COM QUE O HID SEJA GRANDE
+        // OS BITS DO NODE DARAO OS MESMOS
+    } elif ((cid >> 4) == 0x6) { ASSERT(skb->protocol == BE16(ETH_P_IPV6));
+        // IPV6 (NOTE: ASSUMING NO IP NEXT HEADER/FRAGMENTATION)
+        // FLOW, PROTO, SADDR, DADDR
+        cid = (p[0] & BE64(0x000FFFFF0000FF00ULL)) + p[1] + p[2] + p[3] + p[4];
+        nid = (BE64(p[3]) ^ V6_PREFIX) >> (64 - V6_WIDTH_PREFIX - V6_WIDTH_NODE);
+    } else
+        // UNSUPORTED
+        ret_dev(DSTATS_O_DATA_UNKNOWN);
+
+    // TODO: CRIAR O XGW COMNETDEV priv?
+    if (dev == xgw) {
+        // IF ITS THROUGHT THE GLOBAL INTERFACE, WE MUST IDENTIFY THE DESTINATION NODE BY THE DESTINATION ADDRESS
+        if (nid >= NODES_N) {
+            // DESTINATION IS NOT A NODE
+            // NODE IS ONE OF THE GATEWAYS
+            if (gwsN == 0)
+                ret_dev(DSTATS_O_DATA_NO_GW);
+            nid = gws[popcount(cid) % gwsN];
+        }
+    } else
+        // WHATEVER THE DESTINATION IS, IT IS TUNNELED TO A SPECIFIC NODE BY IT'S INTERFACE
+        // TODO: UM FILTRO EM OUTRAS COISAS PARA NAO DEIXAR PASSAR PARA ENDERECOS XGW EM OUTRAS INTERFACES
+        // TODO: UM FILTRO EM OUTRAS COISAS PARA NAO DEIXAR PASSAR PARA MARCAS XGW EM OUTRAS INTERFACES
+        // IN THIS CASE THE NID READEN FROM THE ADDRESSES IS USELESS; AS WE CAN ROUTE TO A NODE THROUGHT ANODER ONE
+        nid = *(uint*)netdev_priv(dev); // TODO: JUMTO COM AQUELE IFFLAGS??
+
+    ASSERT(nid < NODES_N);
+
+    //
+#ifdef CONFIG_XGW_NMAP
+    nid = nmap[nid];
+#endif
+
+    ASSERT(nid < NODES_N);
+
+    if (nid == nodeSelf)
+        // CANNOT SEND TO ITSELF
+        ret_dev(DSTATS_O_DATA_TO_SELF);
+
+    // TODO: CONTINUAR RECEBENDO PACOTES DE CONTROLE/PING/PONG MESMO COM A INTERFACE DESATIVADA
+    //        DAI SERA INTERESSANTE UMA FLAG GLOBAL XGW ON / OFF, NO MESMO ESQUEMA QUE O NODE->ON & PATH->ON
+
+    // IDENTIFIED THE NODE
+    // TODO: IF THE NODE IS NOT AVAILABLE, SEND IT TO ANOTHER ONE
+    //     -- WILL NEED TO REPORT THE NODES WE CAN REACH IN THE PING, WITH A BIT MAP: 1024*8 = 8192 NODES
+    //     -- WILL NEED SOME KIND OF TTL -> junto com o xPath, o xTTL
+    //            e ai se o xttl for != 0, intepreta, desconta um, e manda ele (nao vai poder desencriptar)
+    node_s* const node = nodes_get_unlocked(nid);
+
+    if (node == NULL)
+        ret_node(NSTATS_O_DATA_INEXIST);
+
+    if (node_is_off(node))
+        ret_node(NSTATS_O_DATA_DISABLED);
+
+    if (node->mtu < size)
+        ret_node(NSTATS_O_DATA_MTU_EXCEEDED);
+
+    const u64 opaths = atomic_get(&node->opaths);
+
+    if (!opaths)
+        ret_node(NSTATS_O_DATA_NO_PATH);
+
+    // CHOOSE CONN
+    cid += cid >> 32;
+    cid += cid >> 16;
+    cid %= node->connsN;
+
+    u64* const conn = &node->conns[cid];
+
+    const u64 _now = get_current_ms();
+
+    ASSERT(_now >= RTIME_MIN);
+    ASSERT(_now <= RTIME_MAX);
+
+    // LOAD STREAM TIMEOUT + PID
+    const u64 burst = atomic_get(conn);
+
+    // CHOOSE A PATH
+    // STARTING FROM CURRENT, BUT CHANGE IF IDLE
+    const uint pid0 = (burst + ((burst >> 5) < _now)) % PATHS_N;
+    // NOTE: NO CASO DE OPATHS SER 0, ESTE VALOR FINAL SERIA UNSPECIFIED
+    // NOTE: O ULTIMO GRUPO TEM QUE SER REPETIDO
+    const uint pid = __ctz((opaths >> pid0) << pid0) % PATHS_N;
+
+    ASSERT(opaths & OPATH(pid));
+
+    path_s* const path = &node->paths[pid];
+
+    // STORE STREAM TIMEOUT + PID
+    // CONSIDERAR O TEMPO DE IDA + CPU BUSY TIME + IMPRECISOES
+    atomic_set(conn, ((_now + (atomic_get(&path->rtt) * 3) / 4) << 5) | pid); // olatency
+
+#if 1
+    if (skb->ip_summed == CHECKSUM_PARTIAL)
+        if (skb_checksum_help(skb))
+            ret_path(PSTATS_O_DATA_CKSUM_FAILED);
+#endif
+
+    // NOTE: THIS STAT WILL ONLY HAPPEN ON DATA, NOT ON PING/PONG
+    if ((PTR(p) - (path->skel.hsize + PKT_ALIGN_SIZE)) < SKB_HEAD(skb))
+        ret_path(PSTATS_O_DATA_NO_HEADROOM);
+
+    pkt_encapsulate(node, atomic_get(&node->oIndex), RTIME(path->mask + _now, atomic_get(&path->tdiff)), &path->skel, skb, p, size);
+
+    // -- THE FUNCTION CAN BE CALLED FROM AN INTERRUPT
+    // -- WHEN CALLING THIS METHOD, INTERRUPTS MUST BE ENABLED
+    dev_queue_xmit(skb);
+    // -- REGARDLESS OF THE RETURN VALUE, THE SKB IS CONSUMED
+
+    stat = PSTATS_O_DATA_OK;
+
+_ret_path: _stat = path->stats; goto _ret;
+_ret_node: _stat = nstats[nid]; goto _ret;
+_ret_dev:  _stat = dstats;
+_ret:
+
+    stat_inc_count(&_stat[stat].count);
+    stat_inc_bytes(&_stat[stat].bytes, skb->len);
+
+    if (stat != PSTATS_O_DATA_OK)
+        dev_kfree_skb(skb);
+
+    return NETDEV_TX_OK;
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/ping.c linux-master/drivers/net/xgw/ping.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/ping.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/ping.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,65 @@
+
+static inline void ping_receive (node_s* const node, const ping_s* const ping) {
+
+    u64 K[K_LEN];
+
+    // LEARN HIS INPUT KEYS (MY OUTPUT KEYS)
+    const uint ver = BE8(ping->ver);
+
+    ASSERT(ver < I_KEYS_DYNAMIC);
+
+    secret_derivate_random_as_key(node->secret, ping->rnd, K);
+
+    // FAZ ISSO PRIMEIRO ANTES DE LIBERAR O PATH PARA ENVIAR
+    const uint o = __atomic_add_fetch(&node->oCycle, 1, __ATOMIC_ACQUIRE) % O_KEYS_DYNAMIC;
+                                       node->oVersions[o] = ver;
+                                memcpy(node->oKeys[o], K, sizeof(K));
+                     __atomic_store_n(&node->oIndex, o,  __ATOMIC_RELEASE);
+}
+
+static void ping_send (node_s* const node, path_s* const path, const pkt_s* const skel, const u64 now, const u64 rtime, const uint o) {
+
+    uint stat;
+
+    skb_s* const skb = alloc_skb(64 + PKT_SIZE + PKT_ALIGN_SIZE + PING_SIZE + 64, GFP_ATOMIC);
+
+    if (skb) {
+
+        // TODO: USA O SKB_DATA ALIGNED
+        ping_s* const ping = SKB_DATA(skb) + 64 + PKT_SIZE + PKT_ALIGN_SIZE;
+
+        // GERA AS KEYS
+        random64_n(PTR(ping), PING_RANDOMS_N, SUFFIX_ULL(CONFIG_XGW_RANDOM_PING));
+
+        ping->time = BE64(now);
+
+        if (o != O_KEY_SYN) {
+
+            // A CADA PING/PONG O SLOT MAIS ANTIGO É RECICLADO.
+            // ENTÃO AS KEYS MAIS ANTIGAS SÃO AUTOMATICAMENTE DESCARTADAS.
+            // OVERFLOWS SERAO PROBLEMAS, ENTAO TEM QUE USAR PALAVRA GRANDE.
+            const uint i = __atomic_add_fetch(&node->iCycle, 1, __ATOMIC_RELAXED) % I_KEYS_DYNAMIC;
+
+            ping->ver = BE8(i); // OVERWRITE WITH THE VERSION
+
+            // SEM ATOMICITY/BARRIER POIS ESTA USANDO UMA KEY JA EXPIRADA
+            secret_derivate_random_as_key(node->secret, ping->rnd, node->iKeys[i]);
+        }
+
+        pkt_encapsulate(node, o, rtime, skel, skb, ping, PING_SIZE);
+
+        skb->ip_summed = CHECKSUM_NONE;
+
+        if (dev_queue_xmit(skb))
+            // FAILED TO SEND THE SKB
+            // NOTE: THE SKB WAS ALREADY CONSUMED
+            stat = PSTATS_O_PING_SEND_FAILED;
+        else
+            stat = PSTATS_O_PING_OK;
+    } else // FAILED TO ALLOCATE SKB
+        stat = PSTATS_O_PING_SKB_FAILED;
+
+    // NOTE: WE WILL INFORM THE TOTAL SIZE SENT THROUGHT THE PHYSICAL INTERFACE
+    stat_inc_bytes(&path->stats[stat].bytes, skel->hsize + PKT_ALIGN_SIZE + PING_SIZE);
+    stat_inc_count(&path->stats[stat].count);
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/ping.h linux-master/drivers/net/xgw/ping.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/ping.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/ping.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,15 @@
+
+// KEYS                     SENDER'S IKEYS BEING TAUGHT (UNDEFINED ON PONG)
+// RANDOM | VER             SENDER'S IKEYS INDEX BEING REGISTERED (UNDEFINED ON PONG)
+// TIME                     SENDER'S TIME (RAW)
+#define PING_SIZE 80
+
+// KEYS, VERSION
+#define PING_RANDOMS_N 9
+
+struct ping_s {
+    u64 rnd [K_LEN];
+    u8 _[7];
+    u8 ver;
+    u64 time;
+};
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/pkt_encap.c linux-master/drivers/net/xgw/pkt_encap.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/pkt_encap.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/pkt_encap.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,220 @@
+
+// NOTE: ASSUME NO IPV4 OPTIONS
+// ip: IP PACKET
+// size: IP SIZE
+static inline u16 tcp_checksum4 (const void* ip, uint size) {
+
+    ASSERT(size >= offsetof(ip4_s, sport));
+
+    uint sum = IPPROTO_TCP + size - IP4_SIZE;
+
+    size -= offsetof(ip4_s, saddr);
+    ip   += offsetof(ip4_s, saddr);
+
+    do {
+        sum += BE16(*(u16*)ip);
+                           ip += sizeof(u16);
+    } while ((size -= sizeof(u16))
+                   >= sizeof(u16));
+
+    if (size)
+        sum += *(u8*)ip << 8;
+
+    sum +=  sum >> 16;
+    sum  = ~sum;
+    sum &= 0xFFFFU;
+
+    return sum;
+}
+
+// NOTE: ASSUME NO IPV6 OPTIONS
+static inline u16 tcp_checksum6 (const void* ip, uint size) {
+
+    ASSERT(size >= (IP6_SIZE + TCP_SIZE));
+    ASSERT((ip + IP6_SIZE) == &((ip6_s*)ip)->sport);
+
+    uint sum = IPPROTO_TCP + size - IP6_SIZE;
+
+    size -= offsetof(ip6_s, saddr);
+    ip   += offsetof(ip6_s, saddr);
+
+    do {
+        sum += BE16(*(u16*)ip);
+                           ip += sizeof(u16);
+    } while ((size -= sizeof(u16))
+                   >= sizeof(u16));
+
+    if (size)
+        sum += *(u8*)ip << 8;
+
+    sum +=  sum >> 16;
+    sum  = ~sum;
+    sum &= 0xFFFFU;
+
+    return sum;
+}
+
+// TODO:
+static inline u16 udp_checksum6 (const void* ip, uint size) {
+
+    return 0;
+}
+
+// MUST BE SMALL AND FAST
+// TODO: AQUI ENCRIPTA E NAO RETORNA NADA xD
+// TODO: SE ESSA PORRA COMPUTAR CHECKSUM TCP/UDP,
+// ENTAO VAI TER QUE SER DEPOIS DE ENCRYPTAR
+static void pkt_encapsulate (const node_s* const node, const uint o, const u64 rtime, const pkt_s* const skel, skb_s* const skb, void* const restrict orig, const uint size) {
+
+    ASSERT(size >= XGW_PAYLOAD_MIN);
+    ASSERT(size <= XGW_PAYLOAD_MAX);
+
+    pkt_s* const pkt = orig - (PKT_SIZE + PKT_ALIGN_SIZE);
+
+    ASSERT(skel->x.src  == BE16(nodeSelf));
+    ASSERT(skel->x.dst  == BE16(node->nid));
+    ASSERT(skel->phys);
+
+    ASSERT((skel->moffset + skel->msize) == skel->noffset);
+    ASSERT((skel->moffset + skel->hsize) == sizeof(pkt_s));
+
+    ASSERT(skel->moffset >= 0);
+    ASSERT(skel->noffset >= skel->moffset);
+    ASSERT(skel->Noffset >= skel->noffset);
+    ASSERT(skel->toffset >= skel->Noffset);
+    ASSERT(skel->toffset <= offsetof(pkt_s, x));
+
+    // INSERT OUR HEADER
+    memcpy(PTR(pkt) + skel->moffset, PTR(skel) + skel->moffset, skel->hsize);
+
+    skb->len       = pkt->hsize + PKT_ALIGN_SIZE + size; // TODO: COLOCAR ESSE U64 NOS HSIZES DOS MODELS, E RETIRAR DAQUI
+    skb->dev       = pkt->phys;
+    skb->mac_len   = pkt->msize;
+    skb->protocol  = pkt->protocol;
+    // NOTE: ISSO AQUI NO PING/PONG
+ // skb->ip_summed = CHECKSUM_NONE;
+
+    // NOTE: pkt->[mnt]offset NUNCA PODE COMECAR EM 0 POIS O COMECINHO É O RESERVADO
+    skb->data = PTR(pkt) + pkt->moffset;
+
+    // skb_set_mac_header / skb_reset_mac_header
+    // skb_set_network_header / skb_reset_network_header
+    // SE NAO FOR TER MAC HEADER, ENTAO ESTEMAC_HEADER TEM QUE TERINAR APONTANDO PRO MESMO QUE O DATA
+    // OU SEJA, BASTA QUE O PKT->MOFFSET SEJA IGAL AO QUE APONTA PRO INICIO DO ENCAPSULAMENTO
+    // NOTE: WE NEED TO SET TAIL ALSO, BECAUSE WE ARE ALSO CREATING PACKETS FOR PING/PONG
+#ifdef NET_SKBUFF_DATA_USES_OFFSET
+    skb->mac_header       = (PTR(pkt) + pkt->moffset) - SKB_HEAD(skb);
+    skb->network_header   = (PTR(pkt) + pkt->noffset) - SKB_HEAD(skb);
+    skb->transport_header = (PTR(pkt) + pkt->toffset) - SKB_HEAD(skb);
+    skb->tail             = (PTR(pkt) + PKT_SIZE + PKT_ALIGN_SIZE + size) - SKB_HEAD(skb);
+#else
+    skb->mac_header       =  PTR(pkt) + pkt->moffset;
+    skb->network_header   =  PTR(pkt) + pkt->noffset; // TODO: TEM QUE SER O VLAN???
+    skb->transport_header =  PTR(pkt) + pkt->toffset;
+    skb->tail             = (PTR(pkt) + PKT_SIZE + PKT_ALIGN_SIZE + size);
+#endif
+
+    ASSERT(SKB_DATA(skb) >= SKB_HEAD(skb));
+    ASSERT(SKB_DATA(skb) <  SKB_TAIL(skb));
+
+    ASSERT(SKB_HEAD(skb) <= PTR(pkt));
+    ASSERT(SKB_DATA(skb) >= PTR(pkt)); // O DATA É UM DESTES: MAC/NETWORK/TRANSPORT/&PKT->X
+
+    ASSERT((SKB_TAIL(skb) - SKB_DATA(skb)) == skb->len);
+
+    ASSERT(SKB_MAC      (skb) == (PTR(pkt) + pkt->moffset));
+    ASSERT(SKB_NETWORK  (skb) == (PTR(pkt) + pkt->noffset));
+    ASSERT(SKB_TRANSPORT(skb) == (PTR(pkt) + pkt->toffset));
+
+    //
+    random64_n(pkt->p, PKT_ALIGN_WORDS, SUFFIX_ULL(CONFIG_XGW_RANDOM_ENCRYPT_ALIGN));
+
+    // READ BEFORE OVERWRITING IT
+    const uint type = pkt->type;
+
+    //
+    pkt->x.dsize   = BE16(size);
+    pkt->x.version = BE8(node->oVersions[o]);
+    pkt->x.time    = BE64(rtime);
+    pkt->x.hash    = BE64(pkt_encrypt(node, o, pkt, size));
+
+    switch (type) {
+
+        case H_TYPE_ETH_PPP_IP4:
+        case H_TYPE_ETH_VLAN_PPP_IP4:
+
+            pkt->encap_eth_ppp_ip4.ppp.size = BE16(PKT_X_SIZE + PKT_ALIGN_SIZE + size + sizeof(hdr_ip4_s) + sizeof(u16));
+
+            fallthrough;
+        case H_TYPE_IP4:
+        case H_TYPE_ETH_IP4:
+        case H_TYPE_ETH_VLAN_IP4:
+
+     ASSERT(pkt->encap_eth_ppp_ip4.ip4.cksum == 0);
+            pkt->encap_eth_ppp_ip4.ip4.size  = BE16(PKT_X_SIZE + PKT_ALIGN_SIZE + size + sizeof(hdr_ip4_s));
+            pkt->encap_eth_ppp_ip4.ip4.cksum = ip_fast_csum(&pkt->encap_ip4.ip4, 5);
+
+            break;
+
+        case H_TYPE_ETH_PPP_IP6:
+        case H_TYPE_ETH_VLAN_PPP_IP6:
+
+            pkt->encap_eth_ppp_ip6.ppp.size = BE16(PKT_X_SIZE + PKT_ALIGN_SIZE + size + sizeof(hdr_ip6_s) + sizeof(u16));
+
+            fallthrough;
+        case H_TYPE_IP6:
+        case H_TYPE_ETH_IP6:
+        case H_TYPE_ETH_VLAN_IP6:
+
+            pkt->encap_eth_ppp_ip6.ip6.size = BE16(PKT_X_SIZE + PKT_ALIGN_SIZE + size);
+
+            break;
+
+        case H_TYPE_IP4_UDP:
+        case H_TYPE_ETH_IP4_UDP:
+        case H_TYPE_ETH_VLAN_IP4_UDP:
+
+     ASSERT(pkt->encap_ip4_udp.udp.cksum == 0);
+     ASSERT(pkt->encap_ip4_udp.ip4.cksum == 0);
+            pkt->encap_ip4_udp.udp.size  = BE16(PKT_X_SIZE + PKT_ALIGN_SIZE + size + sizeof(hdr_udp_s));
+            pkt->encap_ip4_udp.ip4.size  = BE16(PKT_X_SIZE + PKT_ALIGN_SIZE + size + sizeof(hdr_udp_s) + sizeof(hdr_ip4_s));
+            pkt->encap_ip4_udp.ip4.cksum = ip_fast_csum(&pkt->encap_ip4_udp.ip4, 5);
+
+            break;
+
+        case H_TYPE_IP6_UDP:
+        case H_TYPE_ETH_IP6_UDP: // TODO: O IPV6 OBRIGA UDP CHECKSUM. ESTA DEIXANDO O ZERO AQUI, MAS DEVERA COMPUTAR DEPOIS
+        case H_TYPE_ETH_VLAN_IP6_UDP:
+
+     ASSERT(pkt->encap_ip6_udp.udp.cksum == 0);
+            pkt->encap_ip6_udp.udp.size = BE16(PKT_X_SIZE + PKT_ALIGN_SIZE + size + sizeof(hdr_udp_s));
+            pkt->encap_ip6_udp.ip6.size = BE16(PKT_X_SIZE + PKT_ALIGN_SIZE + size + sizeof(hdr_udp_s));
+
+            break;
+
+        case H_TYPE_ETH_PPP:
+        case H_TYPE_ETH_VLAN_PPP:
+
+            pkt->encap_eth_ppp.ppp.size = BE16(PKT_X_SIZE + PKT_ALIGN_SIZE + size + 2);
+
+            break;
+
+        case H_TYPE_IP4_TCP:
+        case H_TYPE_ETH_IP4_TCP:
+        case H_TYPE_ETH_VLAN_IP4_TCP:
+
+            break;
+
+        case H_TYPE_IP6_TCP:
+        case H_TYPE_ETH_IP6_TCP:
+        case H_TYPE_ETH_VLAN_IP6_TCP:
+
+            break;
+
+        case H_TYPE_RAW:
+        case H_TYPE_ETH:
+        case H_TYPE_ETH_VLAN:
+            //
+            break;
+    }
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/pkt.h linux-master/drivers/net/xgw/pkt.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/pkt.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/pkt.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,322 @@
+
+// É ISSO QUE TEM QUE SER RETIRADO DO MTU DA INTERFACE XGW
+// (E TAMBEM OS DEMAIS ENCAPSULAMENTOS DO PHYS)
+#define XGW_MTU_OVERHEAD 40
+
+#define PKT_X_SIZE 24
+
+#define PKT_ALIGN_SIZE  16
+#define PKT_ALIGN_WORDS 2
+
+#define XGW_PAYLOAD_MIN     28 // AN EMPTY IPV4/UDP
+#define XGW_PAYLOAD_MAX 0xFFFF // MUST FIT ON PKT->SIZE
+// TODO: XGW_PAYLOAD_MAX TEM QUE SER 65536, E PKT->DSIZE ENCODED COM -1 E DECODED COM +1
+
+#define PKT_DATA(pkt) PTR((pkt)->p + PKT_ALIGN_WORDS)
+
+//
+#define TOS_MAX 0xFF
+
+//
+#define TTL_MIN 0x01
+#define TTL_MAX 0xFF
+
+// TODO:
+#define IPPROTO_XGW 0x99
+
+// TODO:
+#define ETH_P_XGW 0x2562
+
+// HEADERS
+struct hdr_eth_s {
+    u8  dmac [ETH_ALEN];
+    u8  smac [ETH_ALEN];
+    u16 proto;
+};
+
+struct hdr_vlan_s {
+    u16 id;
+    u16 proto;
+};
+
+struct hdr_ppp_s {
+    u16 code; // VERSION (0x1) | TYPE (0x1) | CODE (0x00) -> 0x1100
+    u16 session;
+    u16 size; // IP SIZE + 2
+    u16 proto;
+};
+
+struct hdr_ip4_s {
+    u8  version;
+    u8  tos;
+    u16 size;
+    u16 id;
+    u16 frag;
+    u8  ttl;
+    u8  proto;
+    u16 cksum;
+    u8  saddr [4];
+    u8  daddr [4];
+};
+
+struct hdr_ip6_s {
+    u8  version;
+    u8  tos; // TODO: O IPV6 TOS TEM QUE SER UM BITFIELD
+    u16 flow;
+    u16 size;
+    u8  proto;
+    u8  ttl;
+    u16 saddr [8];
+    u16 daddr [8];
+};
+
+struct hdr_tcp_s {
+    u16 sport;
+    u16 dport;
+    u32 seq;
+    u32 ack;
+    u16 flags;
+    u16 window;
+    u16 cksum;
+    u16 urg;
+} ;
+
+struct hdr_udp_s {
+    u16 sport;
+    u16 dport;
+    u16 size;
+    u16 cksum;
+};
+
+struct hdr_x_s { // WIRE
+    union {
+        struct {
+            u16 src;
+            u16 dst;
+            u8  path; // BEM NO MEIO PARA PROTEGE-LO NO HASHING
+            u8  version;
+            u16 dsize; // SIZE OF THE PAYLOAD (WIRE) OR HEADER (RUNTIME)
+        };  u64 info;
+    };
+    u64 time; // DESTINATION'S TIME (NO CASO DO PONG, O PKT->TIME É O RAW PING->RTIME SENDO RESPONDIDO)
+    u64 hash;
+};
+
+// PAYLOAD
+// PURPOSE: READ VERSION, SIZE, NAT, COMPUTE CHECKSUMS
+
+struct __packed ip4_s {
+    u8  version;
+    u8  tos;
+    u16 size;
+    u16 id;
+    u16 frag;
+    u8  ttl;
+    u8  proto;
+    u16 cksum;
+    u32 saddr;
+    u32 daddr;
+    u16 sport;
+    u16 dport;
+};
+
+struct __packed ip6_s {
+    u32 flow;
+    u16 size; // MAS É SO DO PAYLOAD
+    u8  proto;
+    u8  ttl;
+    u64 saddr [2];
+    u64 daddr [2];
+    u16 sport;
+    u16 dport;
+};
+
+// MAXIMUM SIZE
+// (? + ETH + VLAN + PPPOE + IP6 + TCP)
+// (2 + 14  + 4    + 8     + 40  + 20 )
+#define ENCAP_SIZE 88
+
+// ENCAP_SIZE + sizeof(hdr_x_s)
+#define PKT_SIZE 112
+
+#define __ETH  (1 << 0)
+#define __VLAN (1 << 1)
+#define __IP4  (1 << 2)
+#define __IP6  (1 << 3)
+#define __TCP  (1 << 4)
+#define __UDP  (1 << 5)
+
+#define __PPP  (1 << 6)
+
+#define H_TYPES_N (1 << 7)
+
+enum H_TYPE {
+    H_TYPE_RAW              = 0,
+    H_TYPE_IP4              = __IP4,
+    H_TYPE_IP4_UDP          = __IP4  | __UDP,
+    H_TYPE_IP4_TCP          = __IP4  | __TCP,
+    H_TYPE_IP6              = __IP6,
+    H_TYPE_IP6_UDP          = __IP6  | __UDP,
+    H_TYPE_IP6_TCP          = __IP6  | __TCP,
+    H_TYPE_ETH              = __ETH,
+    H_TYPE_ETH_IP4          = __ETH  | __IP4,
+    H_TYPE_ETH_IP4_UDP      = __ETH  | __IP4   | __UDP,
+    H_TYPE_ETH_IP4_TCP      = __ETH  | __IP4   | __TCP,
+    H_TYPE_ETH_IP6          = __ETH  | __IP6,
+    H_TYPE_ETH_IP6_UDP      = __ETH  | __IP6   | __UDP,
+    H_TYPE_ETH_IP6_TCP      = __ETH  | __IP6   | __TCP,
+    H_TYPE_ETH_VLAN         = __ETH  | __VLAN,
+    H_TYPE_ETH_VLAN_IP4     = __ETH  | __VLAN  | __IP4,
+    H_TYPE_ETH_VLAN_IP4_UDP = __ETH  | __VLAN  | __IP4  | __UDP,
+    H_TYPE_ETH_VLAN_IP4_TCP = __ETH  | __VLAN  | __IP4  | __TCP,
+    H_TYPE_ETH_VLAN_IP6     = __ETH  | __VLAN  | __IP6,
+    H_TYPE_ETH_VLAN_IP6_UDP = __ETH  | __VLAN  | __IP6  | __UDP,
+    H_TYPE_ETH_VLAN_IP6_TCP = __ETH  | __VLAN  | __IP6  | __TCP,
+    H_TYPE_ETH_VLAN_PPP     = __ETH  | __VLAN  | __PPP,
+    H_TYPE_ETH_VLAN_PPP_IP4 = __ETH  | __VLAN  | __PPP  | __IP4,
+    H_TYPE_ETH_VLAN_PPP_IP6 = __ETH  | __VLAN  | __PPP  | __IP6,
+    H_TYPE_ETH_PPP          = __ETH  | __PPP,
+    H_TYPE_ETH_PPP_IP4      = __ETH  | __PPP   | __IP4,
+    H_TYPE_ETH_PPP_IP6      = __ETH  | __PPP   | __IP6,
+};
+
+// THE SIZE OF THE HEADERS
+enum H_SIZE {
+    H_SIZE_RAW              = sizeof(hdr_x_s),
+    H_SIZE_IP4              = sizeof(hdr_x_s)  + sizeof(hdr_ip4_s),
+    H_SIZE_IP4_UDP          = sizeof(hdr_x_s)  + sizeof(hdr_ip4_s)  + sizeof(hdr_udp_s),
+    H_SIZE_IP4_TCP          = sizeof(hdr_x_s)  + sizeof(hdr_ip4_s)  + sizeof(hdr_tcp_s),
+    H_SIZE_IP6              = sizeof(hdr_x_s)  + sizeof(hdr_ip6_s),
+    H_SIZE_IP6_UDP          = sizeof(hdr_x_s)  + sizeof(hdr_ip6_s)  + sizeof(hdr_udp_s),
+    H_SIZE_IP6_TCP          = sizeof(hdr_x_s)  + sizeof(hdr_ip6_s)  + sizeof(hdr_tcp_s),
+    H_SIZE_ETH              = sizeof(hdr_x_s)  + sizeof(hdr_eth_s),
+    H_SIZE_ETH_IP4          = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ip4_s),
+    H_SIZE_ETH_IP4_UDP      = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ip4_s)   + sizeof(hdr_udp_s),
+    H_SIZE_ETH_IP4_TCP      = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ip4_s)   + sizeof(hdr_tcp_s),
+    H_SIZE_ETH_IP6          = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ip6_s),
+    H_SIZE_ETH_IP6_UDP      = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ip6_s)   + sizeof(hdr_udp_s),
+    H_SIZE_ETH_IP6_TCP      = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ip6_s)   + sizeof(hdr_tcp_s),
+    H_SIZE_ETH_VLAN         = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_vlan_s),
+    H_SIZE_ETH_VLAN_IP4     = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_vlan_s)  + sizeof(hdr_ip4_s),
+    H_SIZE_ETH_VLAN_IP4_UDP = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_vlan_s)  + sizeof(hdr_ip4_s)   + sizeof(hdr_udp_s),
+    H_SIZE_ETH_VLAN_IP4_TCP = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_vlan_s)  + sizeof(hdr_ip4_s)   + sizeof(hdr_tcp_s),
+    H_SIZE_ETH_VLAN_IP6     = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_vlan_s)  + sizeof(hdr_ip6_s),
+    H_SIZE_ETH_VLAN_IP6_UDP = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_vlan_s)  + sizeof(hdr_ip6_s)   + sizeof(hdr_udp_s),
+    H_SIZE_ETH_VLAN_IP6_TCP = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_vlan_s)  + sizeof(hdr_ip6_s)   + sizeof(hdr_tcp_s),
+    H_SIZE_ETH_VLAN_PPP     = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ppp_s)   + sizeof(hdr_vlan_s),
+    H_SIZE_ETH_VLAN_PPP_IP4 = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ppp_s)   + sizeof(hdr_vlan_s)  + sizeof(hdr_ip4_s),
+    H_SIZE_ETH_VLAN_PPP_IP6 = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ppp_s)   + sizeof(hdr_vlan_s)  + sizeof(hdr_ip6_s),
+    H_SIZE_ETH_PPP          = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ppp_s),
+    H_SIZE_ETH_PPP_IP4      = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ppp_s)   + sizeof(hdr_ip4_s),
+    H_SIZE_ETH_PPP_IP6      = sizeof(hdr_x_s)  + sizeof(hdr_eth_s)  + sizeof(hdr_ppp_s)   + sizeof(hdr_ip6_s),
+};
+
+// THE OFFSET FROM THE PKT TO THE HEADERS
+enum H_OFFSET {
+    H_OFFSET_RAW              = PKT_SIZE - H_SIZE_RAW,
+    H_OFFSET_ETH              = PKT_SIZE - H_SIZE_ETH,
+    H_OFFSET_ETH_IP4          = PKT_SIZE - H_SIZE_ETH_IP4,
+    H_OFFSET_ETH_IP6          = PKT_SIZE - H_SIZE_ETH_IP6,
+    H_OFFSET_ETH_IP4_UDP      = PKT_SIZE - H_SIZE_ETH_IP4_UDP,
+    H_OFFSET_ETH_IP6_UDP      = PKT_SIZE - H_SIZE_ETH_IP6_UDP,
+    H_OFFSET_ETH_VLAN         = PKT_SIZE - H_SIZE_ETH_VLAN,
+    H_OFFSET_ETH_VLAN_IP4     = PKT_SIZE - H_SIZE_ETH_VLAN_IP4,
+    H_OFFSET_ETH_VLAN_IP6     = PKT_SIZE - H_SIZE_ETH_VLAN_IP6,
+    H_OFFSET_ETH_VLAN_IP4_UDP = PKT_SIZE - H_SIZE_ETH_VLAN_IP4_UDP,
+    H_OFFSET_ETH_VLAN_IP6_UDP = PKT_SIZE - H_SIZE_ETH_VLAN_IP6_UDP,
+    H_OFFSET_ETH_VLAN_PPP     = PKT_SIZE - H_SIZE_ETH_VLAN_PPP,
+    H_OFFSET_ETH_VLAN_PPP_IP4 = PKT_SIZE - H_SIZE_ETH_VLAN_PPP_IP4,
+    H_OFFSET_ETH_VLAN_PPP_IP6 = PKT_SIZE - H_SIZE_ETH_VLAN_PPP_IP6,
+    H_OFFSET_ETH_PPP          = PKT_SIZE - H_SIZE_ETH_PPP,
+    H_OFFSET_ETH_PPP_IP4      = PKT_SIZE - H_SIZE_ETH_PPP_IP4,
+    H_OFFSET_ETH_PPP_IP6      = PKT_SIZE - H_SIZE_ETH_PPP_IP6,
+    H_OFFSET_IP4              = PKT_SIZE - H_SIZE_IP4,
+    H_OFFSET_IP6              = PKT_SIZE - H_SIZE_IP6,
+    H_OFFSET_IP4_UDP          = PKT_SIZE - H_SIZE_IP4_UDP,
+    H_OFFSET_IP4_TCP          = PKT_SIZE - H_SIZE_IP4_TCP,
+    H_OFFSET_IP6_UDP          = PKT_SIZE - H_SIZE_IP6_UDP,
+    H_OFFSET_IP6_TCP          = PKT_SIZE - H_SIZE_IP6_TCP,
+};
+
+// NOTE: ESSA PORRA DESSE ALINHAMENTO NAO ESTA DEIXANDO OS 64-BIT WORDS ALINHADOS PARA PROCESSARMOS
+#define XGW_HEADROOM (sizeof(pkt_s) + (PKT_ALIGN_WORDS * sizeof(u64)))
+
+// ESTAMOS PEGANDO TODOS OS ENCAPSULAMENTOS QUE O SISTEMA JA USA, E AUMENTANDO ISSO:
+//  PAD_NO_ENCAP + sizeof(hdr_x_s) + PKT_ALIGN_WORDS*sizeof(u64)
+// PORTANTO:
+//      32 + sizeof(hdr_x_s) + PKT_ALIGN_WORDS*sizeof(u64) = 64
+// DEVERA INFLUENCIAR:
+//  -   LL_MAX_HEADER
+//  -   MAX_HEADER
+// DEFINIDO EM:
+//      include/linux/netdevice.h
+//BUILD_ASSERT(XGW_HEADROOM_OVERHEAD == (32 + sizeof(hdr_x_s) + sizeof(u64)));
+
+BUILD_ASSERT(LL_MAX_HEADER == 196 );
+BUILD_ASSERT(MAX_HEADER == (196 + 48));
+
+// JA O MTU, INFLUENCIA
+// sizeof(hdr_x_s) + PKT_ALIGN_WORDS*sizeof(u64) = 40
+
+#define __
+
+// TODO: __packed? ARM?
+struct pkt_s {
+    union { // ENCAP
+                                  char encap_raw [H_OFFSET_RAW              ];
+        struct encap_eth_s              { char _ [H_OFFSET_ETH              ]; hdr_eth_s eth; __         __    __        __   __        __   __        __   } encap_eth;
+        struct encap_eth_ip4_s          { char _ [H_OFFSET_ETH_IP4          ]; hdr_eth_s eth; __         __    __        __   hdr_ip4_s ip4; __        __   } encap_eth_ip4;
+        struct encap_eth_ip6_s          { char _ [H_OFFSET_ETH_IP6          ]; hdr_eth_s eth; __         __    __        __   hdr_ip6_s ip6; __        __   } encap_eth_ip6;
+        struct encap_eth_ip4_udp_s      { char _ [H_OFFSET_ETH_IP4_UDP      ]; hdr_eth_s eth; __         __    __        __   hdr_ip4_s ip4; hdr_udp_s udp; } encap_eth_ip4_udp;
+        struct encap_eth_ip6_udp_s      { char _ [H_OFFSET_ETH_IP6_UDP      ]; hdr_eth_s eth; __         __    __        __   hdr_ip6_s ip6; hdr_udp_s udp; } encap_eth_ip6_udp;
+        struct encap_eth_vlan_s         { char _ [H_OFFSET_ETH_VLAN         ]; hdr_eth_s eth; hdr_vlan_s vlan; __        __   __        __   __        __   } encap_eth_vlan;
+        struct encap_eth_vlan_ip4_s     { char _ [H_OFFSET_ETH_VLAN_IP4     ]; hdr_eth_s eth; hdr_vlan_s vlan; __        __   hdr_ip4_s ip4; __        __   } encap_eth_vlan_ip4;
+        struct encap_eth_vlan_ip6_s     { char _ [H_OFFSET_ETH_VLAN_IP6     ]; hdr_eth_s eth; hdr_vlan_s vlan; __        __   hdr_ip6_s ip6; __        __   } encap_eth_vlan_ip6;
+        struct encap_eth_vlan_ip4_udp_s { char _ [H_OFFSET_ETH_VLAN_IP4_UDP ]; hdr_eth_s eth; hdr_vlan_s vlan; __        __   hdr_ip4_s ip4; hdr_udp_s udp; } encap_eth_vlan_ip4_udp;
+        struct encap_eth_vlan_ip6_udp_s { char _ [H_OFFSET_ETH_VLAN_IP6_UDP ]; hdr_eth_s eth; hdr_vlan_s vlan; __        __   hdr_ip6_s ip6; hdr_udp_s udp; } encap_eth_vlan_ip6_udp;
+        struct encap_eth_vlan_ppp_s     { char _ [H_OFFSET_ETH_VLAN_PPP     ]; hdr_eth_s eth; hdr_vlan_s vlan; hdr_ppp_s ppp; __        __   __        __   } encap_eth_vlan_ppp;
+        struct encap_eth_vlan_ppp_ip4_s { char _ [H_OFFSET_ETH_VLAN_PPP_IP4 ]; hdr_eth_s eth; hdr_vlan_s vlan; hdr_ppp_s ppp; hdr_ip4_s ip4; __        __   } encap_eth_vlan_ppp_ip4;
+        struct encap_eth_vlan_ppp_ip6_s { char _ [H_OFFSET_ETH_VLAN_PPP_IP6 ]; hdr_eth_s eth; hdr_vlan_s vlan; hdr_ppp_s ppp; hdr_ip6_s ip6; __        __   } encap_eth_vlan_ppp_ip6;
+        struct encap_eth_ppp_s          { char _ [H_OFFSET_ETH_PPP          ]; hdr_eth_s eth; __         __    hdr_ppp_s ppp; __        __   __        __   } encap_eth_ppp;
+        struct encap_eth_ppp_ip4_s      { char _ [H_OFFSET_ETH_PPP_IP4      ]; hdr_eth_s eth; __         __    hdr_ppp_s ppp; hdr_ip4_s ip4; __        __   } encap_eth_ppp_ip4;
+        struct encap_eth_ppp_ip6_s      { char _ [H_OFFSET_ETH_PPP_IP6      ]; hdr_eth_s eth; __         __    hdr_ppp_s ppp; hdr_ip6_s ip6; __        __   } encap_eth_ppp_ip6;
+        struct encap_ip4_s              { char _ [H_OFFSET_IP4              ]; __        __   __         __    __        __   hdr_ip4_s ip4; __        __   } encap_ip4;
+        struct encap_ip6_s              { char _ [H_OFFSET_IP6              ]; __        __   __         __    __        __   hdr_ip6_s ip6; __        __   } encap_ip6;
+        struct encap_ip4_udp_s          { char _ [H_OFFSET_IP4_UDP          ]; __        __   __         __    __        __   hdr_ip4_s ip4; hdr_udp_s udp; } encap_ip4_udp;
+        struct encap_ip4_tcp_s          { char _ [H_OFFSET_IP4_TCP          ]; __        __   __         __    __        __   hdr_ip4_s ip4; hdr_tcp_s tcp; } encap_ip4_tcp;
+        struct encap_ip6_udp_s          { char _ [H_OFFSET_IP6_UDP          ]; __        __   __         __    __        __   hdr_ip6_s ip6; hdr_udp_s udp; } encap_ip6_udp;
+        struct encap_ip6_tcp_s          { char _ [H_OFFSET_IP6_TCP          ]; __        __   __         __    __        __   hdr_ip6_s ip6; hdr_tcp_s tcp; } encap_ip6_tcp;
+    };
+    union { // X
+        hdr_x_s x;
+        struct { // RUNTIME
+        // SRC, DST, PATH, VERSION, DSIZE
+            u16 _src;
+            u16 _dst;
+            u8  _path;
+            u8  _reserved;
+            u16 hsize;
+        // TIME
+            net_device_s* phys;
+        // HASH
+            u8 type;
+            u8 msize;          // skb->mac_len
+            u8 moffset;        // PTR(pkt) + path->moffset -> SKB_MAC(skb)
+            u8 Noffset;        // É NECESSARIO POIS QUANTO TEM VLAN O NETWORK OFFSET NAO APONTA PARA O IPV4 :S
+            u8 noffset;        // PTR(pkt) + path->noffset -> SKB_NETWORK(skb)
+            u8 toffset;        // PTR(pkt) + path->toffset -> SKB_TRANSPORT(skb)
+            u16 protocol;      // skb->protocol
+        };
+    };
+    u64 p []; // ALIGN | PING / PONG / PAYLOAD
+};
+
+// TODO: TODOS OS ENCAP_S TEM QUE SER < ENCAP_MAX
+
+#define PKT_ETH(pkt)   ((hdr_eth_s*)(PTR(pkt) + (pkt)->moffset))
+#define PKT_VLAN(pkt) ((hdr_vlan_s*)(PTR(pkt) + (pkt)->noffset))
+#define PKT_PPP(pkt)   ((hdr_ppp_s*)(PTR(pkt) + (pkt)->_reserved))
+#define PKT_IP4(pkt)   ((hdr_ip4_s*)(PTR(pkt) + (pkt)->Noffset))
+#define PKT_IP6(pkt)   ((hdr_ip6_s*)(PTR(pkt) + (pkt)->Noffset))
+#define PKT_UDP(pkt)   ((hdr_udp_s*)(PTR(pkt) + (pkt)->toffset))
+#define PKT_TCP(pkt)   ((hdr_tcp_s*)(PTR(pkt) + (pkt)->toffset))
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/pkt_skels.c linux-master/drivers/net/xgw/pkt_skels.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/pkt_skels.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/pkt_skels.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,622 @@
+
+// TODO: NO CASO DO IP4 (RAW) O TRANSPORTE É O PROPRIO XHEADER
+
+// IFRAG BE16 (0b0100000000000000U)
+
+#define SKEL_IP6_FLOW(node, path) (((node)->nid * PATHS_N) + ((path) - (node)->paths))
+
+static const pkt_s models [H_TYPES_N] = {
+
+    [H_TYPE_ETH] = {
+        .type     = H_TYPE_ETH,
+        .hsize    = H_SIZE_ETH,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_s, eth),
+        .noffset  = offsetof(pkt_s, x),
+        .Noffset  = offsetof(pkt_s, x),
+        .toffset  = offsetof(pkt_s, x),
+        .protocol = BE16(ETH_P_XGW),
+        .encap_eth = {
+            .eth = {
+                .dmac = { 0, 0, 0, 0, 0, 0 },
+                .smac = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(ETH_P_XGW),
+            },
+        }
+    },
+
+    [H_TYPE_ETH_PPP] = {
+        .type     = H_TYPE_ETH_PPP,
+        .hsize    = H_SIZE_ETH_PPP,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_ppp_s, eth),
+        .noffset  = offsetof(encap_eth_ppp_s, ppp),
+        .Noffset  = offsetof(encap_eth_ppp_s, ppp),
+        .toffset  = offsetof(encap_eth_ppp_s, ppp),
+       ._reserved = offsetof(encap_eth_ppp_s, ppp),
+        .protocol = BE16(ETH_P_PPP_SES),
+        .encap_eth_ppp = {
+            .eth = {
+                .dmac = { 0, 0, 0, 0, 0, 0 },
+                .smac = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(ETH_P_PPP_SES), // 0x8864
+            },
+            .ppp = {
+                .code    = BE16(0x1100), // VERSION (0x1) | TYPE (0x1) | CODE (0x00)
+                .session = BE16(0),
+                .size    = BE16(0), // IP SIZE + 2
+                .proto   = BE16(ETH_P_XGW),
+            },
+        }
+    },
+
+    [H_TYPE_ETH_IP4] = {
+        .type     = H_TYPE_ETH_IP4,
+        .hsize    = H_SIZE_ETH_IP4,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_ip4_s, eth),
+        .noffset  = offsetof(encap_eth_ip4_s, ip4),
+        .Noffset  = offsetof(encap_eth_ip4_s, ip4),
+        .toffset  = offsetof(pkt_s, x),
+        .protocol = BE16(ETH_P_IP),
+        .encap_eth_ip4 = {
+            .eth = {
+                .dmac = { 0, 0, 0, 0, 0, 0 },
+                .smac = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(ETH_P_IP),
+            },
+            .ip4 = {
+                .version = BE8(0x45),
+                .tos     = BE8(0),
+                .size    = BE16(0),
+                .id      = BE16(0),
+                .frag    = BE16(0),
+                .ttl     = BE8(0),
+                .proto   = BE8(IPPROTO_XGW),
+                .cksum   = BE16(0),
+                .saddr   = { 0, 0, 0, 0 },
+                .daddr   = { 0, 0, 0, 0 },
+            }
+        }
+    },
+
+    [H_TYPE_ETH_PPP_IP4] = {
+        .type     = H_TYPE_ETH_PPP_IP4,
+        .hsize    = H_SIZE_ETH_PPP_IP4,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_ppp_ip4_s, eth),
+        .noffset  = offsetof(encap_eth_ppp_ip4_s, ppp),
+        .Noffset  = offsetof(encap_eth_ppp_ip4_s, ip4),
+        .toffset  = offsetof(pkt_s, x),
+       ._reserved = offsetof(encap_eth_ppp_ip4_s, ppp),
+        .protocol = BE16(ETH_P_PPP_SES),
+        .encap_eth_ppp_ip4 = {
+            .eth = {
+                .dmac = { 0, 0, 0, 0, 0, 0 },
+                .smac = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(ETH_P_PPP_SES),
+            },
+            .ppp = {
+                .code    = BE16(0x1100),
+                .session = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE16(0x0021), // ETH_P_IP
+            },
+            .ip4 = {
+                .version = BE8(0x45),
+                .tos     = BE8(0),
+                .size    = BE16(0),
+                .id      = BE16(0),
+                .frag    = BE16(0),
+                .ttl     = BE8(0),
+                .proto   = BE8(IPPROTO_XGW),
+                .cksum   = BE16(0),
+                .saddr   = { 0, 0, 0, 0 },
+                .daddr   = { 0, 0, 0, 0 },
+            }
+        }
+    },
+
+    [H_TYPE_ETH_PPP_IP6] = {
+        .type     = H_TYPE_ETH_PPP_IP6,
+        .hsize    = H_SIZE_ETH_PPP_IP6,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_ppp_ip6_s, eth),
+        .noffset  = offsetof(encap_eth_ppp_ip6_s, ip6),
+        .Noffset  = offsetof(encap_eth_ppp_ip6_s, ip6),
+        .toffset  = offsetof(pkt_s, x),
+       ._reserved = offsetof(encap_eth_ppp_ip6_s, ppp),
+        .protocol = BE16(ETH_P_PPP_SES),
+        .encap_eth_ppp_ip6 = {
+            .eth = {
+                .dmac = { 0, 0, 0, 0, 0, 0 },
+                .smac = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(ETH_P_PPP_SES),
+            },
+            .ppp = {
+                .code    = BE16(0x1100),
+                .session = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE16(0x0057), // ETH_P_IPV6
+            },
+            .ip6 = {
+                .version = BE8(0x60),
+                .tos     = BE8(0),
+                .flow    = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE8(IPPROTO_XGW),
+                .ttl     = BE8(0),
+                .saddr   = { 0, 0 },
+                .daddr   = { 0, 0 },
+            }
+        }
+    },
+
+    [H_TYPE_ETH_IP6] = {
+        .type     = H_TYPE_ETH_IP6,
+        .hsize    = H_SIZE_ETH_IP6,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_ip6_s, eth),
+        .noffset  = offsetof(encap_eth_ip6_s, ip6),
+        .Noffset  = offsetof(encap_eth_ip6_s, ip6),
+        .toffset  = offsetof(encap_eth_ip6_s, ip6),
+        .protocol = BE16(ETH_P_IPV6),
+        .encap_eth_ip6 = {
+            .eth = {
+                .dmac  = { 0, 0, 0, 0, 0, 0 },
+                .smac  = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(ETH_P_IPV6),
+            },
+            .ip6 = {
+                .version = BE8(0x60),
+                .tos     = BE8(0),
+                .flow    = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE8(IPPROTO_XGW),
+                .ttl     = BE8(0),
+                .saddr   = { 0, 0 },
+                .daddr   = { 0, 0 },
+            }
+        }
+    },
+
+    [H_TYPE_ETH_IP4_UDP] = {
+        .type     = H_TYPE_ETH_IP4_UDP,
+        .hsize    = H_SIZE_ETH_IP4_UDP,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_ip4_udp_s, eth),
+        .noffset  = offsetof(encap_eth_ip4_udp_s, ip4),
+        .Noffset  = offsetof(encap_eth_ip4_udp_s, ip4),
+        .toffset  = offsetof(encap_eth_ip4_udp_s, udp),
+        .protocol = BE16(ETH_P_IP),
+        .encap_eth_ip4_udp = {
+            .eth = {
+                .dmac = { 0, 0, 0, 0, 0, 0 },
+                .smac = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(ETH_P_IP),
+            },
+            .ip4 = {
+                .version = BE8(0x45),
+                .tos     = BE8(0),
+                .size    = BE16(0),
+                .id      = BE16(0),
+                .frag    = BE16(0),
+                .ttl     = BE8(0),
+                .proto   = BE8(IPPROTO_UDP),
+                .cksum   = BE16(0),
+                .saddr   = { 0, 0, 0, 0 },
+                .daddr   = { 0, 0, 0, 0 },
+            },
+            .udp = {
+                .sport = BE16(0),
+                .dport = BE16(0),
+                .size  = BE16(0),
+                .cksum = BE16(0)
+            }
+        }
+    },
+
+    [H_TYPE_ETH_IP6_UDP] = {
+        .type     = H_TYPE_ETH_IP6_UDP,
+        .hsize    = H_SIZE_ETH_IP6_UDP,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_ip6_udp_s, eth),
+        .noffset  = offsetof(encap_eth_ip6_udp_s, ip6),
+        .Noffset  = offsetof(encap_eth_ip6_udp_s, ip6),
+        .toffset  = offsetof(encap_eth_ip6_udp_s, udp),
+        .protocol = BE16(ETH_P_IPV6),
+        .encap_eth_ip6_udp = {
+            .eth = {
+                .dmac  = { 0, 0, 0, 0, 0, 0 },
+                .smac  = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(ETH_P_IPV6),
+            },
+            .ip6 = {
+                .version = BE8(0x60),
+                .tos     = BE8(0),
+                .flow    = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE8(IPPROTO_UDP),
+                .ttl     = BE8(0),
+                .saddr   = { 0, 0 },
+                .daddr   = { 0, 0 },
+            },
+            .udp = {
+                .sport = BE16(0),
+                .dport = BE16(0),
+                .size  = BE16(0),
+                .cksum = BE16(0)
+            }
+        }
+    },
+
+    [H_TYPE_IP4_UDP] = {
+        .type     = H_TYPE_IP4_UDP,
+        .hsize    = H_SIZE_IP4_UDP,
+        .msize    = 0,
+        .moffset  = offsetof(encap_ip4_udp_s, ip4), // TODO: TEM QUE TER ISSO?
+        .noffset  = offsetof(encap_ip4_udp_s, ip4),
+        .Noffset  = offsetof(encap_ip4_udp_s, ip4),
+        .toffset  = offsetof(encap_ip4_udp_s, udp),
+        .protocol = BE16(ETH_P_IP),
+        .encap_ip4_udp = {
+            .ip4 = {
+                .version = BE8(0x45),
+                .tos     = BE8(0),
+                .size    = BE16(0),
+                .id      = BE16(0),
+                .frag    = BE16(0),
+                .ttl     = BE8(0),
+                .proto   = BE8(IPPROTO_UDP),
+                .cksum   = BE16(0),
+                .saddr   = { 0, 0, 0, 0 },
+                .daddr   = { 0, 0, 0, 0 },
+            },
+            .udp = {
+                .sport = BE16(0),
+                .dport = BE16(0),
+                .size  = BE16(0),
+                .cksum = BE16(0)
+            }
+        }
+    },
+
+    [H_TYPE_IP6_UDP] = {
+        .type     = H_TYPE_IP6_UDP,
+        .hsize    = H_SIZE_IP6_UDP,
+        .msize    = 0,
+        .moffset  = offsetof(encap_ip6_udp_s, ip6), // TODO: TEM QUE TER ISSO?
+        .noffset  = offsetof(encap_ip6_udp_s, ip6),
+        .Noffset  = offsetof(encap_ip6_udp_s, ip6),
+        .toffset  = offsetof(encap_ip6_udp_s, udp),
+        .protocol = BE16(ETH_P_IPV6),
+        .encap_ip6_udp = {
+            .ip6 = {
+                .version = BE8(0x60),
+                .tos     = BE8(0),
+                .flow    = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE8(IPPROTO_UDP),
+                .ttl     = BE8(0),
+                .saddr   = { 0, 0 },
+                .daddr   = { 0, 0 },
+            },
+            .udp = {
+                .sport = BE16(0),
+                .dport = BE16(0),
+                .size  = BE16(0),
+                .cksum = BE16(0)
+            }
+        }
+    },
+
+    [H_TYPE_IP4] = {
+        .type     = H_TYPE_IP4,
+        .hsize    = H_SIZE_IP4,
+        .msize    = 0,
+        .moffset  = offsetof(encap_eth_ip4_s, ip4),
+        .noffset  = offsetof(encap_eth_ip4_s, ip4),
+        .Noffset  = offsetof(encap_eth_ip4_s, ip4),
+        .toffset  = offsetof(pkt_s, x),
+        .protocol = BE16(ETH_P_IP),
+        .encap_ip4 = {
+            .ip4 = {
+                .version = BE8(0x45),
+                .tos     = BE8(0),
+                .size    = BE16(0),
+                .id      = BE16(0),
+                .frag    = BE16(0),
+                .ttl     = BE8(0),
+                .proto   = BE8(IPPROTO_XGW),
+                .cksum   = BE16(0),
+                .saddr   = { 0, 0, 0, 0 },
+                .daddr   = { 0, 0, 0, 0 },
+            }
+        }
+       //encap->i4.ip4.cksum  = ip_fast_csum(&encap->i4.ip4, 5),
+    },
+
+#if 0
+    [H_TYPE_IP6] = {
+
+    },
+
+#endif
+
+    // TODO: NO CASO DO VLAN, O TRANSPORTE APONTA PARA O VLAN OU PARA O IP?
+    [H_TYPE_ETH_VLAN_IP4] = {
+        .type     = H_TYPE_ETH_VLAN_IP4,
+        .hsize    = H_SIZE_ETH_VLAN_IP4,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_vlan_ip4_s, eth),
+        .noffset  = offsetof(encap_eth_vlan_ip4_s, vlan),
+        .Noffset  = offsetof(encap_eth_vlan_ip4_s, ip4),
+        .toffset  = offsetof(encap_eth_vlan_ip4_s, ip4),
+        .protocol = BE16(0),
+        .encap_eth_vlan_ip4 = {
+            .eth = {
+                .dmac = { 0, 0, 0, 0, 0, 0 },
+                .smac = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(0),
+            },
+            .vlan = {
+                .id = BE16(0),
+                .proto = BE16(ETH_P_IP),
+            },
+            .ip4 = {
+                .version = BE8(0x45),
+                .tos     = BE8(0),
+                .size    = BE16(0),
+                .id      = BE16(0),
+                .frag    = BE16(0),
+                .ttl     = BE8(0),
+                .proto   = BE8(IPPROTO_XGW),
+                .cksum   = BE16(0),
+                .saddr   = { 0, 0, 0, 0 },
+                .daddr   = { 0, 0, 0, 0 },
+            },
+        }
+    },
+
+    [H_TYPE_ETH_VLAN_PPP] = {
+        .type     = H_TYPE_ETH_VLAN_PPP,
+        .hsize    = H_SIZE_ETH_VLAN_PPP,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_vlan_ppp_s, eth),
+        .noffset  = offsetof(encap_eth_vlan_ppp_s, vlan),
+        .Noffset  = offsetof(encap_eth_vlan_ppp_s, ppp),
+        .toffset  = offsetof(encap_eth_vlan_ppp_s, ppp),
+       ._reserved = offsetof(encap_eth_vlan_ppp_s, ppp),
+        .protocol = BE16(0),
+        .encap_eth_vlan_ppp = {
+            .eth = {
+                .dmac  = { 0, 0, 0, 0, 0, 0 },
+                .smac  = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(0),
+            },
+            .vlan = {
+                .id    = BE16(0),
+                .proto = BE16(ETH_P_PPP_SES),
+            },
+            .ppp = {
+                .code    = BE16(0x1100),
+                .session = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE16(ETH_P_XGW),
+            },
+        }
+    },
+
+    [H_TYPE_ETH_VLAN_PPP_IP4] = {
+        .type     = H_TYPE_ETH_VLAN_PPP_IP4,
+        .hsize    = H_SIZE_ETH_VLAN_PPP_IP4,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_vlan_ppp_ip4_s, eth),
+        .noffset  = offsetof(encap_eth_vlan_ppp_ip4_s, vlan),
+        .Noffset  = offsetof(encap_eth_vlan_ppp_ip4_s, ip4),
+        .toffset  = offsetof(encap_eth_vlan_ppp_ip4_s, ip4),
+       ._reserved = offsetof(encap_eth_vlan_ppp_ip4_s, ppp),
+        .protocol = BE16(0),
+        .encap_eth_vlan_ppp_ip4 = {
+            .eth = {
+                .dmac  = { 0, 0, 0, 0, 0, 0 },
+                .smac  = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(0),
+            },
+            .vlan = {
+                .id    = BE16(0),
+                .proto = BE16(ETH_P_PPP_SES),
+            },
+            .ppp = {
+                .code    = BE16(0x1100),
+                .session = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE16(0x0021), // ETH_P_IP
+            },
+            .ip4 = {
+                .version = BE8(0x45),
+                .tos     = BE8(0),
+                .size    = BE16(0),
+                .id      = BE16(0),
+                .frag    = BE16(0),
+                .ttl     = BE8(0),
+                .proto   = BE8(IPPROTO_XGW),
+                .cksum   = BE16(0),
+                .saddr   = { 0, 0, 0, 0 },
+                .daddr   = { 0, 0, 0, 0 },
+            },
+        }
+    },
+
+    [H_TYPE_ETH_VLAN_PPP_IP6] = {
+        .type     = H_TYPE_ETH_VLAN_PPP_IP6,
+        .hsize    = H_SIZE_ETH_VLAN_PPP_IP6,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_vlan_ppp_ip6_s, eth),
+        .noffset  = offsetof(encap_eth_vlan_ppp_ip6_s, vlan),
+        .Noffset  = offsetof(encap_eth_vlan_ppp_ip6_s, ip6),
+        .toffset  = offsetof(encap_eth_vlan_ppp_ip6_s, ip6),
+       ._reserved = offsetof(encap_eth_vlan_ppp_ip6_s, ppp),
+        .protocol = BE16(0),
+        .encap_eth_vlan_ppp_ip6 = {
+            .eth = {
+                .dmac  = { 0, 0, 0, 0, 0, 0 },
+                .smac  = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(0),
+            },
+            .vlan = {
+                .id    = BE16(0),
+                .proto = BE16(ETH_P_PPP_SES),
+            },
+            .ppp = {
+                .code    = BE16(0x1100),
+                .session = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE16(0x0057), // ETH_P_IPV6
+            },
+            .ip6 = {
+                .version = BE8(0x60),
+                .tos     = BE8(0),
+                .flow    = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE8(IPPROTO_XGW),
+                .ttl     = BE8(0),
+                .saddr   = { 0, 0 },
+                .daddr   = { 0, 0 },
+            },
+        }
+    },
+
+    [H_TYPE_ETH_VLAN_IP6] = {
+        .type     = H_TYPE_ETH_VLAN_IP6,
+        .hsize    = H_SIZE_ETH_VLAN_IP6,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_vlan_ip6_s, eth),
+        .noffset  = offsetof(encap_eth_vlan_ip6_s, vlan),
+        .Noffset  = offsetof(encap_eth_vlan_ip6_s, ip6),
+        .toffset  = offsetof(encap_eth_vlan_ip6_s, ip6),
+        .protocol = BE16(0),
+        .encap_eth_vlan_ip6 = {
+            .eth = {
+                .dmac  = { 0, 0, 0, 0, 0, 0 },
+                .smac  = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(0),
+            },
+            .vlan = {
+                .id = BE16(0),
+                .proto = BE16(ETH_P_IPV6),
+            },
+            .ip6 = {
+                .version = BE8(0x60),
+                .tos     = BE8(0),
+                .flow    = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE8(IPPROTO_XGW),
+                .ttl     = BE8(0),
+                .saddr   = { 0, 0 },
+                .daddr   = { 0, 0 },
+            },
+        }
+    },
+
+    [H_TYPE_ETH_VLAN] = {
+        .type     = H_TYPE_ETH_VLAN,
+        .hsize    = H_SIZE_ETH_VLAN,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_vlan_s, eth),
+        .noffset  = offsetof(encap_eth_vlan_s, vlan), // TODO: PRECISA DISSO?
+        .Noffset  = offsetof(encap_eth_vlan_s, vlan),
+        .toffset  = offsetof(encap_eth_vlan_s, vlan),
+        .protocol = BE16(0), // ETH_P_8021Q / ETH_P_8021AD
+        .encap_eth_vlan = {
+            .eth = {
+                .dmac = { 0, 0, 0, 0, 0, 0 },
+                .smac = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(0),
+            },
+            .vlan = {
+                .id    = BE16(0),
+                .proto = BE16(ETH_P_XGW),
+            },
+        }
+    },
+
+    [H_TYPE_ETH_VLAN_IP4_UDP] = {
+        .type     = H_TYPE_ETH_VLAN_IP4_UDP,
+        .hsize    = H_SIZE_ETH_VLAN_IP4_UDP,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_vlan_ip4_udp_s, eth),
+        .noffset  = offsetof(encap_eth_vlan_ip4_udp_s, vlan),
+        .Noffset  = offsetof(encap_eth_vlan_ip4_udp_s, ip4),
+        .toffset  = offsetof(encap_eth_vlan_ip4_udp_s, udp),
+        .protocol = BE16(0),
+        .encap_eth_vlan_ip4_udp = {
+            .eth = {
+                .dmac = { 0, 0, 0, 0, 0, 0 },
+                .smac = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(0),
+            },
+            .vlan = {
+                .id = BE16(0),
+                .proto = BE16(ETH_P_IP),
+            },
+            .ip4 = {
+                .version = BE8(0x45),
+                .tos     = BE8(0),
+                .size    = BE16(0),
+                .id      = BE16(0),
+                .frag    = BE16(0),
+                .ttl     = BE8(0),
+                .proto   = BE8(IPPROTO_UDP),
+                .cksum   = BE16(0),
+                .saddr   = { 0, 0, 0, 0 },
+                .daddr   = { 0, 0, 0, 0 },
+            },
+            .udp = {
+                .sport = BE16(0),
+                .dport = BE16(0),
+                .size  = BE16(0),
+                .cksum = BE16(0)
+            }
+        }
+    },
+
+    [H_TYPE_ETH_VLAN_IP6_UDP] = {
+        .type     = H_TYPE_ETH_VLAN_IP6_UDP,
+        .hsize    = H_SIZE_ETH_VLAN_IP6_UDP,
+        .msize    = ETH_HLEN,
+        .moffset  = offsetof(encap_eth_vlan_ip6_udp_s, eth),
+        .noffset  = offsetof(encap_eth_vlan_ip6_udp_s, vlan),
+        .Noffset  = offsetof(encap_eth_vlan_ip6_udp_s, ip6),
+        .toffset  = offsetof(encap_eth_vlan_ip6_udp_s, udp),
+        .protocol = BE16(0),
+        .encap_eth_vlan_ip6_udp = {
+            .eth = {
+                .dmac  = { 0, 0, 0, 0, 0, 0 },
+                .smac  = { 0, 0, 0, 0, 0, 0 },
+                .proto = BE16(0),
+            },
+            .vlan = {
+                .id = BE16(0),
+                .proto = BE16(ETH_P_IPV6),
+            },
+            .ip6 = {
+                .version = BE8(0x60),
+                .tos     = BE8(0),
+                .flow    = BE16(0),
+                .size    = BE16(0),
+                .proto   = BE8(IPPROTO_UDP),
+                .ttl     = BE8(0),
+                .saddr   = { 0, 0 },
+                .daddr   = { 0, 0 },
+            },
+            .udp = {
+                .sport = BE16(0),
+                .dport = BE16(0),
+                .size  = BE16(0),
+                .cksum = BE16(0)
+            }
+        }
+    },
+
+};
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/ports.c linux-master/drivers/net/xgw/ports.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/ports.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/ports.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,16 @@
+
+// TODO: SO APRENDER UM PATH SE TAL PORTA ESTIVER CONFIGURADA NELE
+static inline void ports_enable (const uint port) {
+
+    PORTS_W |= PORTS_B;
+}
+
+static inline void ports_disable (const uint port) {
+
+    PORTS_W &= ~PORTS_B;
+}
+
+static inline ports_t ports_is_enabled (const uint port) {
+
+    return PORTS_W & PORTS_B;
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/ports.h linux-master/drivers/net/xgw/ports.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/ports.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/ports.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,14 @@
+
+// ALL UDP PORTS
+#define UDP_PORTS_N 65536
+
+//
+#define PORTS_N (UDP_PORTS_N / PORTS_WIDTH)
+
+#define PORTS_WIDTH 32
+#define PORTS_SHIFT 5
+#define PORTS_MASK 0b11111
+#define PORTS_W (ports[port >> PORTS_SHIFT])
+#define PORTS_B (1 << (port & PORTS_MASK))
+
+typedef int ports_t;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/random.c linux-master/drivers/net/xgw/random.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/random.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/random.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,63 @@
+
+// X86 RDRAND
+#ifdef CONFIG_XGW_RDRAND
+static inline u64 rdrand64 (void) {
+
+    u64 r;
+
+    __builtin_ia32_rdrand64_step(&r);
+
+    return r;
+}
+#endif
+
+// NAO É RANDOM NO SENTIDO DE NAO ADIVINHAVEL, MAS FICA NAO TAO SEQUENCIAL E ALTERANDO DIFERENTES BITS
+static void random64_n (u64 words[], uint n, u64 seed) {
+
+#ifdef CONFIG_XGW_RDRAND
+    seed += rdrand64();
+#endif
+#ifdef CONFIG_XGW_RDTSC
+    seed += __builtin_ia32_rdtsc();
+#endif
+
+    for_count (i, n) {
+        seed += _xrnd[seed % RANDOM_LEN];
+        seed += _xrnd[seed % RANDOM_LEN] * seed;
+                _xrnd[seed % RANDOM_LEN] = seed;
+        words[i] = seed;
+    }
+}
+
+static u64 random64 (u64 seed) {
+
+#ifdef CONFIG_XGW_RDRAND
+    seed += rdrand64();
+#endif
+#ifdef CONFIG_XGW_RDTSC
+    seed += __builtin_ia32_rdtsc();
+#endif
+
+    seed += _xrnd[seed % RANDOM_LEN];
+    seed += _xrnd[seed % RANDOM_LEN] * seed;
+            _xrnd[seed % RANDOM_LEN] = seed;
+
+    return seed;
+}
+
+static void random64_init (void) {
+
+    u64 seed = SUFFIX_ULL(CONFIG_XGW_RANDOM_PING);
+
+#ifdef CONFIG_XGW_RDTSC
+    seed += __builtin_ia32_rdtsc();
+#endif
+
+    for_count (i, RANDOM_LEN) {
+        seed += seed * popcount(seed);
+#ifdef CONFIG_XGW_RDRAND
+        seed += rdrand64();
+#endif
+        _xrnd[i] = seed;
+    }
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/random.h linux-master/drivers/net/xgw/random.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/random.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/random.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,2 @@
+
+#define RANDOM_LEN 8
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/stats.c linux-master/drivers/net/xgw/stats.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/stats.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/stats.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,100 @@
+
+#define STAT_NAME(a) [a] = #a
+
+static const struct {
+    const char* d [DSTATS_N];
+    const char* n [NSTATS_N];
+    const char* p [PSTATS_N];
+} statsStrs = {  // TODO: MARCAR SE ESTIVER ENVIANDO UM PING ATRASADO
+    {
+        STAT_NAME(DSTATS_I_NOT_XGW),
+        STAT_NAME(DSTATS_I_NON_LINEAR),
+        STAT_NAME(DSTATS_I_INCOMPLETE),
+        STAT_NAME(DSTATS_I_FROM_SELF),
+        STAT_NAME(DSTATS_O_DATA_DOWN),
+        STAT_NAME(DSTATS_O_DATA_NON_LINEAR),
+        STAT_NAME(DSTATS_O_DATA_UNKNOWN),
+        STAT_NAME(DSTATS_O_DATA_TO_SELF),
+        STAT_NAME(DSTATS_O_DATA_NO_GW),
+        STAT_NAME(DSTATS_O_DATA_SIZE_SMALL),
+        STAT_NAME(DSTATS_O_DATA_SIZE_BIG),
+    }, {
+        STAT_NAME(NSTATS_I_FORWARD),
+        STAT_NAME(NSTATS_I_INEXIST),
+        STAT_NAME(NSTATS_I_DISABLED),
+        STAT_NAME(NSTATS_I_DOWN),
+        STAT_NAME(NSTATS_I_PATH_INVALID),
+        STAT_NAME(NSTATS_O_DATA_INEXIST),
+        STAT_NAME(NSTATS_O_DATA_DISABLED),
+        STAT_NAME(NSTATS_O_DATA_MTU_EXCEEDED),
+        STAT_NAME(NSTATS_O_DATA_NO_PATH),
+    }, {
+        STAT_NAME(PSTATS_I_DATA_GOOD),
+        STAT_NAME(PSTATS_I_DATA_IP4_TRUNCATED),
+        STAT_NAME(PSTATS_I_DATA_IP6_TRUNCATED),
+        STAT_NAME(PSTATS_I_DISABLED),
+        STAT_NAME(PSTATS_I_SIZE_SMALL),
+        STAT_NAME(PSTATS_I_SIZE_NOT_PING),
+        STAT_NAME(PSTATS_I_SIZE_TRUNCATED),
+        STAT_NAME(PSTATS_I_HASH_MISMATCH),
+        STAT_NAME(PSTATS_I_LISTENING_SYN_TOO_MANY),
+        STAT_NAME(PSTATS_I_LISTENING_SYN_WRONG),
+        STAT_NAME(PSTATS_I_LISTENING_REFUSE_DATA_AND_PONG),
+        STAT_NAME(PSTATS_I_ACCEPTING),
+        STAT_NAME(PSTATS_I_CONNECTING_REQUIRE_PONG),
+        STAT_NAME(PSTATS_I_ESTABLISHED_REFUSE_SYN),
+        STAT_NAME(PSTATS_I_LTIME_MISMATCH_SYN),
+        STAT_NAME(PSTATS_I_LTIME_MISMATCH),
+        STAT_NAME(PSTATS_I_RTIME_MISMATCH),
+        STAT_NAME(PSTATS_I_SYN_ACK_RACED),
+        STAT_NAME(PSTATS_I_PING_GOOD),
+        STAT_NAME(PSTATS_I_PONG_GOOD),
+        STAT_NAME(PSTATS_K_TIMEOUTS),
+        STAT_NAME(PSTATS_O_PING_OK),
+        STAT_NAME(PSTATS_O_PING_SKB_FAILED),
+        STAT_NAME(PSTATS_O_PING_SEND_FAILED),
+        STAT_NAME(PSTATS_O_DATA_OK),
+        STAT_NAME(PSTATS_O_DATA_NO_HEADROOM),
+        STAT_NAME(PSTATS_O_DATA_CKSUM_FAILED),
+        STAT_NAME(PSTATS_O_DATA_FAIL),
+    }
+};
+
+static void __cold_as_ice __optimize_size stats_print (void) {
+
+    for_count (s, DSTATS_N) {
+        const uintll c = atomic_get(&(dstats[s].count));
+        const uintll b = atomic_get(&(dstats[s].bytes));
+        if (c || b)
+            printk("XGW: %s %llu %llu\n", statsStrs.d[s], c, b);
+    }
+
+    for_count (nid, NODES_N) {
+
+        const node_s* const node = nodes_get_locked_unsuspended(nid);
+
+        if (node) {
+
+            for_count (s, NSTATS_N) {
+                const uintll c = atomic_get(&(nstats[nid][s].count));
+                const uintll b = atomic_get(&(nstats[nid][s].bytes));
+                if (c || b)
+                    printk("XGW: %s %s %llu %llu\n", node->name, statsStrs.n[s], c, b);
+            }
+
+            for_count (pid, PATHS_N) {
+
+                const path_s* const path = &node->paths[pid];
+
+                if (path->info) { // <----- E SE QUISERMOS VER MESMO ASSIM?
+                    for_count (s, PSTATS_N) {
+                        const u64 c = atomic_get(&path->stats[s].count);
+                        const u64 b = atomic_get(&path->stats[s].bytes);
+                        if (c || b)
+                            printk("XGW: %s [%s] %s %llu %llu\n", node->name, path->name, statsStrs.p[s], (uintll)c, (uintll)b);
+                    }
+                }
+            }
+        }
+    }
+}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/stats.h linux-master/drivers/net/xgw/stats.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/stats.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/stats.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,88 @@
+
+// STATISTICS
+
+// NOTE: THOSE ORDERS MUST CONSIDER CACHE USAGE
+
+// INTERFACE
+// TODO: GLOBAL STATS VS PHYS STATS (PER ITFC INDEX)
+enum DSTATS {
+    DSTATS_I_NOT_XGW, // PASS
+    DSTATS_I_NON_LINEAR,
+    DSTATS_I_INCOMPLETE,
+    DSTATS_I_FROM_SELF,
+    DSTATS_O_DATA_DOWN,
+    DSTATS_O_DATA_NON_LINEAR,
+    DSTATS_O_DATA_UNKNOWN,
+    DSTATS_O_DATA_TO_SELF,
+    DSTATS_O_DATA_NO_GW,
+    DSTATS_O_DATA_SIZE_SMALL,
+    DSTATS_O_DATA_SIZE_BIG,
+    DSTATS_N
+};
+
+// NODE
+enum NSTATS {
+    NSTATS_I_FORWARD, // PASS
+    NSTATS_I_INEXIST,
+    NSTATS_I_DISABLED,
+    NSTATS_I_DOWN,
+    NSTATS_I_PATH_INVALID,
+    NSTATS_O_DATA_INEXIST,
+    NSTATS_O_DATA_DISABLED,
+    NSTATS_O_DATA_MTU_EXCEEDED,
+    NSTATS_O_DATA_NO_PATH,
+    NSTATS_N
+};
+
+// PATH
+enum PSTATS {
+
+    PSTATS_I_DATA_GOOD, // PASS
+    PSTATS_I_DATA_IP4_TRUNCATED,
+    PSTATS_I_DATA_IP6_TRUNCATED,
+    PSTATS_I_DISABLED,
+    PSTATS_I_SIZE_SMALL,
+    PSTATS_I_SIZE_TRUNCATED,
+    PSTATS_I_SIZE_NOT_PING,
+    PSTATS_I_HASH_MISMATCH,
+    PSTATS_I_ESTABLISHED_REFUSE_SYN,
+    PSTATS_I_CONNECTING_REQUIRE_PONG,
+    PSTATS_I_LISTENING_SYN_TOO_MANY,
+    PSTATS_I_LISTENING_SYN_WRONG,
+    PSTATS_I_LISTENING_REFUSE_DATA_AND_PONG,
+    PSTATS_I_ACCEPTING,
+    PSTATS_I_LTIME_MISMATCH_SYN,
+    PSTATS_I_LTIME_MISMATCH,
+    PSTATS_I_RTIME_MISMATCH,
+    PSTATS_I_SYN_ACK_RACED,
+    PSTATS_I_PING_GOOD,
+    PSTATS_I_PONG_GOOD,
+
+    PSTATS_K_TIMEOUTS,
+
+    PSTATS_O_PING_OK,
+    PSTATS_O_PING_SKB_FAILED,
+    PSTATS_O_PING_SEND_FAILED,
+
+    PSTATS_O_DATA_OK,
+    PSTATS_O_DATA_NO_HEADROOM,
+    PSTATS_O_DATA_CKSUM_FAILED,
+    PSTATS_O_DATA_FAIL,
+
+    PSTATS_N
+};
+
+struct stat_s {
+    u64 count;
+    u64 bytes; // NOTE: ALGUNS STATS TERAO O COUNT/BYTES CONSIDERANDO O PACOTE REAL E NAO ENCAPSULADO
+};
+
+// TODO: OUT {ping, pong, data} _PHYS_DOWN
+// TODO: OUT {ping, pong, data} _PHYS_NO_CARRIER
+
+#define stat_inc_count(ptr)      __atomic_add_fetch(ptr, 1, __ATOMIC_RELAXED)
+#define stat_inc_bytes(ptr, b)   __atomic_add_fetch(ptr, b, __ATOMIC_RELAXED)
+
+#define ret_dev(i)  { stat = i; goto _ret_dev;  }
+#define ret_node(i) { stat = i; goto _ret_node; }
+#define ret_path(i) { stat = i; goto _ret_path; }
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/TODO.txt linux-master/drivers/net/xgw/TODO.txt
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/TODO.txt	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/TODO.txt	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,131 @@
+INICIALIZAR TODAS AS IKEYS / OKEYS com o secret
+    ou melhor, com um iKeysInitial
+
+AO APRENDER KEYS USAR AS JA CONHECIDAS
+    ou seja, o mesmo que o out faz para criptografar
+     e o in ao receber
+
+#
+
+WARN/DESISTIR AO TENTAR SE CONECTAR USANDO UMA PORTA QUE NAO ESTA ATIVADA
+
+###
+
+TEM QUE SER CAPAZ DE SETAR O IP SRC/DST SE ESTIVER ON
+    E STATUS <= CONNECTING
+
+###
+
+traffic shaping burst rate
+
+paths bandwidth weighting
+
+
+###
+
+status path
+
+    if (& ETH_DST)
+        print(eth dst)
+    if ()
+        print(vlan dst)
+
+###
+
+path -> bitarray de devs dos quais pode aprender
+
+
+###
+
+status node
+    checksum do secret
+
+###
+
+informar o ttl sendo usado ao enviar pings
+informar o ttl que ficou ao receber o ping
+
+######
+
+mostrar alteracoes de pings
+se mudar, seta no ping
+
+mostra no keeper
+
+
+###########
+
+informa MTU no ping
+
+informa MRU no ping
+
+ao mudar, seta todos os pings
+
+########################3
+
+P_NAME, path name
+
+#####################
+
+inicia todos os headers ao criar o path
+
+########
+
+ao deletar o path apenas limpa o statos e o cpaths
+
+#########
+
+[87766.352417] XGW: BR [1]: CONNECTING
+[87767.179084] XGW: BR [1]: ACCEPTED ON DEV switch
+[87773.741160] XFS (nvme0n1p4): Unmounting Filesystem 351cf54b-7b3f-4473-9e50-dada810ff179
+[87778.069837] XGW: DOWN
+[87779.579082] XGW: US [1]: UNSTABLE
+[87779.579084] XGW: US [2]: UNSTABLE
+[87779.579084] XGW: SPEEDYB0Y [0]: UNSTABLE
+[87792.805746] XGW: SPEEDYB0Y [0]: SUSPEND
+[87793.632413] XGW: SPEEDYB0Y [0]: SUSPENDING
+[87793.632414] XGW: SPEEDYB0Y [0]: WILL STOP
+[87794.459079] XGW: SPEEDYB0Y [0]: STOPPED
+[87794.459080] XGW: SPEEDYB0Y: STOPED
+[87795.285746] XGW: US [1]: SUSPEND
+[87795.285746] XGW: US [2]: SUSPEND
+[87796.112412] XGW: US [1]: SUSPENDING
+[87796.112413] XGW: US [1]: WILL STOP
+[87796.112413] XGW: US [2]: SUSPENDING
+[87796.112414] XGW: US [2]: WILL STOP
+[87796.939078] XGW: BR [1]: SUSPEND
+[87796.939079] XGW: BR [2]: SUSPEND
+[87796.939080] XGW: US [1]: STOPPED
+[87796.939080] XGW: US [2]: STOPPED
+[87796.939080] XGW: US: STOPED
+[87797.765745] XGW: BR [1]: SUSPENDING
+[87797.765746] XGW: BR [1]: WILL STOP
+[87797.765746] XGW: BR [2]: SUSPENDING
+[87797.765746] XGW: BR [2]: WILL STOP
+[87798.592411] XGW: BR [1]: STOPPED
+[87798.592412] XGW: BR [2]: STOPPED
+[87798.592412] XGW: BR: STOPED
+[88225.374140] XGW: drivers/net/xgw/xgw.c:1792: ASSERT FAILED: node->kpaths & KPATH(pid)
+[88225.374144] XGW: drivers/net/xgw/xgw.c:1793: ASSERT FAILED: node == nodes[nid]
+[88225.374169] XGW: drivers/net/xgw/xgw.c:1792: ASSERT FAILED: node->kpaths & KPATH(pid)
+[88225.374170] XGW: drivers/net/xgw/xgw.c:1793: ASSERT FAILED: node == nodes[nid]
+
+
+
+
+PING
+
+*ping->p ---> SEQ
+signed with auth
+
+
+PONG
+ack
+
+//
+encrypted with the learned o
+signed with 0
+*ping->p ---> ACK
+
+
+data
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/types.h linux-master/drivers/net/xgw/types.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/types.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/types.h	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,43 @@
+
+typedef struct pkt_s  pkt_s;
+typedef struct ping_s ping_s;
+typedef struct path_s path_s;
+typedef struct node_s node_s;
+typedef struct stat_s stat_s;
+
+typedef struct ip4_s ip4_s;
+typedef struct ip6_s ip6_s;
+
+typedef struct hdr_ip4_s   hdr_ip4_s;
+typedef struct hdr_ip6_s   hdr_ip6_s;
+typedef struct hdr_udp_s   hdr_udp_s;
+typedef struct hdr_tcp_s   hdr_tcp_s;
+typedef struct hdr_eth_s   hdr_eth_s;
+typedef struct hdr_vlan_s  hdr_vlan_s;
+typedef struct hdr_ppp_s   hdr_ppp_s;
+
+typedef struct encap_eth_s              encap_eth_s;
+typedef struct encap_eth_ip4_s          encap_eth_ip4_s;
+typedef struct encap_eth_ip6_s          encap_eth_ip6_s;
+typedef struct encap_eth_ip4_udp_s      encap_eth_ip4_udp_s;
+typedef struct encap_eth_ip6_udp_s      encap_eth_ip6_udp_s;
+typedef struct encap_eth_vlan_s         encap_eth_vlan_s;
+typedef struct encap_eth_vlan_ip4_s     encap_eth_vlan_ip4_s;
+typedef struct encap_eth_vlan_ip6_s     encap_eth_vlan_ip6_s;
+typedef struct encap_eth_vlan_ip4_udp_s encap_eth_vlan_ip4_udp_s;
+typedef struct encap_eth_vlan_ip6_udp_s encap_eth_vlan_ip6_udp_s;
+typedef struct encap_ip4_s              encap_ip4_s;
+typedef struct encap_ip6_s              encap_ip6_s;
+typedef struct encap_ip4_udp_s          encap_ip4_udp_s;
+typedef struct encap_ip4_tcp_s          encap_ip4_tcp_s;
+typedef struct encap_ip6_udp_s          encap_ip6_udp_s;
+typedef struct encap_ip6_tcp_s          encap_ip6_tcp_s;
+
+typedef struct encap_eth_ppp_s          encap_eth_ppp_s;
+typedef struct encap_eth_ppp_ip4_s      encap_eth_ppp_ip4_s;
+typedef struct encap_eth_ppp_ip6_s      encap_eth_ppp_ip6_s;
+typedef struct encap_eth_vlan_ppp_s     encap_eth_vlan_ppp_s;
+typedef struct encap_eth_vlan_ppp_ip4_s encap_eth_vlan_ppp_ip4_s;
+typedef struct encap_eth_vlan_ppp_ip6_s encap_eth_vlan_ppp_ip6_s;
+
+typedef struct hdr_x_s hdr_x_s;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/xgw.c linux-master/drivers/net/xgw/xgw.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/xgw.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/xgw.c	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,255 @@
+/*
+
+*/
+
+#include "kconfig.h"
+
+#if 1
+#define BUILD_ASSERT(c) _Static_assert((c), #c)
+#else
+#define BUILD_ASSERT(c)
+#endif
+
+#ifdef CONFIG_XGW_ASSERT
+#define ASSERT(c) ({ if (unlikely(!(c))) printk("XGW: %s:%d: ASSERT FAILED: %s\n", __FILE__, __LINE__, #c); })
+#elif 1
+#define ASSERT(c) __attribute__((assume(c)))
+#else
+#define ASSERT(c) ({})
+#endif
+
+#define CACHE_LINE_SIZE 64
+
+//
+#define KEEPER_INTERVAL_MS 900
+#define KEEPER_INTERVAL_JIFFIES ((9 * HZ) / 10)
+
+#define KEEPER_LAUNCH_DELAY_SECS 4
+
+// HASHEIA E AGRUPA POR INTERFACE INDEX
+// NOTE: SE MUDAR DE INTERFACE VAI TER QUE REMOVER DA LISTA PRIMEIRO, E SÓ DEPOIS JOGAR PARA OUTRO
+#define PING_QUEUES_N 8
+
+#ifdef CONFIG_XGW_GATEWAY
+#define XGW_TCP_PROXY_MARK_4 0x25440000U
+#define XGW_TCP_PROXY_MARK_6 0x25660000U
+#endif
+
+// QUANTO MAIS INTERVALOS AGUENTA MAIS TEMPO DE FALHAS DE CONEXAO SEM TER QUE RENEGOCIAR E EXPOR AS PRESHAREDS
+// QUANTO MAIS INTERVALOS MENOS PROBABILIDADE DA RESINCRONIZACAO DE L/R COUNTERS SOBRESCREVER IKEYS ATUAIS
+
+//
+#define MTU_MIN XGW_PAYLOAD_MIN
+#define MTU_MAX XGW_PAYLOAD_MAX
+
+#define GWS_N 8
+
+// A XGW ADDRESS IS COMPOSED OF
+// PREFIX | NODE | SUB
+
+// 192.0.0.0/24
+#define V4_PREFIX 0xC0000000U
+#define V4_WIDTH_PREFIX 24
+#define V4_WIDTH_NODE 8
+
+// fccc::/16         -> XGW'S NETWORK
+// fccc:NODE::/32    -> NODE'S NETWORK
+#define V6_PREFIX 0xFCCC000000000000ULL
+#define V6_WIDTH_PREFIX 16
+#define V6_WIDTH_NODE 16
+
+#define __link(o, ptr_to_next) { \
+        if ((o->next = (ptr_to_next))) { \
+             o->next->ptr = &o->next; \
+        }  *(o->ptr = &(ptr_to_next)) = o; \
+    }
+
+// NOTE: O->NEXT FICARA INVALIDO
+#define __unlink(o) { \
+        if ((*o->ptr = o->next)) { \
+            (*o->ptr)->ptr = o->ptr; \
+        }     o->ptr = NULL; \
+    }
+
+#define LTIME_DIFF_RTIME(ltime, rtime) ((s64)(ltime) - (s64)(rtime))
+#define LTIME(rtime, tdiff) ((u64)((rtime) + (tdiff)))
+#define RTIME(ltime, tdiff) ((u64)((ltime) - (tdiff)))
+
+#define ANSWERED_LISTENING  ((u64)0)
+#define ANSWERED_ACCEPTING  ((u64)1)
+#define ANSWERED_CONNECTING ((u64)2048) // TEM QUE SER GRANDE SUFICIENTE PARA QUE ((path->answered - path->asked) > RTT_MAX)
+
+// REAL TIME (KTIME) (~2 YEARS IN MS)
+#define RTIME_MIN ((u64)8192)
+#define RTIME_MAX ((u64)0x1800000000ULL)
+
+//
+#define PTIME_MIN (PMASK_MIN + RTIME_MIN)
+#define PTIME_MAX (PMASK_MAX + RTIME_MAX)
+
+// MAX DIFFERENCE FROM LOCAL PTIME TO PEER PTIME
+#define TDIFF_MIN ((s64)PTIME_MIN - (s64)PTIME_MAX)
+#define TDIFF_MAX ((s64)PTIME_MAX - (s64)PTIME_MIN)
+
+#include "base.h"
+#include "types.h"
+#include "ports.h"
+#include "random.h"
+#include "crypto.h"
+#include "ping.h"
+#include "pkt.h"
+#include "stats.h"
+#include "nodes.h"
+#include "dhcp.h"
+#include "cmd_codes.h"
+#include "cmd_errs.h"
+#include "cmd_args_types.h"
+
+DEFINE_SPINLOCK(xlock);
+
+static volatile u64 _xrnd [RANDOM_LEN];
+static net_device_s* xgw;
+static node_s* knodes;
+static u16 nodeSelf;
+static u8 gwsN;
+static u16 gws [GWS_N]; // TODO: PODE DEIXAR DUAS ARRAYS E MODIFICAR A QUE NAO ESTA SENDO USADA
+static node_s* volatile nodes [NODES_N];
+#ifdef CONFIG_XGW_NMAP
+static volatile u16 nmap [NODES_N];
+#endif
+static volatile ports_t ports [PORTS_N];
+static volatile stat_s dstats           [DSTATS_N];
+static volatile stat_s nstats [NODES_N] [NSTATS_N];
+
+// NEED TO BE SEPARATE
+//    - SO IT CAN BE USET WITHOUT THE LOCK
+//    - SO IT CAN BE USET WITH INTERRUPTS ENABLED
+//    - SO IT CAN BE DONE ONCE
+//    - SO IT CAN BE DONE PER INTERFACE HASH
+static path_s* pings [PING_QUEUES_N];
+
+// EXPOSED TO KERNEL
+// net/core/dev.c WILL USE US
+#define in xgw_dev_in
+
+static inline u64 get_current_ms (void) {
+#ifdef CONFIG_HIGH_RES_TIMERS
+    const u64 j = ((RTIME_MIN * NSEC_PER_MSEC) + ktime_get_boottime_ns()) / NSEC_PER_MSEC;
+#else // jiffies64_to_msecs()
+#error
+#endif
+    ASSERT(j >= RTIME_MIN);
+    ASSERT(j <= RTIME_MAX);
+    return j;
+}
+
+#include "alloc.c"
+#ifdef CONFIG_XGW_BEEP
+#include "beep.c"
+#endif
+#include "random.c"
+#include "ports.c"
+#include "crypto.c"
+#include "pkt_skels.c"
+#include "pkt_encap.c"
+#include "out.c"
+#include "ping.c"
+#include "in_discover.c"
+#include "in.c"
+#include "keeper.c"
+#include "stats.c"
+#include "dev.c"
+#include "cmd_names.c"
+#include "cmd.c"
+#include "asserts.c"
+
+/*
+
+ - pode fazer isso deixando de verificar o hash no TCP
+    e trocando a porta dst no input para CONFIG_XGW_PROXY_PORT
+    e trocando a porta src no output para CONFIG_XGW_PROXY_PORT
+
+ - pode fazer isso forcando a porta CONFIG_XGW_PROXY_PORT ao verificar o bind hash tables
+        e mantendo as portas originais
+*/
+
+// EM MILISEGUNDOS E NAO JIFIFES
+
+// TERMINADO EM 1: SEM IN/OUT (ESTA DISABLED)
+// NULL -> NAO TEM, OU ESTA SENDO DELETADO
+
+// vai ter que retirar o erro node_is_self :S ?
+//  ou nao vai poder setar o self comoum que ja existe
+// e nem crar um que seja o self
+
+static struct proc_ops xgwProcOps = {
+    .proc_write = cmd,
+};
+
+static int __init xgw_init (void) {
+
+    //BUILD_ASSERT(sizeof(dhcp_s) == DHCP_SIZE);
+
+    //
+    BUILD_ASSERT( ( ((uintptr_t)0xffffffffffffffffULL) & (~(uintptr_t)1) ) == (0xffffffffffffffffULL ^ 1) );
+
+    printk("XGW: INIT KEEPER INTERVAL %u MS\n", KEEPER_INTERVAL_MS);
+    printk("XGW: V4 PREFIX %08llX WIDTH %u/%u\n", (uintll)V4_PREFIX, V4_WIDTH_PREFIX, V4_WIDTH_NODE);
+    printk("XGW: V6 PREFIX %016llX WIDTH %u/%u\n", (uintll)V6_PREFIX, V6_WIDTH_PREFIX, V6_WIDTH_NODE);
+
+    // INITIALIZE EVERYTHING
+
+    // TODO:
+    nodeSelf = 0;
+
+    gwsN = 0;
+
+    //
+    random64_init();
+
+    knodes = NULL;
+
+    memset(pings,  0, sizeof(pings));
+    memset(gws,  0, sizeof(gws));
+    memset((void*)ports,  0, sizeof(ports));
+    memset((void*)nodes,  0, sizeof(nodes));
+    memset((void*)&dstats, 0, sizeof(dstats));
+    memset((void*)&nstats, 0, sizeof(nstats));
+
+#ifdef CONFIG_XGW_NMAP
+    //
+    for (int i = 0; i != NODES_N; i++)
+        nmap[i] = i;
+#endif
+
+    // CREATE THE VIRTUAL INTERFACE
+    xgw = alloc_netdev(0, "xgw", NET_NAME_USER, dev_setup);
+
+    if (xgw == NULL) {
+        printk("XGW: FAILED TO ALLOCATE\n");
+        return -1;
+    }
+
+    // MAKE IT VISIBLE IN THE SYSTEM
+    if (register_netdev(xgw)) {
+        printk("XGW: CREATE FAILED TO REGISTER\n");
+        return -1;
+    }
+
+#ifdef CONFIG_XGW_BEEP
+    proc_create("beep", 0600, NULL, &beepProcOps);
+#endif
+
+    // LAUNCH KEEPER
+    kTimer.expires = jiffies + KEEPER_LAUNCH_DELAY_SECS * HZ;
+    add_timer(&kTimer);
+
+    // EXPOSE CMD
+    proc_create("xgw", 0600, NULL, &xgwProcOps);
+
+    return 0;
+}
+
+late_initcall(xgw_init);
+
+// TODO: REVIEW ALL RESTRICT
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/xgw.py linux-master/drivers/net/xgw/xgw.py
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/net/xgw/xgw.py	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/drivers/net/xgw/xgw.py	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,816 @@
+#!/usr/bin/python
+
+# dd status=none if=/dev/random bs=128 count=1 | base64 --wrap=0 ; echo
+
+import sys
+import os
+import time
+import base64
+import binascii
+import ipaddress
+
+NODE_NAME_SIZE = 32
+PATH_NAME_SIZE = 24
+
+PORTS_N = 65536
+
+IFNAMSIZ = 16
+
+ETH_ALEN = 6
+
+ETH_P_8021Q  = 0x8100
+ETH_P_8021AD = 0x88A8
+
+###
+
+_MTU_MIN =   128
+_MTU_MAX = 16384
+
+_TTL_MIN =   1
+_TTL_MAX = 255
+
+_CONNS_MIN =       1
+_CONNS_MAX = 4194304 # 4MB
+
+TOS_MAX = 0xFF
+
+NODES_N = 65536
+PATHS_N = 16
+PATH_PORTS_N = 4
+NODE_NAME_SIZE = 32
+PATH_WEIGHT_MAX = 31
+
+PATH_TIMEOUT_MIN =     1
+PATH_TIMEOUT_MAX = 65535
+
+CMDS_N = 87
+CMD_ERRS_N = 76
+
+# ALL UDP PORTS
+UDP_PORTS_N = 65536
+
+(
+    CMD_PORT_ON,
+    CMD_PORT_OFF,
+    CMD_PORT_GET,
+
+    CMD_PORTS_LIST,
+    CMD_PORTS_CLEAR,
+
+    CMD_PHYS_ATTACH,
+    CMD_PHYS_DETACH,
+
+    CMD_PHYS_LIST,
+
+    CMD_SELF_SET,
+    CMD_SELF_GET,
+
+    CMD_GWS_INSERT,
+    CMD_GWS_REMOVE,
+    CMD_GWS_LIST,
+    CMD_GWS_CLEAR,
+
+    CMD_NODE_NEW,
+    CMD_NODE_DEL,
+
+    CMD_NODE_SET_NAME,
+    CMD_NODE_SET_MTU,
+    CMD_NODE_SET_CONNS_N,
+    CMD_NODE_SET_SECRET,
+
+    CMD_NODE_DEV_CREATE,
+    CMD_NODE_DEV_DEL,
+
+    CMD_NODE_CLR_NAME,
+    CMD_NODE_CLR_SECRET,
+
+    CMD_NODE_ON,
+    CMD_NODE_OFF,
+
+    CMD_NODE_STATUS,
+    CMD_NODE_STATS,
+
+    CMD_PATH_NEW,
+    CMD_PATH_DEL,
+
+    CMD_PATH_SET_NAME,
+    CMD_PATH_SET_WEIGHT_NODE,
+    CMD_PATH_SET_WEIGHT_ACKS,
+    CMD_PATH_SET_CLIENT,
+    CMD_PATH_SET_SERVER,
+    CMD_PATH_SET_TIMEOUT,
+    CMD_PATH_SET_RTT_VAR,
+    CMD_PATH_SET_DHCP,
+    CMD_PATH_SET_PHYS,
+    CMD_PATH_SET_TYPE,
+    CMD_PATH_SET_ETH_SRC,
+    CMD_PATH_SET_ETH_DST,
+    CMD_PATH_SET_VLAN_PROTO,
+    CMD_PATH_SET_VLAN_ID,
+    CMD_PATH_SET_IP4_TOS,
+    CMD_PATH_SET_IP6_TOS,
+    CMD_PATH_SET_IP4_TTL,
+    CMD_PATH_SET_IP6_TTL,
+    CMD_PATH_SET_IP4_SRC,
+    CMD_PATH_SET_IP4_DST,
+    CMD_PATH_SET_IP6_SRC,
+    CMD_PATH_SET_IP6_DST,
+    CMD_PATH_SET_UDP_SRC,
+    CMD_PATH_SET_TCP_SRC,
+    CMD_PATH_SET_UDP_DST,
+    CMD_PATH_SET_TCP_DST,
+
+    CMD_PATH_SET_PPP_SESSION,
+
+    CMD_PATH_SET_IP_TOS,
+    CMD_PATH_SET_IP_TTL,
+
+    CMD_PATH_CLR_NAME,
+    CMD_PATH_CLR_WEIGHT_NODE,
+    CMD_PATH_CLR_WEIGHT_ACKS,
+    CMD_PATH_CLR_DHCP,
+    CMD_PATH_CLR_PHYS,
+    CMD_PATH_CLR_TYPE,
+    CMD_PATH_CLR_ETH_SRC,
+    CMD_PATH_CLR_ETH_DST,
+    CMD_PATH_CLR_VLAN_PROTO,
+    CMD_PATH_CLR_VLAN_ID,
+    CMD_PATH_CLR_IP4_TOS,
+    CMD_PATH_CLR_IP6_TOS,
+    CMD_PATH_CLR_IP4_TTL,
+    CMD_PATH_CLR_IP6_TTL,
+    CMD_PATH_CLR_IP4_SRC,
+    CMD_PATH_CLR_IP4_DST,
+    CMD_PATH_CLR_IP6_SRC,
+    CMD_PATH_CLR_IP6_DST,
+    CMD_PATH_CLR_UDP_SRC,
+    CMD_PATH_CLR_TCP_SRC,
+    CMD_PATH_CLR_UDP_DST,
+    CMD_PATH_CLR_TCP_DST,
+
+    CMD_PATH_ON,
+    CMD_PATH_OFF,
+
+    CMD_PATH_STATUS,
+    CMD_PATH_STATS,
+
+    CMD_STATS,
+
+    CMD_NMAP,
+) = range(CMDS_N)
+
+(
+    CMD_ERR_ALLOC_CMD,
+    CMD_ERR_ALLOC_CONNS,
+    CMD_ERR_ALLOC_NODE,
+    CMD_ERR_INVALID_CONNS_N,
+    CMD_ERR_INVALID_MTU,
+    CMD_ERR_INVALID_NID,
+    CMD_ERR_INVALID_PID,
+    CMD_ERR_INVALID_DID,
+    CMD_ERR_INVALID_NODE_NAME,
+    CMD_ERR_INVALID_PATH_NAME,
+    CMD_ERR_INVALID_PHYS,
+    CMD_ERR_INVALID_DHCP_IP,
+    CMD_ERR_INVALID_PORTS_N,
+    CMD_ERR_INVALID_PASSWORD_LEN,
+    CMD_ERR_INVALID_TYPE,
+    CMD_ERR_INVALID_TOS,
+    CMD_ERR_INVALID_TTL,
+    CMD_ERR_INVALID_VPROTO,
+    CMD_ERR_INVALID_VID,
+    CMD_ERR_INVALID_SESSION,
+    CMD_ERR_INVALID_WEIGHT,
+    CMD_ERR_INVALID_TIMEOUT,
+    CMD_ERR_INVALID_RTT,
+    CMD_ERR_INVALID_RTT_VAR,
+    CMD_ERR_PATH_USE_DHCP_NOT_IP,
+    CMD_ERR_PATH_USE_DHCP_NOT_IP_4,
+    CMD_ERR_PATH_USE_DHCP_NOT_IP_6,
+    CMD_ERR_NODE_EXIST,
+    CMD_ERR_NODE_DONT_EXIST,
+    CMD_ERR_NODE_IS_OFF,
+    CMD_ERR_NODE_IS_ON,
+    CMD_ERR_NODE_IS_SELF,
+    CMD_ERR_NODE_IS_STOPPING,
+    CMD_ERR_NODE_NOT_CONFIGURED,
+    CMD_ERR_PATH_EXIST,
+    CMD_ERR_PATH_DONT_EXIST,
+    CMD_ERR_PATH_IS_OFF,
+    CMD_ERR_PATH_IS_ON,
+    CMD_ERR_PATH_IS_STOPPING,
+    CMD_ERR_PATH_NEED_NAME,
+    CMD_ERR_PATH_NEED_CLT_SRV,
+    CMD_ERR_PATH_NEED_TIMEOUT,
+    CMD_ERR_PATH_NEED_LATENCY_MIN,
+    CMD_ERR_PATH_NEED_LATENCY_MAX,
+    CMD_ERR_PATH_NEED_RTT_VAR,
+    CMD_ERR_PATH_NEED_PHYS,
+    CMD_ERR_PATH_NEED_TOS,
+    CMD_ERR_PATH_NEED_TTL,
+    CMD_ERR_PATH_NEED_MAC_SRC,
+    CMD_ERR_PATH_NEED_MAC_DST,
+    CMD_ERR_PATH_NEED_ADDR_SRC,
+    CMD_ERR_PATH_NEED_ADDR_DST,
+    CMD_ERR_PATH_NEED_PORT_SRC,
+    CMD_ERR_PATH_NEED_PORT_DST,
+    CMD_ERR_PATH_NEED_VLAN_PROTO,
+    CMD_ERR_PATH_NEED_VLAN_ID,
+    CMD_ERR_PATH_NEED_PPP_SESSION,
+    CMD_ERR_PATH_NOT_SERVER,
+    CMD_ERR_PATH_NOT_ETH,
+    CMD_ERR_PATH_NOT_VLAN,
+    CMD_ERR_PATH_NOT_PPP,
+    CMD_ERR_PATH_NOT_IP,
+    CMD_ERR_PATH_NOT_IP4,
+    CMD_ERR_PATH_NOT_IP6,
+    CMD_ERR_PATH_NOT_UDP,
+    CMD_ERR_PATH_NOT_TCP,
+    CMD_ERR_PHYS_IS_BAD,
+    CMD_ERR_PHYS_IS_XGW,
+    CMD_ERR_PHYS_NOT_FOUND,
+    CMD_ERR_PHYS_NOT_HOOKED,
+    CMD_ERR_GWS_FULL,
+    CMD_ERR_GWS_NID_NOT_FOUND,
+    CMD_ERR_GWS_NID_ALREADY,
+    CMD_ERR_INVALID_CMD_CODE,
+    CMD_ERR_INVALID_CMD_SIZE,
+    CMD_ERR_COPY_CMD,
+) = range(CMD_ERRS_N)
+
+PASSWORD_SIZE_MAX = 65536
+
+CMD_SIZE_MIN = 1
+CMD_SIZE_MAX = 8 + PASSWORD_SIZE_MAX
+
+#############
+
+CMD_CODES = (
+    'PORT_ON',
+    'PORT_OFF',
+    'PORT_GET',
+
+    'PORTS_LIST',
+    'PORTS_CLEAR',
+
+    'PHYS_ATTACH',
+    'PHYS_DETACH',
+
+    'PHYS_LIST',
+
+    'SELF_SET',
+    'SELF_GET',
+
+    'GWS_INSERT',
+    'GWS_REMOVE',
+    'GWS_LIST',
+    'GWS_CLEAR',
+
+    'NODE_NEW',
+    'NODE_DEL',
+
+    'NODE_SET_NAME',
+    'NODE_SET_MTU',
+    'NODE_SET_CONNS_N',
+    'NODE_SET_SECRET',
+
+    'NODE_DEV_CREATE',
+    'NODE_DEV_DEL',
+
+    'NODE_CLR_NAME',
+    'NODE_CLR_SECRET',
+
+    'NODE_ON',
+    'NODE_OFF',
+
+    'NODE_STATUS',
+    'NODE_STATS',
+
+    'PATH_NEW',
+    'PATH_DEL',
+
+    'PATH_SET_NAME',
+    'PATH_SET_WEIGHT_NODE',
+    'PATH_SET_WEIGHT_ACKS',
+    'PATH_SET_CLIENT',
+    'PATH_SET_SERVER',
+    'PATH_SET_TIMEOUT',
+    'PATH_SET_RTT_VAR',
+    'PATH_SET_DHCP',
+    'PATH_SET_PHYS',
+    'PATH_SET_TYPE',
+    'PATH_SET_ETH_SRC',
+    'PATH_SET_ETH_DST',
+    'PATH_SET_VLAN_PROTO',
+    'PATH_SET_VLAN_ID',
+    'PATH_SET_IP4_TOS',
+    'PATH_SET_IP6_TOS',
+    'PATH_SET_IP4_TTL',
+    'PATH_SET_IP6_TTL',
+    'PATH_SET_IP4_SRC',
+    'PATH_SET_IP4_DST',
+    'PATH_SET_IP6_SRC',
+    'PATH_SET_IP6_DST',
+    'PATH_SET_UDP_SRC',
+    'PATH_SET_TCP_SRC',
+    'PATH_SET_UDP_DST',
+    'PATH_SET_TCP_DST',
+
+    'PATH_SET_PPP_SESSION',
+
+    'PATH_SET_IP_TOS',
+    'PATH_SET_IP_TTL',
+
+    'PATH_CLR_NAME',
+    'PATH_CLR_WEIGHT_NODE',
+    'PATH_CLR_WEIGHT_ACKS',
+    'PATH_CLR_DHCP',
+    'PATH_CLR_PHYS',
+    'PATH_CLR_TYPE',
+    'PATH_CLR_ETH_SRC',
+    'PATH_CLR_ETH_DST',
+    'PATH_CLR_VLAN_PROTO',
+    'PATH_CLR_VLAN_ID',
+    'PATH_CLR_IP4_TOS',
+    'PATH_CLR_IP6_TOS',
+    'PATH_CLR_IP4_TTL',
+    'PATH_CLR_IP6_TTL',
+    'PATH_CLR_IP4_SRC',
+    'PATH_CLR_IP4_DST',
+    'PATH_CLR_IP6_SRC',
+    'PATH_CLR_IP6_DST',
+    'PATH_CLR_UDP_SRC',
+    'PATH_CLR_TCP_SRC',
+    'PATH_CLR_UDP_DST',
+    'PATH_CLR_TCP_DST',
+
+    'PATH_ON',
+    'PATH_OFF',
+
+    'PATH_STATUS',
+    'PATH_STATS',
+
+    'STATS',
+
+    'NMAP',
+)
+
+CMD_ERRS = (
+    'CMD_ERR_ALLOC_CMD',
+    'CMD_ERR_ALLOC_CONNS',
+    'CMD_ERR_ALLOC_NODE',
+    'CMD_ERR_INVALID_CONNS_N',
+    'CMD_ERR_INVALID_MTU',
+    'CMD_ERR_INVALID_NID',
+    'CMD_ERR_INVALID_PID',
+    'CMD_ERR_INVALID_DID',
+    'CMD_ERR_INVALID_NODE_NAME',
+    'CMD_ERR_INVALID_PATH_NAME',
+    'CMD_ERR_INVALID_PHYS',
+    'CMD_ERR_INVALID_DHCP_IP',
+    'CMD_ERR_INVALID_PORTS_N',
+    'CMD_ERR_INVALID_PASSWORD_LEN',
+    'CMD_ERR_INVALID_TYPE',
+    'CMD_ERR_INVALID_TOS',
+    'CMD_ERR_INVALID_TTL',
+    'CMD_ERR_INVALID_VPROTO',
+    'CMD_ERR_INVALID_VID',
+    'CMD_ERR_INVALID_SESSION',
+    'CMD_ERR_INVALID_WEIGHT',
+    'CMD_ERR_INVALID_TIMEOUT',
+    'CMD_ERR_INVALID_RTT',
+    'CMD_ERR_INVALID_RTT_VAR',
+    'CMD_ERR_PATH_USE_DHCP_NOT_IP',
+    'CMD_ERR_PATH_USE_DHCP_NOT_IP_4',
+    'CMD_ERR_PATH_USE_DHCP_NOT_IP_6',
+    'CMD_ERR_NODE_EXIST',
+    'CMD_ERR_NODE_DONT_EXIST',
+    'CMD_ERR_NODE_IS_OFF',
+    'CMD_ERR_NODE_IS_ON',
+    'CMD_ERR_NODE_IS_SELF',
+    'CMD_ERR_NODE_IS_STOPPING',
+    'CMD_ERR_NODE_NOT_CONFIGURED',
+    'CMD_ERR_PATH_EXIST',
+    'CMD_ERR_PATH_DONT_EXIST',
+    'CMD_ERR_PATH_IS_OFF',
+    'CMD_ERR_PATH_IS_ON',
+    'CMD_ERR_PATH_IS_STOPPING',
+    'CMD_ERR_PATH_NEED_NAME',
+    'CMD_ERR_PATH_NEED_CLT_SRV',
+    'CMD_ERR_PATH_NEED_TIMEOUT',
+    'CMD_ERR_PATH_NEED_LATENCY_MIN',
+    'CMD_ERR_PATH_NEED_LATENCY_MAX',
+    'CMD_ERR_PATH_NEED_RTT_VAR',
+    'CMD_ERR_PATH_NEED_PHYS',
+    'CMD_ERR_PATH_NEED_TOS',
+    'CMD_ERR_PATH_NEED_TTL',
+    'CMD_ERR_PATH_NEED_MAC_SRC',
+    'CMD_ERR_PATH_NEED_MAC_DST',
+    'CMD_ERR_PATH_NEED_ADDR_SRC',
+    'CMD_ERR_PATH_NEED_ADDR_DST',
+    'CMD_ERR_PATH_NEED_PORT_SRC',
+    'CMD_ERR_PATH_NEED_PORT_DST',
+    'CMD_ERR_PATH_NEED_VLAN_PROTO',
+    'CMD_ERR_PATH_NEED_VLAN_ID',
+    'CMD_ERR_PATH_NEED_PPP_SESSION',
+    'CMD_ERR_PATH_NOT_SERVER',
+    'CMD_ERR_PATH_NOT_ETH',
+    'CMD_ERR_PATH_NOT_VLAN',
+    'CMD_ERR_PATH_NOT_PPP',
+    'CMD_ERR_PATH_NOT_IP',
+    'CMD_ERR_PATH_NOT_IP4',
+    'CMD_ERR_PATH_NOT_IP6',
+    'CMD_ERR_PATH_NOT_UDP',
+    'CMD_ERR_PATH_NOT_TCP',
+    'CMD_ERR_PHYS_IS_BAD',
+    'CMD_ERR_PHYS_IS_XGW',
+    'CMD_ERR_PHYS_NOT_FOUND',
+    'CMD_ERR_PHYS_NOT_HOOKED',
+    'CMD_ERR_GWS_FULL',
+    'CMD_ERR_GWS_NID_NOT_FOUND',
+    'CMD_ERR_GWS_NID_ALREADY',
+    'CMD_ERR_INVALID_CMD_CODE',
+    'CMD_ERR_INVALID_CMD_SIZE',
+    'CMD_ERR_COPY_CMD',
+    'OK'
+)
+
+assert len(CMD_CODES) ==  CMDS_N
+assert len(CMD_ERRS)  == (CMD_ERRS_N + 1)
+
+__ETH  = (1 << 0)
+__VLAN = (1 << 1)
+__IP4  = (1 << 2)
+__IP6  = (1 << 3)
+__TCP  = (1 << 4)
+__UDP  = (1 << 5)
+__PPP  = (1 << 6)
+
+typesNames = {
+    'raw'              : 0,
+    'ip4'              : __IP4,
+    'ip4-udp'          : __IP4  | __UDP,
+    'ip4-tcp'          : __IP4  | __TCP,
+    'ip6'              : __IP6,
+    'ip6-udp'          : __IP6  | __UDP,
+    'ip6-tcp'          : __IP6  | __TCP,
+    'eth'              : __ETH,
+    'eth-ip4'          : __ETH  | __IP4,
+    'eth-ip4-udp'      : __ETH  | __IP4   | __UDP,
+    'eth-ip4-tcp'      : __ETH  | __IP4   | __TCP,
+    'eth-ip6'          : __ETH  | __IP6,
+    'eth-ip6-udp'      : __ETH  | __IP6   | __UDP,
+    'eth-ip6-tcp'      : __ETH  | __IP6   | __TCP,
+    'eth-vlan'         : __ETH  | __VLAN,
+    'eth-vlan-ip4'     : __ETH  | __VLAN  | __IP4,
+    'eth-vlan-ip4-udp' : __ETH  | __VLAN  | __IP4  | __UDP,
+    'eth-vlan-ip4-tcp' : __ETH  | __VLAN  | __IP4  | __TCP,
+    'eth-vlan-ip6'     : __ETH  | __VLAN  | __IP6,
+    'eth-vlan-ip6-udp' : __ETH  | __VLAN  | __IP6  | __UDP,
+    'eth-vlan-ip6-tcp' : __ETH  | __VLAN  | __IP6  | __TCP,
+    'eth-vlan-ppp'     : __ETH  | __VLAN | __PPP,
+    'eth-vlan-ppp-ip4' : __ETH  | __VLAN | __PPP  | __IP4,
+    'eth-vlan-ppp-ip6' : __ETH  | __VLAN | __PPP  | __IP6,
+    'eth-ppp'          : __ETH  | __PPP,
+    'eth-ppp-ip4'      : __ETH  | __PPP  | __IP4,
+    'eth-ppp-ip6'      : __ETH  | __PPP  | __IP6,
+}
+
+#############
+
+# !!!
+ENDIANESS = 'little'
+
+def U64 (v):
+    assert 0 <= v <= ((1 << 64) - 1)
+    return v.to_bytes(length=8, signed=False, byteorder=ENDIANESS)
+
+def U32 (v):
+    assert 0 <= v <= ((1 << 32) - 1)
+    return v.to_bytes(length=4, signed=False, byteorder=ENDIANESS)
+
+def U16 (v):
+    assert 0 <= v <= ((1 << 16) - 1)
+    return v.to_bytes(length=2, signed=False, byteorder=ENDIANESS)
+
+def U8 (v):
+    assert 0 <= v <= ((1 << 8) - 1)
+    return v.to_bytes(length=1, signed=False, byteorder=ENDIANESS)
+
+def STR (s, L):
+    s = s.encode()
+    s += (b'\x00' * (L - len(s)))
+    assert len(s) == L
+    return s
+
+def PORTS (ports):
+    ports = [int(p) for p in ports.split(',')]
+    assert 1 <= len(ports) < PORTS_N
+    assert all((0 <= p <= 0xFFFF) for p in ports)
+    return b''.join(p.to_bytes(length=2, signed=False, byteorder=ENDIANESS) for p in ports)
+
+def PHYS (phys):
+    assert 1 <= len(phys) < IFNAMSIZ
+    return STR(phys, IFNAMSIZ)
+
+def MAC (mac):
+    assert len(mac) == len('XX:XX:XX:XX:XX:XX'), mac
+    assert mac.count(':') == 'XX:XX:XX:XX:XX:XX'.count(':'), mac
+    return b''.join(int(b, 16).to_bytes(length=1, signed=False, byteorder='big') for b in mac.split(':'))
+
+def IP4 (addr):
+    assert addr.count('.') == 3, addr
+    # if True: # LITTLE ENDIAN
+        # return sum((int(x) << (8*(i))) for i, x in enumerate(addr.split('.')))
+    # return sum((int(x) << (32 - 8*(i+1))) for i, x in enumerate(addr.split('.')))
+    addr = [int(b, 10) for b in addr.split('.')]
+    assert len(addr) == 4
+    assert all((0 <= b <= 255) for b in addr)
+    return b''.join(b.to_bytes(length=1, signed=False, byteorder='big') for b in addr)
+
+
+def IP6 (addr):
+    return ipaddress.IPv6Address(addr).packed
+
+def oswrite (fd, msg):
+    try:
+        assert os.write(fd, msg) == len(msg)
+        return CMD_ERRS_N
+    except OSError as e:
+        # LEMBRANDO QUE ESTE ERRNO É O VALOR RETORNADO PELA FUNCAO EM C, POSITIVADO
+        return (-e.errno) + 200
+
+def COMM (code, *args):
+
+    assert isinstance(code, int) and 0 <= code < CMDS_N
+
+    assert all(isinstance(a, bytes) for a in args)
+
+    cmd = b''.join((U8(code), *args))
+
+    binsizes.append(len(cmd))
+
+    while (e := oswrite(fd, cmd)) in (
+        CMD_ERR_NODE_IS_STOPPING,
+        CMD_ERR_PATH_IS_STOPPING
+    ): time.sleep(0.4)
+
+    print(CMD_CODES[code], '->', CMD_ERRS[e], binascii.hexlify(cmd[:32], sep='|', bytes_per_sep=8).decode())
+
+binsizes = []
+
+xpath = os.getenv('XGW_PATH', '/proc/xgw')
+
+fd = os.open(xpath, os.O_WRONLY | os.O_CREAT, 0o0644)
+
+args = list(sys.argv)
+args.pop(0)
+
+port = phys = nid = pid = None
+
+while args:
+
+    name = v = None
+
+    name = args.pop(0)
+
+    match name:
+        case 'stats':
+            COMM(CMD_STATS)
+        case 'self-set':
+            v = int(args.pop(0))
+            assert 0 <= v < NODES_N
+            COMM(CMD_SELF_SET, U16(v))
+        case 'self-get':
+            COMM(CMD_SELF_GET)
+        case 'gws-insert':
+            v = int(args.pop(0))
+            assert 0 <= v < NODES_N
+            COMM(CMD_GWS_INSERT, U16(v))
+        case 'gws-remove':
+            v = int(args.pop(0))
+            assert 0 <= v < NODES_N
+            COMM(CMD_GWS_REMOVE, U16(v))
+        case 'gws-list':
+            COMM(CMD_GWS_LIST)
+        case 'sleep':
+            v = float(args.pop(0))
+            assert 0 <= v <= 24*60*60
+            print(f'SLEEPING FOR {v} SECONDS...')
+            time.sleep(v)
+        case 'port':
+            phys = nid = pid = None
+            port = PORTS(args.pop(0))
+        case 'phys':
+            port = nid = pid = None
+            phys = PHYS(args.pop(0))
+        case 'node':
+            port = phys = pid = None
+            nid  = int(args.pop(0))
+            assert 0 <= nid < NODES_N
+            nid = U16(nid)
+        case 'path':
+            phys = port = None
+            assert nid is not None
+            pid  = int(args.pop(0))
+            assert 0 <= pid < PATHS_N
+            pid = U8(pid)
+        case 'attach':
+            assert port is nid is pid is None
+            assert phys
+            COMM(CMD_PHYS_ATTACH, phys)
+        case 'detach':
+            assert port is nid is pid is None
+            assert phys
+            COMM(CMD_PHYS_DETACH, phys)
+        case 'clt':
+            COMM(CMD_PATH_SET_CLIENT, nid, pid)
+        case 'srv':
+            COMM(CMD_PATH_SET_SERVER, nid, pid)
+        case 'create':
+            if pid is not None:
+                COMM(CMD_PATH_NEW, nid, pid)
+            elif nid is not None:
+                COMM(CMD_NODE_NEW, nid)
+            else:
+                assert False
+        case 'on':
+            if port is not None:
+                COMM(CMD_PORT_ON, port)
+            elif pid is not None:
+                COMM(CMD_PATH_ON, nid, pid)
+            elif nid is not None:
+                COMM(CMD_NODE_ON, nid)
+            else:
+                assert False
+        case 'off':
+            if port is not None:
+                COMM(CMD_PORT_OFF, port)
+            elif pid is not None:
+                COMM(CMD_PATH_OFF, nid, pid)
+            elif nid is not None:
+                COMM(CMD_NODE_OFF, nid)
+            else:
+                assert False
+        case 'del':
+            if pid is not None:
+                COMM(CMD_PATH_DEL, nid, pid)
+                pid = None
+            elif nid is not None:
+                COMM(CMD_NODE_DEL, nid)
+                nid = None
+            else:
+                assert False
+        case 'status':
+            if pid is not None:
+                COMM(CMD_PATH_STATUS, nid, pid)
+            elif nid is not None:
+                COMM(CMD_NODE_STATUS, nid)
+            else:
+                assert False
+        case 'dev-del':
+            assert nid is not None
+            COMM(CMD_NODE_DEV_DEL, nid)
+        case 'nmap':
+            assert nid is not None
+            nid2  = int(args.pop(0))
+            assert 0 <= nid2 < NODES_N
+            COMM(CMD_NMAP, nid, U16(nid2))
+        case _:
+
+            assert '=' in name, name
+
+            name, v = name.split('=', 1)
+
+            match name:
+                case 'dev-create':
+                    assert nid is not None
+                    COMM(CMD_NODE_DEV_CREATE, nid, STR(v, IFNAMSIZ))
+                case 'name':
+                    if pid is not None:
+                        COMM(CMD_PATH_SET_NAME, nid, pid, STR(v, PATH_NAME_SIZE))
+                    elif nid is not None:
+                        COMM(CMD_NODE_SET_NAME, nid, STR(v, NODE_NAME_SIZE))
+                    else:
+                        assert False
+                case 'mtu':
+                    v = int(v)
+                    assert _MTU_MIN <= v <= _MTU_MAX
+                    COMM(CMD_NODE_SET_MTU, nid, U16(v))
+                case 'timeout':
+                    v = int(v)
+                    assert PATH_TIMEOUT_MIN <= v <= PATH_TIMEOUT_MAX
+                    COMM(CMD_PATH_SET_TIMEOUT, nid, pid, U16(v))
+                case 'rtt-var':
+                    v = int(v)
+                    assert 0 <= v <= 1000
+                    COMM(CMD_PATH_SET_RTT_VAR, nid, pid, U16(v))
+                case 'conns-n':
+                    v = int(v)
+                    assert _CONNS_MIN <= v <= _CONNS_MAX
+                    COMM(CMD_NODE_SET_CONNS_N, nid, U32(v))
+                case 'secret-str':
+                    v = v.encode()
+                    assert 1 <= len(v) <= PASSWORD_SIZE_MAX
+                    COMM(CMD_NODE_SET_SECRET, nid, v)
+                case 'secret-base64':
+                    v = base64.b64decode(v)
+                    assert 1 <= len(v) <= PASSWORD_SIZE_MAX
+                    COMM(CMD_NODE_SET_SECRET, nid, v)
+                case 'secret-hex':
+                    v = int(v, 16).to_bytes(length=(len(v)//2 + len(v)%2), byteorder='big', signed=False)
+                    assert 1 <= len(v) <= PASSWORD_SIZE_MAX
+                    COMM(CMD_NODE_SET_SECRET, nid, v)
+                case 'secret-file':
+                    v = open(v, 'rb').read(PASSWORD_SIZE_MAX + 1)
+                    assert 1 <= len(v) <= PASSWORD_SIZE_MAX
+                    COMM(CMD_NODE_SET_SECRET, nid, v)
+                case 'weight-acks':
+                    v = int(v)
+                    assert 0 <= v <= 0xFF
+                    COMM(CMD_PATH_SET_WEIGHT_ACKS, nid, pid, U8(v))
+                case 'weight-node':
+                    v = int(v)
+                    assert 0 <= v <= 0xFF
+                    COMM(CMD_PATH_SET_WEIGHT_NODE, nid, pid, U8(v))
+                case 'vlan-proto':
+                    ETH_P_8021AD = 0x88A8
+                    ETH_P_8021Q  = 0x8100
+                    if v in ('8021q', '8021Q'):
+                        v = ETH_P_8021Q
+                    elif v in ('8021ad', '8021AD'):
+                        v = ETH_P_8021AD
+                    else:
+                        v = int(v)
+                    assert 0 <= v <= 0xFFFF
+                    COMM(CMD_PATH_SET_VLAN_PROTO, nid, pid, U16(v))
+                case 'vlan-id':
+                    v = int(v)
+                    assert 0 <= v <= 4095
+                    COMM(CMD_PATH_SET_VLAN_ID, nid, pid, U16(v))
+                case 'ppp-session':
+                    v = int(v)
+                    assert 0 <= v <= 0xFFFF
+                    COMM(CMD_PATH_SET_PPP_SESSION, nid, pid, U16(v))
+                case 'eth-dst':
+                    COMM(CMD_PATH_SET_ETH_DST, nid, pid, MAC(v))
+                case 'eth-src':
+                    COMM(CMD_PATH_SET_ETH_SRC, nid, pid, MAC(v))
+                case 'ip4-tos':
+                    assert v.startswith('0x')
+                    v = int(v[2:], 16)
+                    assert 0 <= v <= TOS_MAX
+                    COMM(CMD_PATH_SET_IP4_TOS, nid, pid, U8(v))
+                case 'ip6-tos':
+                    assert v.startswith('0x')
+                    v = int(v[2:], 16)
+                    assert 0 <= v <= TOS_MAX
+                    COMM(CMD_PATH_SET_IP6_TOS, nid, pid, U8(v))
+                case 'ip4-ttl':
+                    v = int(v)
+                    assert _TTL_MIN <= v <= _TTL_MAX
+                    COMM(CMD_PATH_SET_IP4_TTL, nid, pid, U8(v))
+                case 'ip6-ttl':
+                    v = int(v)
+                    assert _TTL_MIN <= v <= _TTL_MAX
+                    COMM(CMD_PATH_SET_IP6_TTL, nid, pid, U8(v))
+                case 'ip4-src':
+                    COMM(CMD_PATH_SET_IP4_SRC, nid, pid, IP4(v))
+                case 'ip4-dst':
+                    COMM(CMD_PATH_SET_IP4_DST, nid, pid, IP4(v))
+                case 'ip6-src':
+                    COMM(CMD_PATH_SET_IP6_SRC, nid, pid, IP6(v))
+                case 'ip6-dst':
+                    COMM(CMD_PATH_SET_IP6_DST, nid, pid, IP6(v))
+                case 'udp-src':
+                    COMM(CMD_PATH_SET_UDP_SRC, nid, pid, PORTS(v))
+                case 'udp-dst':
+                    COMM(CMD_PATH_SET_UDP_DST, nid, pid, PORTS(v))
+                case 'tcp-src':
+                    COMM(CMD_PATH_SET_TCP_SRC, nid, pid, PORTS(v))
+                case 'tcp-dst':
+                    COMM(CMD_PATH_SET_TCP_DST, nid, pid, PORTS(v))
+                case 'phys':
+                    COMM(CMD_PATH_SET_PHYS, nid, pid, PHYS(v))
+                case 'type':
+                    COMM(CMD_PATH_SET_TYPE, nid, pid, U8(typesNames[v]))
+                case 'ip-tos':
+                    assert v.startswith('0x')
+                    v = int(v[2:], 16)
+                    assert 0 <= v <= TOS_MAX
+                    COMM(CMD_PATH_SET_IP_TOS, nid, pid, U8(v))
+                case 'ip-ttl':
+                    v = int(v)
+                    assert _TTL_MIN <= v <= _TTL_MAX
+                    COMM(CMD_PATH_SET_IP_TTL, nid, pid, U8(v))
+                case _:
+                    assert False, (name, v)
+
+if os.getenv('XGW_PATH', ''):
+    open(f'{xpath}.sizes', 'w').write(' '.join(map(str, binsizes)))
+
+'''
+for S in $(cat /xgw.sizes) ; do
+    dd bs=${S} count=1
+done < /xgw.bin > /proc/xgw
+'''
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/pci/hotplug/Kconfig linux-master/drivers/pci/hotplug/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/pci/hotplug/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/pci/hotplug/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -172,15 +172,4 @@
 
 	  When in doubt, say N.
 
-config HOTPLUG_PCI_S390
-	bool "System z PCI Hotplug Support"
-	depends on S390 && 64BIT
-	help
-	  Say Y here if you want to use the System z PCI Hotplug
-	  driver for PCI devices. Without this driver it is not
-	  possible to access stand-by PCI functions nor to deconfigure
-	  PCI functions.
-
-	  When in doubt, say Y.
-
 endif # HOTPLUG_PCI
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/pci/hotplug/Makefile linux-master/drivers/pci/hotplug/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/pci/hotplug/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/pci/hotplug/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -19,7 +19,6 @@
 obj-$(CONFIG_HOTPLUG_PCI_RPA)		+= rpaphp.o
 obj-$(CONFIG_HOTPLUG_PCI_RPA_DLPAR)	+= rpadlpar_io.o
 obj-$(CONFIG_HOTPLUG_PCI_ACPI)		+= acpiphp.o
-obj-$(CONFIG_HOTPLUG_PCI_S390)		+= s390_pci_hpc.o
 obj-$(CONFIG_HOTPLUG_PCI_OCTEONEP)	+= octep_hp.o
 
 # acpiphp_ibm extends acpiphp, so should be linked afterwards.
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/ptp/Makefile linux-master/drivers/ptp/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/ptp/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/ptp/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -20,5 +20,4 @@
 obj-$(CONFIG_PTP_1588_CLOCK_VMW)	+= ptp_vmw.o
 obj-$(CONFIG_PTP_1588_CLOCK_OCP)	+= ptp_ocp.o
 obj-$(CONFIG_PTP_DFL_TOD)		+= ptp_dfl_tod.o
-obj-$(CONFIG_PTP_S390)			+= ptp_s390.o
 obj-$(CONFIG_PTP_NETC_V4_TIMER)		+= ptp_netc.o
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/scsi/iscsi_tcp.c linux-master/drivers/scsi/iscsi_tcp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/scsi/iscsi_tcp.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/scsi/iscsi_tcp.c	2025-10-20 00:41:14.000000000 -0300
@@ -273,7 +273,6 @@
 	sk->sk_data_ready   = tcp_sw_conn->old_data_ready;
 	sk->sk_state_change = tcp_sw_conn->old_state_change;
 	sk->sk_write_space  = tcp_sw_conn->old_write_space;
-	sk->sk_no_check_tx = 0;
 	write_unlock_bh(&sk->sk_callback_lock);
 }
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/watchdog/Makefile linux-master/drivers/watchdog/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/drivers/watchdog/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/drivers/watchdog/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -159,13 +159,6 @@
 obj-$(CONFIG_KEEMBAY_WATCHDOG) += keembay_wdt.o
 obj-$(CONFIG_SIEMENS_SIMATIC_IPC_WDT) += simatic-ipc-wdt.o
 
-# M68K Architecture
-obj-$(CONFIG_M54xx_WATCHDOG) += m54xx_wdt.o
-
-# MicroBlaze Architecture
-obj-$(CONFIG_XILINX_WATCHDOG) += of_xilinx_wdt.o
-obj-$(CONFIG_XILINX_WINDOW_WATCHDOG) += xilinx_wwdt.o
-
 # MIPS Architecture
 obj-$(CONFIG_ATH79_WDT) += ath79_wdt.o
 obj-$(CONFIG_BCM47XX_WDT) += bcm47xx_wdt.o
@@ -186,38 +179,16 @@
 obj-$(CONFIG_PIC32_DMT) += pic32-dmt.o
 obj-$(CONFIG_REALTEK_OTTO_WDT) += realtek_otto_wdt.o
 
-# PARISC Architecture
-
-# POWERPC Architecture
-obj-$(CONFIG_GEF_WDT) += gef_wdt.o
-obj-$(CONFIG_8xxx_WDT) += mpc8xxx_wdt.o
-obj-$(CONFIG_PIKA_WDT) += pika_wdt.o
-obj-$(CONFIG_BOOKE_WDT) += booke_wdt.o
-obj-$(CONFIG_MEN_A21_WDT) += mena21_wdt.o
-
-# PPC64 Architecture
-obj-$(CONFIG_PSERIES_WDT) += pseries-wdt.o
-obj-$(CONFIG_WATCHDOG_RTAS) += wdrtas.o
-
 # RISC-V Architecture
 obj-$(CONFIG_STARFIVE_WATCHDOG) += starfive-wdt.o
 
-# S390 Architecture
-obj-$(CONFIG_DIAG288_WATCHDOG) += diag288_wdt.o
-
 # SUPERH (sh + sh64) Architecture
 obj-$(CONFIG_SH_WDT) += shwdt.o
 
-# SPARC Architecture
-
-# SPARC64 Architecture
-
 obj-$(CONFIG_WATCHDOG_RIO)		+= riowd.o
 obj-$(CONFIG_WATCHDOG_CP1XXX)		+= cpwd.o
 obj-$(CONFIG_WATCHDOG_SUN4V)		+= sun4v_wdt.o
 
-# XTENSA Architecture
-
 # Xen
 obj-$(CONFIG_XEN_WDT) += xen_wdt.o
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/fs/Kconfig linux-master/fs/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/fs/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/fs/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -43,13 +43,9 @@
 	default y if EXT4_FS=y
 	default m if EXT2_FS_XATTR || EXT4_FS
 
-source "fs/jfs/Kconfig"
 
 source "fs/xfs/Kconfig"
-source "fs/gfs2/Kconfig"
-source "fs/ocfs2/Kconfig"
 source "fs/btrfs/Kconfig"
-source "fs/nilfs2/Kconfig"
 source "fs/f2fs/Kconfig"
 source "fs/zonefs/Kconfig"
 
@@ -310,8 +306,6 @@
 source "fs/adfs/Kconfig"
 source "fs/affs/Kconfig"
 source "fs/ecryptfs/Kconfig"
-source "fs/hfs/Kconfig"
-source "fs/hfsplus/Kconfig"
 source "fs/befs/Kconfig"
 source "fs/bfs/Kconfig"
 source "fs/efs/Kconfig"
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/fs/Makefile linux-master/fs/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/fs/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/fs/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -78,8 +78,6 @@
 obj-$(CONFIG_EXFAT_FS)		+= exfat/
 obj-$(CONFIG_BFS_FS)		+= bfs/
 obj-$(CONFIG_ISO9660_FS)	+= isofs/
-obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
-obj-$(CONFIG_HFS_FS)		+= hfs/
 obj-$(CONFIG_ECRYPT_FS)		+= ecryptfs/
 obj-$(CONFIG_VXFS_FS)		+= freevxfs/
 obj-$(CONFIG_NFS_FS)		+= nfs/
@@ -107,19 +105,15 @@
 obj-$(CONFIG_UDF_FS)		+= udf/
 obj-$(CONFIG_SUN_OPENPROMFS)	+= openpromfs/
 obj-$(CONFIG_OMFS_FS)		+= omfs/
-obj-$(CONFIG_JFS_FS)		+= jfs/
 obj-$(CONFIG_XFS_FS)		+= xfs/
 obj-$(CONFIG_9P_FS)		+= 9p/
 obj-$(CONFIG_AFS_FS)		+= afs/
-obj-$(CONFIG_NILFS2_FS)		+= nilfs2/
 obj-$(CONFIG_BEFS_FS)		+= befs/
 obj-y				+= hostfs/
 obj-$(CONFIG_CACHEFILES)	+= cachefiles/
 obj-$(CONFIG_DEBUG_FS)		+= debugfs/
 obj-$(CONFIG_TRACING)		+= tracefs/
-obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
 obj-$(CONFIG_BTRFS_FS)		+= btrfs/
-obj-$(CONFIG_GFS2_FS)           += gfs2/
 obj-$(CONFIG_F2FS_FS)		+= f2fs/
 obj-$(CONFIG_CEPH_FS)		+= ceph/
 obj-$(CONFIG_PSTORE)		+= pstore/
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/bpf.h linux-master/include/linux/bpf.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/bpf.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/bpf.h	2025-10-20 00:41:14.000000000 -0300
@@ -3531,7 +3531,6 @@
 extern const struct bpf_func_proto bpf_skc_to_tcp_request_sock_proto;
 extern const struct bpf_func_proto bpf_skc_to_udp6_sock_proto;
 extern const struct bpf_func_proto bpf_skc_to_unix_sock_proto;
-extern const struct bpf_func_proto bpf_skc_to_mptcp_sock_proto;
 extern const struct bpf_func_proto bpf_copy_from_user_proto;
 extern const struct bpf_func_proto bpf_snprintf_btf_proto;
 extern const struct bpf_func_proto bpf_snprintf_proto;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/btf_ids.h linux-master/include/linux/btf_ids.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/btf_ids.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/btf_ids.h	2025-10-20 00:41:14.000000000 -0300
@@ -254,7 +254,6 @@
 	BTF_SOCK_TYPE(BTF_SOCK_TYPE_UDP, udp_sock)			\
 	BTF_SOCK_TYPE(BTF_SOCK_TYPE_UDP6, udp6_sock)			\
 	BTF_SOCK_TYPE(BTF_SOCK_TYPE_UNIX, unix_sock)			\
-	BTF_SOCK_TYPE(BTF_SOCK_TYPE_MPTCP, mptcp_sock)			\
 	BTF_SOCK_TYPE(BTF_SOCK_TYPE_SOCKET, socket)
 
 enum {
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/if_vlan.h linux-master/include/linux/if_vlan.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/if_vlan.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/if_vlan.h	2025-10-20 00:41:14.000000000 -0300
@@ -79,7 +79,11 @@
 /* found in socket.c */
 extern void vlan_ioctl_set(int (*hook)(struct net *, void __user *));
 
+#ifdef CONFIG_VLAN_CORE
 #define skb_vlan_tag_present(__skb)	(!!(__skb)->vlan_all)
+#else
+#define skb_vlan_tag_present(__skb) 0
+#endif
 #define skb_vlan_tag_get(__skb)		((__skb)->vlan_tci)
 #define skb_vlan_tag_get_id(__skb)	((__skb)->vlan_tci & VLAN_VID_MASK)
 #define skb_vlan_tag_get_cfi(__skb)	(!!((__skb)->vlan_tci & VLAN_CFI_MASK))
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/in.h linux-master/include/linux/in.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/in.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/in.h	2025-10-20 00:41:14.000000000 -0300
@@ -26,7 +26,6 @@
 	case IPPROTO_DCCP:
 	case IPPROTO_ESP:	/* SPI */
 	case IPPROTO_SCTP:
-	case IPPROTO_UDPLITE:
 		return 0;
 	case IPPROTO_AH:	/* SPI */
 		return 4;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/lsm_hook_defs.h linux-master/include/linux/lsm_hook_defs.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/lsm_hook_defs.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/lsm_hook_defs.h	2025-10-20 00:41:14.000000000 -0300
@@ -375,7 +375,6 @@
 	 struct sock *sk, struct sock *newsk)
 LSM_HOOK(int, 0, sctp_assoc_established, struct sctp_association *asoc,
 	 struct sk_buff *skb)
-LSM_HOOK(int, 0, mptcp_add_subflow, struct sock *sk, struct sock *ssk)
 #endif /* CONFIG_SECURITY_NETWORK */
 
 #ifdef CONFIG_SECURITY_INFINIBAND
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/netdevice.h linux-master/include/linux/netdevice.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/netdevice.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/netdevice.h	2025-10-20 00:41:14.000000000 -0300
@@ -160,6 +160,11 @@
  *	used.
  */
 
+#ifdef CONFIG_XGW
+#define LL_MAX_HEADER 196
+#define MAX_HEADER (196 + 48)
+#else
+
 #if defined(CONFIG_HYPERV_NET)
 # define LL_MAX_HEADER 128
 #elif defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)
@@ -179,6 +184,8 @@
 #define MAX_HEADER (LL_MAX_HEADER + 48)
 #endif
 
+#endif
+
 /*
  *	Old network device statistics. Fields are native words
  *	(unsigned long) so they can be read and written atomically.
@@ -2098,6 +2105,7 @@
 		unsigned long		priv_flags:32;
 		unsigned long		lltx:1;
 		unsigned long		netmem_tx:1;
+		unsigned long		xgw:1;
 	);
 	const struct net_device_ops *netdev_ops;
 	const struct header_ops *header_ops;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/netfilter/ipset/ip_set_getport.h linux-master/include/linux/netfilter/ipset/ip_set_getport.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/netfilter/ipset/ip_set_getport.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/netfilter/ipset/ip_set_getport.h	2025-10-20 00:41:14.000000000 -0300
@@ -26,7 +26,6 @@
 	case IPPROTO_TCP:
 	case IPPROTO_SCTP:
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE:
 		return true;
 	}
 	return false;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/security.h linux-master/include/linux/security.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/security.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/security.h	2025-10-20 00:41:14.000000000 -0300
@@ -1692,7 +1692,6 @@
 			    struct sock *newsk);
 int security_sctp_assoc_established(struct sctp_association *asoc,
 				    struct sk_buff *skb);
-int security_mptcp_add_subflow(struct sock *sk, struct sock *ssk);
 
 #else	/* CONFIG_SECURITY_NETWORK */
 static inline int security_netlink_send(struct sock *sk, struct sk_buff *skb)
@@ -1926,10 +1925,6 @@
 	return 0;
 }
 
-static inline int security_mptcp_add_subflow(struct sock *sk, struct sock *ssk)
-{
-	return 0;
-}
 #endif	/* CONFIG_SECURITY_NETWORK */
 
 #ifdef CONFIG_SECURITY_INFINIBAND
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/skbuff.h linux-master/include/linux/skbuff.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/skbuff.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/skbuff.h	2025-10-20 00:41:14.000000000 -0300
@@ -4246,7 +4246,9 @@
 struct sk_buff *skb_segment(struct sk_buff *skb, netdev_features_t features);
 struct sk_buff *skb_segment_list(struct sk_buff *skb, netdev_features_t features,
 				 unsigned int offset);
+#ifdef CONFIG_VLAN_CORE
 struct sk_buff *skb_vlan_untag(struct sk_buff *skb);
+#endif
 int skb_ensure_writable(struct sk_buff *skb, unsigned int write_len);
 int skb_ensure_writable_head_tail(struct sk_buff *skb, struct net_device *dev);
 int __skb_vlan_pop(struct sk_buff *skb, u16 *vlan_tci);
@@ -4902,9 +4904,6 @@
 #if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
 	TC_SKB_EXT,
 #endif
-#if IS_ENABLED(CONFIG_MPTCP)
-	SKB_EXT_MPTCP,
-#endif
 #if IS_ENABLED(CONFIG_MCTP_FLOWS)
 	SKB_EXT_MCTP,
 #endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/socket.h linux-master/include/linux/socket.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/socket.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/socket.h	2025-10-20 00:41:14.000000000 -0300
@@ -330,7 +330,6 @@
 #define MSG_SOCK_DEVMEM 0x2000000	/* Receive devmem skbs as cmsg */
 #define MSG_ZEROCOPY	0x4000000	/* Use user data in kernel path */
 #define MSG_SPLICE_PAGES 0x8000000	/* Splice the pages from the iterator in sendmsg() */
-#define MSG_FASTOPEN	0x20000000	/* Send data in TCP SYN */
 #define MSG_CMSG_CLOEXEC 0x40000000	/* Set close_on_exec for file
 					   descriptor received through
 					   SCM_RIGHTS */
@@ -352,7 +351,6 @@
 #define SOL_IPV6	41
 #define SOL_ICMPV6	58
 #define SOL_SCTP	132
-#define SOL_UDPLITE	136     /* UDP-Lite (RFC 3828) */
 #define SOL_RAW		255
 #define SOL_IPX		256
 #define SOL_AX25	257
@@ -382,7 +380,6 @@
 #define SOL_KCM		281
 #define SOL_TLS		282
 #define SOL_XDP		283
-#define SOL_MPTCP	284
 #define SOL_MCTP	285
 #define SOL_SMC		286
 #define SOL_VSOCK	287
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/tcp.h linux-master/include/linux/tcp.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/tcp.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/tcp.h	2025-10-20 00:41:14.000000000 -0300
@@ -81,18 +81,6 @@
 	return (tcp_hdr(skb)->doff - 5) * 4;
 }
 
-/* TCP Fast Open */
-#define TCP_FASTOPEN_COOKIE_MIN	4	/* Min Fast Open Cookie size in bytes */
-#define TCP_FASTOPEN_COOKIE_MAX	16	/* Max Fast Open Cookie size in bytes */
-#define TCP_FASTOPEN_COOKIE_SIZE 8	/* the size employed by this impl. */
-
-/* TCP Fast Open Cookie as stored in memory */
-struct tcp_fastopen_cookie {
-	__le64	val[DIV_ROUND_UP(TCP_FASTOPEN_COOKIE_MAX, sizeof(u64))];
-	s8	len;
-	bool	exp;	/* In RFC6994 experimental option format */
-};
-
 /* This defines a selective acknowledgement block. */
 struct tcp_sack_block_wire {
 	__be32	start_seq;
@@ -151,12 +139,8 @@
 	struct inet_request_sock 	req;
 	const struct tcp_request_sock_ops *af_specific;
 	u64				snt_synack; /* first SYNACK sent time */
-	bool				tfo_listener;
-	bool				is_mptcp;
+	bool				_is_m_t_tcp;
 	bool				req_usec_ts;
-#if IS_ENABLED(CONFIG_MPTCP)
-	bool				drop_req;
-#endif
 	u32				txhash;
 	u32				rcv_isn;
 	u32				snt_isn;
@@ -394,18 +378,18 @@
 		syn_ect_snt:2,	/* AccECN ECT memory, only */
 		syn_ect_rcv:2;	/* ... needed during 3WHS + first seqno */
 	u8	thin_lto    : 1,/* Use linear timeouts for thin streams */
-		fastopen_connect:1, /* FASTOPEN_CONNECT sockopt */
-		fastopen_no_cookie:1, /* Allow send/recv SYN+data without a cookie */
-		fastopen_client_fail:2, /* reason why fastopen failed */
+		XXXXXXXX_connect:1, /* FASTOPEN_CONNECT sockopt */
+		XXXXXXXX_no_cookie:1, /* Allow send/recv SYN+data without a cookie */
+		XXXXXXXX_client_fail:2, /* reason why fastopen failed */
 		frto        : 1;/* F-RTO (RFC5682) activated in CA_Loss */
 	u8	repair_queue;
 	u8	save_syn:2,	/* Save headers of SYN packet */
-		syn_data:1,	/* SYN includes data */
-		syn_fastopen:1,	/* SYN includes Fast Open option */
-		syn_fastopen_exp:1,/* SYN includes Fast Open exp. option */
-		syn_fastopen_ch:1, /* Active TFO re-enabling probe */
-		syn_data_acked:1,/* data in SYN is acked by SYN-ACK */
-		syn_fastopen_child:1; /* created TFO passive child socket */
+		syn_XXXX:1,	/* SYN includes data */
+		syn_XXXXXXXX:1,	/* SYN includes Fast Open option */
+		syn_XXXXXXXX_exp:1,/* SYN includes Fast Open exp. option */
+		syn_XXXXXXXX_ch:1, /* Active TFO re-enabling probe */
+		syn_XXXX_acked:1,/* data in SYN is acked by SYN-ACK */
+		syn_XXXXXXXX_child:1; /* created TFO passive child socket */
 
 	u8	keepalive_probes; /* num of allowed keep alive probes	*/
 	u8	accecn_fail_mode:4,	/* AccECN failure handling */
@@ -497,9 +481,6 @@
 		u32		  probe_seq_end;
 	} mtu_probe;
 	u32     plb_rehash;     /* PLB-triggered rehash attempts */
-#if IS_ENABLED(CONFIG_MPTCP)
-	bool	is_mptcp;
-#endif
 #if IS_ENABLED(CONFIG_SMC)
 	bool	syn_smc;	/* SYN includes SMC */
 	bool	(*smc_hs_congested)(const struct sock *sk);
@@ -518,12 +499,6 @@
 #endif
 #endif
 
-/* TCP fastopen related information */
-	struct tcp_fastopen_request *fastopen_req;
-	/* fastopen_rsk points to request_sock that resulted in this big
-	 * socket. Used to retransmit SYNACKs etc.
-	 */
-	struct request_sock __rcu *fastopen_rsk;
 	struct saved_syn *saved_syn;
 };
 
@@ -582,20 +557,6 @@
 	return (struct tcp_timewait_sock *)sk;
 }
 
-static inline bool tcp_passive_fastopen(const struct sock *sk)
-{
-	return sk->sk_state == TCP_SYN_RECV &&
-	       rcu_access_pointer(tcp_sk(sk)->fastopen_rsk) != NULL;
-}
-
-static inline void fastopen_queue_tune(struct sock *sk, int backlog)
-{
-	struct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;
-	int somaxconn = READ_ONCE(sock_net(sk)->core.sysctl_somaxconn);
-
-	WRITE_ONCE(queue->fastopenq.max_qlen, min_t(unsigned int, backlog, somaxconn));
-}
-
 static inline void tcp_move_syn(struct tcp_sock *tp,
 				struct request_sock *req)
 {
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/udp.h linux-master/include/linux/udp.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/linux/udp.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/linux/udp.h	2025-10-20 00:41:14.000000000 -0300
@@ -40,8 +40,8 @@
 	UDP_FLAGS_ACCEPT_FRAGLIST,
 	UDP_FLAGS_ACCEPT_L4,
 	UDP_FLAGS_ENCAP_ENABLED, /* This socket enabled encap */
-	UDP_FLAGS_UDPLITE_SEND_CC, /* set via udplite setsockopt */
-	UDP_FLAGS_UDPLITE_RECV_CC, /* set via udplite setsockopt */
+	UDP_FLAGS_XXXX,
+	UDP_FLAGS_ZZZZ,
 };
 
 /* per NUMA structure for lockless producer usage. */
@@ -75,10 +75,10 @@
 	__u16		 len;		/* total length of pending frames */
 	__u16		 gso_size;
 	/*
-	 * Fields specific to UDP-Lite.
+	 * Fields specific to XXXZZZ.
 	 */
-	__u16		 pcslen;
-	__u16		 pcrlen;
+	__u16		 XXXXXX;
+	__u16		 ZZZZZZ;
 	/*
 	 * For encapsulation sockets.
 	 */
@@ -236,7 +236,6 @@
 	hlist_nulls_for_each_entry_rcu(__up, node, list, udp_lrpa_node)
 #endif
 
-#define IS_UDPLITE(__sk) (__sk->sk_protocol == IPPROTO_UDPLITE)
 
 static inline struct sock *udp_tunnel_sk(const struct net *net, bool is_ipv6)
 {
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/dropreason-core.h linux-master/include/net/dropreason-core.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/dropreason-core.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/dropreason-core.h	2025-10-20 00:41:14.000000000 -0300
@@ -50,7 +50,6 @@
 	FN(TCP_RESET)			\
 	FN(TCP_INVALID_SYN)		\
 	FN(TCP_CLOSE)			\
-	FN(TCP_FASTOPEN)		\
 	FN(TCP_OLD_ACK)			\
 	FN(TCP_TOO_OLD_ACK)		\
 	FN(TCP_ACK_UNSENT_DATA)		\
@@ -331,8 +330,6 @@
 	SKB_DROP_REASON_TCP_INVALID_SYN,
 	/** @SKB_DROP_REASON_TCP_CLOSE: TCP socket in CLOSE state */
 	SKB_DROP_REASON_TCP_CLOSE,
-	/** @SKB_DROP_REASON_TCP_FASTOPEN: dropped by FASTOPEN request socket */
-	SKB_DROP_REASON_TCP_FASTOPEN,
 	/** @SKB_DROP_REASON_TCP_OLD_ACK: TCP ACK is old, but in window */
 	SKB_DROP_REASON_TCP_OLD_ACK,
 	/** @SKB_DROP_REASON_TCP_TOO_OLD_ACK: TCP ACK is too old */
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/inet_connection_sock.h linux-master/include/net/inet_connection_sock.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/inet_connection_sock.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/inet_connection_sock.h	2025-10-20 00:41:14.000000000 -0300
@@ -357,7 +357,6 @@
 	struct inet_connection_sock *icsk = inet_csk(sk);
 
 	spin_lock_init(&icsk->icsk_accept_queue.rskq_lock);
-	spin_lock_init(&icsk->icsk_accept_queue.fastopenq.lock);
 }
 
 #endif /* _INET_CONNECTION_SOCK_H */
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/inet_sock.h linux-master/include/net/inet_sock.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/inet_sock.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/inet_sock.h	2025-10-20 00:41:14.000000000 -0300
@@ -237,7 +237,6 @@
 	int			uc_index;
 	int			mc_index;
 	__be32			mc_addr;
-	u32			local_port_range;	/* high << 16 | low */
 
 	struct ip_mc_socklist __rcu	*mc_list;
 	struct inet_cork_full	cork;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/ip.h linux-master/include/net/ip.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/ip.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/ip.h	2025-10-20 00:41:14.000000000 -0300
@@ -352,32 +352,16 @@
 
 static inline void inet_get_local_port_range(const struct net *net, int *low, int *high)
 {
-	u32 range = READ_ONCE(net->ipv4.ip_local_ports.range);
-
-	*low = range & 0xffff;
-	*high = range >> 16;
+	*low  = CONFIG_SYSCTL_IP_LOCAL_PORTS_MIN;
+	*high = CONFIG_SYSCTL_IP_LOCAL_PORTS_MAX;
 }
 bool inet_sk_get_local_port_range(const struct sock *sk, int *low, int *high);
 
-#ifdef CONFIG_SYSCTL
-static inline bool inet_is_local_reserved_port(const struct net *net, unsigned short port)
-{
-	if (!net->ipv4.sysctl_local_reserved_ports)
-		return false;
-	return test_bit(port, net->ipv4.sysctl_local_reserved_ports);
-}
-
 static inline bool sysctl_dev_name_is_allowed(const char *name)
 {
 	return strcmp(name, "default") != 0  && strcmp(name, "all") != 0;
 }
 
-static inline bool inet_port_requires_bind_service(struct net *net, unsigned short port)
-{
-	return port < READ_ONCE(net->ipv4.sysctl_ip_prot_sock);
-}
-
-#else
 static inline bool inet_is_local_reserved_port(struct net *net, unsigned short port)
 {
 	return false;
@@ -387,7 +371,6 @@
 {
 	return port < PROT_SOCK;
 }
-#endif
 
 __be32 inet_current_timestamp(void);
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/ipv6.h linux-master/include/net/ipv6.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/ipv6.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/ipv6.h	2025-10-20 00:41:14.000000000 -0300
@@ -1248,8 +1248,6 @@
 void tcp6_proc_exit(struct net *net);
 int udp6_proc_init(struct net *net);
 void udp6_proc_exit(struct net *net);
-int udplite6_proc_init(void);
-void udplite6_proc_exit(void);
 int ipv6_misc_proc_init(void);
 void ipv6_misc_proc_exit(void);
 int snmp6_register_dev(struct inet6_dev *idev);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netfilter/ipv4/nf_conntrack_ipv4.h linux-master/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netfilter/ipv4/nf_conntrack_ipv4.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/netfilter/ipv4/nf_conntrack_ipv4.h	2025-10-20 00:41:14.000000000 -0300
@@ -16,9 +16,6 @@
 #ifdef CONFIG_NF_CT_PROTO_SCTP
 extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp;
 #endif
-#ifdef CONFIG_NF_CT_PROTO_UDPLITE
-extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_udplite;
-#endif
 #ifdef CONFIG_NF_CT_PROTO_GRE
 extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_gre;
 #endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netfilter/nf_conntrack_l4proto.h linux-master/include/net/netfilter/nf_conntrack_l4proto.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netfilter/nf_conntrack_l4proto.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/netfilter/nf_conntrack_l4proto.h	2025-10-20 00:41:14.000000000 -0300
@@ -107,11 +107,6 @@
 			    unsigned int dataoff,
 			    enum ip_conntrack_info ctinfo,
 			    const struct nf_hook_state *state);
-int nf_conntrack_udplite_packet(struct nf_conn *ct,
-				struct sk_buff *skb,
-				unsigned int dataoff,
-				enum ip_conntrack_info ctinfo,
-				const struct nf_hook_state *state);
 int nf_conntrack_tcp_packet(struct nf_conn *ct,
 			    struct sk_buff *skb,
 			    unsigned int dataoff,
@@ -139,7 +134,7 @@
 /* Existing built-in generic protocol */
 extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_generic;
 
-#define MAX_NF_CT_PROTO IPPROTO_UDPLITE
+#define MAX_NF_CT_PROTO IPPROTO_UDPZZZZ
 
 const struct nf_conntrack_l4proto *nf_ct_l4proto_find(u8 l4proto);
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netfilter/nf_reject.h linux-master/include/net/netfilter/nf_reject.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netfilter/nf_reject.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/netfilter/nf_reject.h	2025-10-20 00:41:14.000000000 -0300
@@ -33,7 +33,6 @@
 		case IPPROTO_SCTP:
 
 		/* Protocols with partial checksums. */
-		case IPPROTO_UDPLITE:
 			return false;
 	}
 	return true;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netns/ipv4.h linux-master/include/net/netns/ipv4.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netns/ipv4.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/netns/ipv4.h	2025-10-20 00:41:14.000000000 -0300
@@ -38,8 +38,6 @@
 	int			sysctl_max_tw_buckets;
 };
 
-struct tcp_fastopen_context;
-
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 struct sysctl_fib_multipath_hash_seed {
 	u32 user_seed;
@@ -52,6 +50,10 @@
 	struct hlist_head list;
 };
 
+#define CONFIG_SYSCTL_TCP_FIN_TIMEOUT      (CONFIG_SYSCTL_TCP_FIN_TIMEOUT_*HZ)      // TCP_FIN_TIMEOUT
+#define CONFIG_SYSCTL_TCP_KEEPALIVE_INTVL  (CONFIG_SYSCTL_TCP_KEEPALIVE_INTVL_*HZ)  // TCP_KEEPALIVE_INTVL
+#define CONFIG_SYSCTL_TCP_KEEPALIVE_TIME   (CONFIG_SYSCTL_TCP_KEEPALIVE_TIME_*HZ)   // TCP_KEEPALIVE_TIME
+#define CONFIG_SYSCTL_TCP_KEEPALIVE_PROBES (CONFIG_SYSCTL_TCP_KEEPALIVE_PROBES_*HZ) // TCP_KEEPALIVE_PROBES
 struct netns_ipv4 {
 	/* Cacheline organization can be found documented in
 	 * Documentation/networking/net_cachelines/netns_ipv4_sysctl.rst.
@@ -74,7 +76,7 @@
 
 	/* TXRX readonly hotpath cache lines */
 	__cacheline_group_begin(netns_ipv4_read_txrx);
-	u8 sysctl_tcp_moderate_rcvbuf;
+	u8 __klmknjsj;
 	__cacheline_group_end(netns_ipv4_read_txrx);
 
 	/* RX readonly hotpath cache line */
@@ -83,7 +85,7 @@
 	u8 sysctl_tcp_early_demux;
 	u8 sysctl_tcp_l3mdev_accept;
 	/* 3 bytes hole, try to pack */
-	int sysctl_tcp_reordering;
+	int __abcdefg;
 	int sysctl_tcp_rmem[3];
 	__cacheline_group_end(netns_ipv4_read_rx);
 
@@ -130,9 +132,6 @@
 	struct inet_peer_base	*peers;
 	struct fqdir		*fqdir;
 
-	u8 sysctl_icmp_echo_ignore_all;
-	u8 sysctl_icmp_echo_enable_probe;
-	u8 sysctl_icmp_echo_ignore_broadcasts;
 	u8 sysctl_icmp_ignore_bogus_error_responses;
 	u8 sysctl_icmp_errors_use_inbound_ifaddr;
 	int sysctl_icmp_ratelimit;
@@ -145,14 +144,11 @@
 	int ip_rt_mtu_expires;
 	int ip_rt_min_advmss;
 
-	struct local_ports ip_local_ports;
-
 	u8 sysctl_tcp_ecn;
 	u8 sysctl_tcp_ecn_option;
 	u8 sysctl_tcp_ecn_option_beacon;
 	u8 sysctl_tcp_ecn_fallback;
 
-	u8 sysctl_ip_default_ttl;
 	u8 sysctl_ip_no_pmtu_disc;
 	u8 sysctl_ip_fwd_update_priority;
 	u8 sysctl_ip_nonlocal_bind;
@@ -171,64 +167,31 @@
 	u8 sysctl_tcp_mtu_probing;
 	int sysctl_tcp_mtu_probe_floor;
 	int sysctl_tcp_base_mss;
-	int sysctl_tcp_probe_threshold;
-	u32 sysctl_tcp_probe_interval;
 
-	int sysctl_tcp_keepalive_time;
-	int sysctl_tcp_keepalive_intvl;
-	u8 sysctl_tcp_keepalive_probes;
-
-	u8 sysctl_tcp_syn_retries;
-	u8 sysctl_tcp_synack_retries;
-	u8 sysctl_tcp_syncookies;
-	u8 sysctl_tcp_migrate_req;
 	u8 sysctl_tcp_comp_sack_nr;
 	u8 sysctl_tcp_backlog_ack_defer;
 	u8 sysctl_tcp_pingpong_thresh;
 
-	u8 sysctl_tcp_retries1;
-	u8 sysctl_tcp_retries2;
-	u8 sysctl_tcp_orphan_retries;
 	u8 sysctl_tcp_tw_reuse;
 	unsigned int sysctl_tcp_tw_reuse_delay;
-	int sysctl_tcp_fin_timeout;
 	u8 sysctl_tcp_sack;
 	u8 sysctl_tcp_window_scaling;
-	u8 sysctl_tcp_timestamps;
 	int sysctl_tcp_rto_min_us;
 	int sysctl_tcp_rto_max_ms;
 	u8 sysctl_tcp_recovery;
 	u8 sysctl_tcp_thin_linear_timeouts;
 	u8 sysctl_tcp_slow_start_after_idle;
-	u8 sysctl_tcp_retrans_collapse;
-	u8 sysctl_tcp_stdurg;
 	u8 sysctl_tcp_rfc1337;
-	u8 sysctl_tcp_abort_on_overflow;
-	u8 sysctl_tcp_fack; /* obsolete */
-	int sysctl_tcp_max_reordering;
-	int sysctl_tcp_adv_win_scale; /* obsolete */
 	u8 sysctl_tcp_dsack;
 	u8 sysctl_tcp_app_win;
-	u8 sysctl_tcp_frto;
-	u8 sysctl_tcp_nometrics_save;
-	u8 sysctl_tcp_no_ssthresh_metrics_save;
-	u8 sysctl_tcp_workaround_signed_windows;
 	int sysctl_tcp_challenge_ack_limit;
-	u8 sysctl_tcp_min_tso_segs;
-	u8 sysctl_tcp_reflect_tos;
 	int sysctl_tcp_invalid_ratelimit;
 	int sysctl_tcp_pacing_ss_ratio;
 	int sysctl_tcp_pacing_ca_ratio;
 	unsigned int sysctl_tcp_child_ehash_entries;
 	unsigned long sysctl_tcp_comp_sack_delay_ns;
 	unsigned long sysctl_tcp_comp_sack_slack_ns;
-	int sysctl_max_syn_backlog;
-	int sysctl_tcp_fastopen;
 	const struct tcp_congestion_ops __rcu  *tcp_congestion_control;
-	struct tcp_fastopen_context __rcu *tcp_fastopen_ctx;
-	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
-	atomic_t tfo_active_disable_times;
-	unsigned long tfo_active_disable_stamp;
 	u32 tcp_challenge_timestamp;
 	u32 tcp_challenge_count;
 	u8 sysctl_tcp_plb_enabled;
@@ -241,7 +204,6 @@
 	int sysctl_udp_rmem_min;
 
 	u8 sysctl_fib_notify_on_flag_change;
-	u8 sysctl_tcp_syn_linear_timeouts;
 
 #ifdef CONFIG_NET_L3_MASTER_DEV
 	u8 sysctl_udp_l3mdev_accept;
@@ -257,12 +219,6 @@
 
 	atomic_t dev_addr_genid;
 
-	unsigned int sysctl_udp_child_hash_entries;
-
-#ifdef CONFIG_SYSCTL
-	unsigned long *sysctl_local_reserved_ports;
-	int sysctl_ip_prot_sock;
-#endif
 
 #ifdef CONFIG_IP_MROUTE
 #ifndef CONFIG_IP_MROUTE_MULTIPLE_TABLES
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netns/ipv6.h linux-master/include/net/netns/ipv6.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netns/ipv6.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/netns/ipv6.h	2025-10-20 00:41:14.000000000 -0300
@@ -33,10 +33,7 @@
 	u8 bindv6only;
 	u8 flowlabel_consistency;
 	u8 auto_flowlabels;
-	int icmpv6_time;
-	u8 icmpv6_echo_ignore_all;
-	u8 icmpv6_echo_ignore_multicast;
-	u8 icmpv6_echo_ignore_anycast;
+#define CONFIG_SYSCTL_ICMPV6_TIME ((int)(CONFIG_SYSCTL_ICMPV6_TIME_*HZ))
 	DECLARE_BITMAP(icmpv6_ratemask, ICMPV6_MSG_MAX + 1);
 	unsigned long *icmpv6_ratemask_ptr;
 	u8 anycast_src_echo_reply;
@@ -55,7 +52,6 @@
 	u64 ioam6_id_wide;
 	u8 skip_notify_on_dev_down;
 	u8 fib_notify_on_flag_change;
-	u8 icmpv6_error_anycast_as_unicast;
 };
 
 struct netns_ipv6 {
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netns/mib.h linux-master/include/net/netns/mib.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/netns/mib.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/netns/mib.h	2025-10-20 00:41:14.000000000 -0300
@@ -24,14 +24,7 @@
 #if IS_ENABLED(CONFIG_TLS)
 	DEFINE_SNMP_STAT(struct linux_tls_mib, tls_statistics);
 #endif
-#ifdef CONFIG_MPTCP
-	DEFINE_SNMP_STAT(struct mptcp_mib, mptcp_statistics);
-#endif
 
-	DEFINE_SNMP_STAT(struct udp_mib, udplite_statistics);
-#if IS_ENABLED(CONFIG_IPV6)
-	DEFINE_SNMP_STAT(struct udp_mib, udplite_stats_in6);
-#endif
 
 	DEFINE_SNMP_STAT(struct icmp_mib, icmp_statistics);
 	DEFINE_SNMP_STAT_ATOMIC(struct icmpmsg_mib, icmpmsg_statistics);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/request_sock.h linux-master/include/net/request_sock.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/request_sock.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/request_sock.h	2025-10-20 00:41:14.000000000 -0300
@@ -145,36 +145,6 @@
 		__reqsk_free(req);
 }
 
-/*
- * For a TCP Fast Open listener -
- *	lock - protects the access to all the reqsk, which is co-owned by
- *		the listener and the child socket.
- *	qlen - pending TFO requests (still in TCP_SYN_RECV).
- *	max_qlen - max TFO reqs allowed before TFO is disabled.
- *
- *	XXX (TFO) - ideally these fields can be made as part of "listen_sock"
- *	structure above. But there is some implementation difficulty due to
- *	listen_sock being part of request_sock_queue hence will be freed when
- *	a listener is stopped. But TFO related fields may continue to be
- *	accessed even after a listener is closed, until its sk_refcnt drops
- *	to 0 implying no more outstanding TFO reqs. One solution is to keep
- *	listen_opt around until	sk_refcnt drops to 0. But there is some other
- *	complexity that needs to be resolved. E.g., a listener can be disabled
- *	temporarily through shutdown()->tcp_disconnect(), and re-enabled later.
- */
-struct fastopen_queue {
-	struct request_sock	*rskq_rst_head; /* Keep track of past TFO */
-	struct request_sock	*rskq_rst_tail; /* requests that caused RST.
-						 * This is part of the defense
-						 * against spoofing attack.
-						 */
-	spinlock_t	lock;
-	int		qlen;		/* # of pending (TCP_SYN_RECV) reqs */
-	int		max_qlen;	/* != 0 iff TFO is currently enabled */
-
-	struct tcp_fastopen_context __rcu *ctx; /* cipher context for cookie */
-};
-
 /** struct request_sock_queue - queue of request_socks
  *
  * @rskq_accept_head - FIFO head of established children
@@ -192,16 +162,10 @@
 
 	struct request_sock	*rskq_accept_head;
 	struct request_sock	*rskq_accept_tail;
-	struct fastopen_queue	fastopenq;  /* Check max_qlen != 0 to determine
-					     * if TFO is enabled.
-					     */
 };
 
 void reqsk_queue_alloc(struct request_sock_queue *queue);
 
-void reqsk_fastopen_remove(struct sock *sk, struct request_sock *req,
-			   bool reset);
-
 static inline bool reqsk_queue_empty(const struct request_sock_queue *queue)
 {
 	return READ_ONCE(queue->rskq_accept_head) == NULL;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/route.h linux-master/include/net/route.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/route.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/route.h	2025-10-20 00:41:14.000000000 -0300
@@ -387,12 +387,8 @@
 	int hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);
 
 	if (hoplimit == 0) {
-		const struct net *net;
+		hoplimit = CONFIG_SYSCTL_IP_DEFAULT_TTL;
 
-		rcu_read_lock();
-		net = dst_dev_net_rcu(dst);
-		hoplimit = READ_ONCE(net->ipv4.sysctl_ip_default_ttl);
-		rcu_read_unlock();
 	}
 	return hoplimit;
 }
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/rstreason.h linux-master/include/net/rstreason.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/rstreason.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/rstreason.h	2025-10-20 00:41:14.000000000 -0300
@@ -3,7 +3,7 @@
 #ifndef _LINUX_RSTREASON_H
 #define _LINUX_RSTREASON_H
 #include <net/dropreason-core.h>
-#include <uapi/linux/mptcp.h>
+// uapi/linux/mptcp.h
 
 #define DEFINE_RST_REASON(FN, FNe)	\
 	FN(NOT_SPECIFIED)		\
@@ -23,13 +23,6 @@
 	FN(TCP_STATE)			\
 	FN(TCP_KEEPALIVE_TIMEOUT)	\
 	FN(TCP_DISCONNECT_WITH_DATA)	\
-	FN(MPTCP_RST_EUNSPEC)		\
-	FN(MPTCP_RST_EMPTCP)		\
-	FN(MPTCP_RST_ERESOURCE)		\
-	FN(MPTCP_RST_EPROHIBIT)		\
-	FN(MPTCP_RST_EWQ2BIG)		\
-	FN(MPTCP_RST_EBADPERF)		\
-	FN(MPTCP_RST_EMIDDLEBOX)	\
 	FN(ERROR)			\
 	FNe(MAX)
 
@@ -124,62 +117,6 @@
 	 */
 	SK_RST_REASON_TCP_DISCONNECT_WITH_DATA,
 
-	/* Copy from include/uapi/linux/mptcp.h.
-	 * These reset fields will not be changed since they adhere to
-	 * RFC 8684. So do not touch them. I'm going to list each definition
-	 * of them respectively.
-	 */
-	/**
-	 * @SK_RST_REASON_MPTCP_RST_EUNSPEC: Unspecified error.
-	 * This is the default error; it implies that the subflow is no
-	 * longer available. The presence of this option shows that the
-	 * RST was generated by an MPTCP-aware device.
-	 */
-	SK_RST_REASON_MPTCP_RST_EUNSPEC,
-	/**
-	 * @SK_RST_REASON_MPTCP_RST_EMPTCP: MPTCP-specific error.
-	 * An error has been detected in the processing of MPTCP options.
-	 * This is the usual reason code to return in the cases where a RST
-	 * is being sent to close a subflow because of an invalid response.
-	 */
-	SK_RST_REASON_MPTCP_RST_EMPTCP,
-	/**
-	 * @SK_RST_REASON_MPTCP_RST_ERESOURCE: Lack of resources.
-	 * This code indicates that the sending host does not have enough
-	 * resources to support the terminated subflow.
-	 */
-	SK_RST_REASON_MPTCP_RST_ERESOURCE,
-	/**
-	 * @SK_RST_REASON_MPTCP_RST_EPROHIBIT: Administratively prohibited.
-	 * This code indicates that the requested subflow is prohibited by
-	 * the policies of the sending host.
-	 */
-	SK_RST_REASON_MPTCP_RST_EPROHIBIT,
-	/**
-	 * @SK_RST_REASON_MPTCP_RST_EWQ2BIG: Too much outstanding data.
-	 * This code indicates that there is an excessive amount of data
-	 * that needs to be transmitted over the terminated subflow while
-	 * having already been acknowledged over one or more other subflows.
-	 * This may occur if a path has been unavailable for a short period
-	 * and it is more efficient to reset and start again than it is to
-	 * retransmit the queued data.
-	 */
-	SK_RST_REASON_MPTCP_RST_EWQ2BIG,
-	/**
-	 * @SK_RST_REASON_MPTCP_RST_EBADPERF: Unacceptable performance.
-	 * This code indicates that the performance of this subflow was
-	 * too low compared to the other subflows of this Multipath TCP
-	 * connection.
-	 */
-	SK_RST_REASON_MPTCP_RST_EBADPERF,
-	/**
-	 * @SK_RST_REASON_MPTCP_RST_EMIDDLEBOX: Middlebox interference.
-	 * Middlebox interference has been detected over this subflow,
-	 * making MPTCP signaling invalid. For example, this may be sent
-	 * if the checksum does not validate.
-	 */
-	SK_RST_REASON_MPTCP_RST_EMIDDLEBOX,
-
 	/** @SK_RST_REASON_ERROR: unexpected error happens */
 	SK_RST_REASON_ERROR,
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/snmp.h linux-master/include/net/snmp.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/snmp.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/snmp.h	2025-10-20 00:41:14.000000000 -0300
@@ -193,4 +193,33 @@
 #define __SNMP_UPD_PO_STATS64(mib, basefield, addend) __SNMP_UPD_PO_STATS(mib, basefield, addend)
 #endif
 
+#ifdef CONFIG_NO_SNMP
+
+#undef __SNMP_ADD_STATS64
+#undef __SNMP_ADD_STATS
+#undef __SNMP_INC_STATS
+#undef __SNMP_UPD_PO_STATS64
+#undef __SNMP_UPD_PO_STATS
+#undef SNMP_INC_STATS_ATOMIC_LONG
+#undef SNMP_INC_STATS
+#undef SNMP_DEC_STATS
+#undef SNMP_ADD_STATS
+#undef SNMP_UPD_PO_STATS
+#undef SNMP_ADD_STATS64
+#undef SNMP_UPD_PO_STATS64
+
+#define __SNMP_ADD_STATS64(mib, field, addend) 		((void)((mib)[field]))
+#define __SNMP_ADD_STATS(mib, field, addend)		((void)((mib)[field]))
+#define __SNMP_INC_STATS(mib, field)	        	((void)((mib)[field]))
+#define __SNMP_UPD_PO_STATS64(mib, basefield, addend)	((void)(mib))
+#define __SNMP_UPD_PO_STATS(mib, basefield, addend)	((void)(mib))
+#define SNMP_INC_STATS_ATOMIC_LONG(mib, field)		((void)((mib)[field]))
+#define SNMP_INC_STATS(mib, field)			((void)((mib)[field]))
+#define SNMP_DEC_STATS(mib, field)			((void)((mib)[field]))
+#define SNMP_ADD_STATS(mib, field, addend)		((void)((mib)[field]))
+#define SNMP_UPD_PO_STATS(mib, basefield, addend)	((void)(mib))
+#define SNMP_ADD_STATS64(mib, field, addend) 		((void)((mib)[field]))
+#define SNMP_UPD_PO_STATS64(mib, basefield, addend)	((void)(mib))
+#endif
+
 #endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/sock.h linux-master/include/net/sock.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/sock.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/sock.h	2025-10-20 00:41:14.000000000 -0300
@@ -120,14 +120,14 @@
  *	@skc_net_refcnt: socket is using net ref counting
  *	@skc_bound_dev_if: bound device index if != 0
  *	@skc_bind_node: bind hash linkage for various protocol lookup tables
- *	@skc_portaddr_node: second hash linkage for UDP/UDP-Lite protocol
+ *	@skc_portaddr_node: second hash linkage for UDP protocol
  *	@skc_prot: protocol handlers inside a network family
  *	@skc_net: reference to the network namespace of this socket
  *	@skc_v6_daddr: IPV6 destination address
  *	@skc_v6_rcv_saddr: IPV6 source address
  *	@skc_cookie: socket's cookie value
  *	@skc_node: main hash linkage for various protocol lookup tables
- *	@skc_nulls_node: main hash linkage for TCP/UDP/UDP-Lite protocol
+ *	@skc_nulls_node: main hash linkage for TCP/UDP protocol
  *	@skc_tx_queue_mapping: tx queue number for this connection
  *	@skc_rx_queue_mapping: rx queue number for this connection
  *	@skc_flags: place holder for sk_flags
@@ -265,8 +265,6 @@
   *	@sk_pacing_status: Pacing status (requested, handled by sch_fq)
   *	@sk_max_pacing_rate: Maximum pacing rate (%SO_MAX_PACING_RATE)
   *	@sk_sndbuf: size of send buffer in bytes
-  *	@sk_no_check_tx: %SO_NO_CHECK setting, set checksum in TX packets
-  *	@sk_no_check_rx: allow zero checksum in RX packets
   *	@sk_route_caps: route capabilities (e.g. %NETIF_F_TSO)
   *	@sk_gso_disabled: if set, NETIF_F_GSO_MASK is forbidden.
   *	@sk_gso_type: GSO type (e.g. %SKB_GSO_TCPV4)
@@ -518,8 +516,8 @@
 	 */
 	u8			sk_gso_disabled : 1,
 				sk_kern_sock : 1,
-				sk_no_check_tx : 1,
-				sk_no_check_rx : 1;
+				XXXXXXXXXXXXXX : 1,
+				ZZZZZZZZZZZZZZ : 1;
 	u8			sk_shutdown;
 	unsigned long	        sk_lingertime;
 	struct proto		*sk_prot_creator;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/tcp.h linux-master/include/net/tcp.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/tcp.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/tcp.h	2025-10-20 00:41:14.000000000 -0300
@@ -41,7 +41,7 @@
 #include <net/tcp_ao.h>
 #include <net/inet_ecn.h>
 #include <net/dst.h>
-#include <net/mptcp.h>
+// #include <net/mptcp.h>   linux/types.h linux/tcp.h
 #include <net/xfrm.h>
 
 #include <linux/seq_file.h>
@@ -148,7 +148,11 @@
 				  */
 #define TCP_FIN_TIMEOUT_MAX (120 * HZ) /* max TCP_LINGER2 value (two minutes) */
 
+#if HZ > 1500
+#define TCP_DELACK_MAX	((unsigned)(HZ/8))
+#else
 #define TCP_DELACK_MAX	((unsigned)(HZ/5))	/* maximal time to delay before sending an ACK */
+#endif
 static_assert((1 << ATO_BITS) > TCP_DELACK_MAX);
 
 #if HZ >= 100
@@ -158,14 +162,14 @@
 #define TCP_DELACK_MIN	4U
 #define TCP_ATO_MIN	4U
 #endif
-#define TCP_RTO_MAX_SEC 120
+#define TCP_RTO_MAX_SEC 8
 #define TCP_RTO_MAX	((unsigned)(TCP_RTO_MAX_SEC * HZ))
-#define TCP_RTO_MIN	((unsigned)(HZ / 5))
+#define TCP_RTO_MIN	((unsigned)(HZ / 10))
 #define TCP_TIMEOUT_MIN	(2U) /* Min timeout for TCP timers in jiffies */
 
 #define TCP_TIMEOUT_MIN_US (2*USEC_PER_MSEC) /* Min TCP timeout in microsecs */
 
-#define TCP_TIMEOUT_INIT ((unsigned)(1*HZ))	/* RFC6298 2.1 initial RTO value	*/
+#define TCP_TIMEOUT_INIT ((unsigned)(HZ/2))	/* RFC6298 2.1 initial RTO value	*/
 #define TCP_TIMEOUT_FALLBACK ((unsigned)(3*HZ))	/* RFC 1122 initial RTO value, now
 						 * used as a fallback RTO for the
 						 * initial data transmission if no
@@ -214,15 +218,12 @@
 #define TCPOPT_TIMESTAMP	8	/* Better RTT estimations/PAWS */
 #define TCPOPT_MD5SIG		19	/* MD5 Signature (RFC2385) */
 #define TCPOPT_AO		29	/* Authentication Option (RFC5925) */
-#define TCPOPT_MPTCP		30	/* Multipath TCP (RFC6824) */
-#define TCPOPT_FASTOPEN		34	/* Fast open (RFC7413) */
 #define TCPOPT_ACCECN0		172	/* 0xAC: Accurate ECN Order 0 */
 #define TCPOPT_ACCECN1		174	/* 0xAE: Accurate ECN Order 1 */
 #define TCPOPT_EXP		254	/* Experimental */
 /* Magic number to be after the option value for sharing TCP
  * experimental options. See draft-ietf-tcpm-experimental-options-00.txt
  */
-#define TCPOPT_FASTOPEN_MAGIC	0xF989
 #define TCPOPT_SMC_MAGIC	0xE2D4C3D9
 
 /*
@@ -234,9 +235,7 @@
 #define TCPOLEN_SACK_PERM      2
 #define TCPOLEN_TIMESTAMP      10
 #define TCPOLEN_MD5SIG         18
-#define TCPOLEN_FASTOPEN_BASE  2
 #define TCPOLEN_ACCECN_BASE    2
-#define TCPOLEN_EXP_FASTOPEN_BASE  4
 #define TCPOLEN_EXP_SMC_BASE   6
 
 /* But this is what stacks really send out. */
@@ -269,20 +268,6 @@
 /* TCP initial congestion window as per rfc6928 */
 #define TCP_INIT_CWND		10
 
-/* Bit Flags for sysctl_tcp_fastopen */
-#define	TFO_CLIENT_ENABLE	1
-#define	TFO_SERVER_ENABLE	2
-#define	TFO_CLIENT_NO_COOKIE	4	/* Data in SYN w/o cookie option */
-
-/* Accept SYN data w/o any cookie option */
-#define	TFO_SERVER_COOKIE_NOT_REQD	0x200
-
-/* Force enable TFO on all listeners, i.e., not requiring the
- * TCP_FASTOPEN socket option.
- */
-#define	TFO_SERVER_WO_SOCKOPT1	0x400
-
-
 /* sysctl variables for tcp */
 extern int sysctl_tcp_max_orphans;
 extern long sysctl_tcp_mem[3];
@@ -356,8 +341,6 @@
 void tcp_remove_empty_skb(struct sock *sk);
 int tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);
 int tcp_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t size);
-int tcp_sendmsg_fastopen(struct sock *sk, struct msghdr *msg, int *copied,
-			 size_t size, struct ubuf_info *uarg);
 void tcp_splice_eof(struct socket *sock);
 int tcp_send_mss(struct sock *sk, int *size_goal, int flags);
 int tcp_wmem_schedule(struct sock *sk, int copy);
@@ -454,7 +437,7 @@
 					      u32 *tw_isn,
 					      enum skb_drop_reason *drop_reason);
 struct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,
-			   struct request_sock *req, bool fastopen,
+			   struct request_sock *req,
 			   bool *lost_race, enum skb_drop_reason *drop_reason);
 enum skb_drop_reason tcp_child_process(struct sock *parent, struct sock *child,
 				       struct sk_buff *skb);
@@ -498,7 +481,7 @@
 #endif
 void tcp_parse_options(const struct net *net, const struct sk_buff *skb,
 		       struct tcp_options_received *opt_rx,
-		       int estab, struct tcp_fastopen_cookie *foc);
+		       int estab);
 
 /*
  *	BPF SKB-less helpers
@@ -534,12 +517,11 @@
 int tcp_connect(struct sock *sk);
 enum tcp_synack_type {
 	TCP_SYNACK_NORMAL,
-	TCP_SYNACK_FASTOPEN,
+	__NOTFO_TCP_SYNACK_FASTOPEN,
 	TCP_SYNACK_COOKIE,
 };
 struct sk_buff *tcp_make_synack(const struct sock *sk, struct dst_entry *dst,
 				struct request_sock *req,
-				struct tcp_fastopen_cookie *foc,
 				enum tcp_synack_type synack_type,
 				struct sk_buff *syn_skb);
 int tcp_disconnect(struct sock *sk, int flags);
@@ -777,7 +759,11 @@
 
 unsigned int tcp_sync_mss(struct sock *sk, u32 pmtu);
 unsigned int tcp_current_mss(struct sock *sk);
+#if 1
+#define tcp_clamp_probe0_to_user_timeout(sk, when) (when)
+#else
 u32 tcp_clamp_probe0_to_user_timeout(const struct sock *sk, u32 when);
+#endif
 
 /* Bound MSS / TSO packet size with the half of the window */
 static inline int tcp_bound_to_half_wnd(struct tcp_sock *tp, int pktsize)
@@ -1148,7 +1134,6 @@
 {
 	/* skb_cmp_decrypted() not needed, use tcp_write_collapse_fence() */
 	return likely(tcp_skb_can_collapse_to(to) &&
-		      mptcp_skb_can_collapse(to, from) &&
 		      skb_pure_zcopy_same(to, from) &&
 		      skb_frags_readable(to) == skb_frags_readable(from));
 }
@@ -1156,7 +1141,7 @@
 static inline bool tcp_skb_can_collapse_rx(const struct sk_buff *to,
 					   const struct sk_buff *from)
 {
-	return likely(mptcp_skb_can_collapse(to, from) &&
+	return likely(1 &&
 		      !skb_cmp_decrypted(to, from));
 }
 
@@ -1248,7 +1233,7 @@
 	/* hook for packet ack accounting (optional) */
 	void (*pkts_acked)(struct sock *sk, const struct ack_sample *sample);
 
-	/* override sysctl_tcp_min_tso_segs */
+	/* override CONFIG_SYSCTL_TCP_MIN_TSO_SEGS */
 	u32 (*min_tso_segs)(struct sock *sk);
 
 	/* call when packets are delivered to update cwnd and pacing rate,
@@ -1718,7 +1703,7 @@
 	 */
 	val = READ_ONCE(tp->keepalive_intvl);
 
-	return val ? : READ_ONCE(net->ipv4.sysctl_tcp_keepalive_intvl);
+	return val ? : CONFIG_SYSCTL_TCP_KEEPALIVE_INTVL;
 }
 
 static inline int keepalive_time_when(const struct tcp_sock *tp)
@@ -1729,7 +1714,7 @@
 	/* Paired with WRITE_ONCE() in tcp_sock_set_keepidle_locked() */
 	val = READ_ONCE(tp->keepalive_time);
 
-	return val ? : READ_ONCE(net->ipv4.sysctl_tcp_keepalive_time);
+	return val ? : CONFIG_SYSCTL_TCP_KEEPALIVE_TIME;
 }
 
 static inline int keepalive_probes(const struct tcp_sock *tp)
@@ -1742,7 +1727,7 @@
 	 */
 	val = READ_ONCE(tp->keepalive_probes);
 
-	return val ? : READ_ONCE(net->ipv4.sysctl_tcp_keepalive_probes);
+	return val ? : CONFIG_SYSCTL_TCP_KEEPALIVE_PROBES;
 }
 
 static inline u32 keepalive_time_elapsed(const struct tcp_sock *tp)
@@ -1756,7 +1741,7 @@
 static inline int tcp_fin_time(const struct sock *sk)
 {
 	int fin_timeout = tcp_sk(sk)->linger2 ? :
-		READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_fin_timeout);
+		CONFIG_SYSCTL_TCP_FIN_TIMEOUT;
 	const int rto = inet_csk(sk)->icsk_rto;
 
 	if (fin_timeout < (rto << 2) - (rto >> 1))
@@ -1811,10 +1796,6 @@
 {
 	u32 ace;
 
-	/* mptcp hooks are only on the slow path */
-	if (sk_is_mptcp((struct sock *)tp))
-		return;
-
 	ace = tcp_ecn_mode_accecn(tp) ?
 	      ((tp->delivered_ce + TCP_ACCECN_CEP_INIT_OFFSET) &
 	       TCP_ACCECN_CEP_ACE_MASK) : 0;
@@ -2005,82 +1986,6 @@
 int tcp_md5_hash_key(struct tcp_sigpool *hp,
 		     const struct tcp_md5sig_key *key);
 
-/* From tcp_fastopen.c */
-void tcp_fastopen_cache_get(struct sock *sk, u16 *mss,
-			    struct tcp_fastopen_cookie *cookie);
-void tcp_fastopen_cache_set(struct sock *sk, u16 mss,
-			    struct tcp_fastopen_cookie *cookie, bool syn_lost,
-			    u16 try_exp);
-struct tcp_fastopen_request {
-	/* Fast Open cookie. Size 0 means a cookie request */
-	struct tcp_fastopen_cookie	cookie;
-	struct msghdr			*data;  /* data in MSG_FASTOPEN */
-	size_t				size;
-	int				copied;	/* queued in tcp_connect() */
-	struct ubuf_info		*uarg;
-};
-void tcp_free_fastopen_req(struct tcp_sock *tp);
-void tcp_fastopen_destroy_cipher(struct sock *sk);
-void tcp_fastopen_ctx_destroy(struct net *net);
-int tcp_fastopen_reset_cipher(struct net *net, struct sock *sk,
-			      void *primary_key, void *backup_key);
-int tcp_fastopen_get_cipher(struct net *net, struct inet_connection_sock *icsk,
-			    u64 *key);
-void tcp_fastopen_add_skb(struct sock *sk, struct sk_buff *skb);
-struct sock *tcp_try_fastopen(struct sock *sk, struct sk_buff *skb,
-			      struct request_sock *req,
-			      struct tcp_fastopen_cookie *foc,
-			      const struct dst_entry *dst);
-void tcp_fastopen_init_key_once(struct net *net);
-bool tcp_fastopen_cookie_check(struct sock *sk, u16 *mss,
-			     struct tcp_fastopen_cookie *cookie);
-bool tcp_fastopen_defer_connect(struct sock *sk, int *err);
-#define TCP_FASTOPEN_KEY_LENGTH sizeof(siphash_key_t)
-#define TCP_FASTOPEN_KEY_MAX 2
-#define TCP_FASTOPEN_KEY_BUF_LENGTH \
-	(TCP_FASTOPEN_KEY_LENGTH * TCP_FASTOPEN_KEY_MAX)
-
-/* Fastopen key context */
-struct tcp_fastopen_context {
-	siphash_key_t	key[TCP_FASTOPEN_KEY_MAX];
-	int		num;
-	struct rcu_head	rcu;
-};
-
-void tcp_fastopen_active_disable(struct sock *sk);
-bool tcp_fastopen_active_should_disable(struct sock *sk);
-void tcp_fastopen_active_disable_ofo_check(struct sock *sk);
-void tcp_fastopen_active_detect_blackhole(struct sock *sk, bool expired);
-
-/* Caller needs to wrap with rcu_read_(un)lock() */
-static inline
-struct tcp_fastopen_context *tcp_fastopen_get_ctx(const struct sock *sk)
-{
-	struct tcp_fastopen_context *ctx;
-
-	ctx = rcu_dereference(inet_csk(sk)->icsk_accept_queue.fastopenq.ctx);
-	if (!ctx)
-		ctx = rcu_dereference(sock_net(sk)->ipv4.tcp_fastopen_ctx);
-	return ctx;
-}
-
-static inline
-bool tcp_fastopen_cookie_match(const struct tcp_fastopen_cookie *foc,
-			       const struct tcp_fastopen_cookie *orig)
-{
-	if (orig->len == TCP_FASTOPEN_COOKIE_SIZE &&
-	    orig->len == foc->len &&
-	    !memcmp(orig->val, foc->val, foc->len))
-		return true;
-	return false;
-}
-
-static inline
-int tcp_fastopen_context_len(const struct tcp_fastopen_context *ctx)
-{
-	return ctx->num;
-}
-
 /* Latencies incurred by various limits for a sender. They are
  * chronograph-like stats that are mutually exclusive.
  */
@@ -2408,7 +2313,6 @@
 	u32 (*init_ts_off)(const struct net *net, const struct sk_buff *skb);
 	int (*send_synack)(const struct sock *sk, struct dst_entry *dst,
 			   struct flowi *fl, struct request_sock *req,
-			   struct tcp_fastopen_cookie *foc,
 			   enum tcp_synack_type synack_type,
 			   struct sk_buff *syn_skb);
 };
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/transp_v6.h linux-master/include/net/transp_v6.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/transp_v6.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/transp_v6.h	2025-10-20 00:41:14.000000000 -0300
@@ -8,7 +8,6 @@
 /* IPv6 transport protocols */
 extern struct proto rawv6_prot;
 extern struct proto udpv6_prot;
-extern struct proto udplitev6_prot;
 extern struct proto tcpv6_prot;
 extern struct proto pingv6_prot;
 
@@ -28,8 +27,6 @@
 void rawv6_exit(void);
 int udpv6_init(void);
 void udpv6_exit(void);
-int udplitev6_init(void);
-void udplitev6_exit(void);
 int tcpv6_init(void);
 void tcpv6_exit(void);
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/udp.h linux-master/include/net/udp.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/udp.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/udp.h	2025-10-20 00:41:14.000000000 -0300
@@ -31,11 +31,10 @@
 #include <linux/indirect_call_wrapper.h>
 
 /**
- *	struct udp_skb_cb  -  UDP(-Lite) private variables
+ *	struct udp_skb_cb  -  UDP private variables
  *
  *	@header:      private variables used by IPv4/IPv6
- *	@cscov:       checksum coverage length (UDP-Lite only)
- *	@partial_cov: if set indicates partial csum coverage
+ *	@cscov:       checksum coverage length (UDP only)
  */
 struct udp_skb_cb {
 	union {
@@ -45,7 +44,6 @@
 #endif
 	} header;
 	__u16		cscov;
-	__u8		partial_cov;
 };
 #define UDP_SKB_CB(__skb)	((struct udp_skb_cb *)((__skb)->cb))
 
@@ -215,7 +213,7 @@
 struct sk_buff;
 
 /*
- *	Generic checksumming routines for UDP(-Lite) v4 and v6
+ *	Generic checksumming routines for UDP v4 and v6
  */
 static inline __sum16 __udp_lib_checksum_complete(struct sk_buff *skb)
 {
@@ -308,7 +306,7 @@
 	numa_drop_add(&udp_sk(sk)->drop_counters, 1);
 }
 
-/* hash routines shared between UDPv4/6 and UDP-Litev4/6 */
+/* hash routines shared between UDPv4/6 */
 static inline int udp_lib_hash(struct sock *sk)
 {
 	BUG();
@@ -524,36 +522,26 @@
 }
 
 /*
- * 	SNMP statistics for UDP and UDP-Lite
+ * 	SNMP statistics for UDP
  */
-#define UDP_INC_STATS(net, field, is_udplite)		      do { \
-	if (is_udplite) SNMP_INC_STATS((net)->mib.udplite_statistics, field);       \
-	else		SNMP_INC_STATS((net)->mib.udp_statistics, field);  }  while(0)
-#define __UDP_INC_STATS(net, field, is_udplite) 	      do { \
-	if (is_udplite) __SNMP_INC_STATS((net)->mib.udplite_statistics, field);         \
-	else		__SNMP_INC_STATS((net)->mib.udp_statistics, field);    }  while(0)
-
-#define __UDP6_INC_STATS(net, field, is_udplite)	    do { \
-	if (is_udplite) __SNMP_INC_STATS((net)->mib.udplite_stats_in6, field);\
-	else		__SNMP_INC_STATS((net)->mib.udp_stats_in6, field);  \
-} while(0)
-#define UDP6_INC_STATS(net, field, __lite)		    do { \
-	if (__lite) SNMP_INC_STATS((net)->mib.udplite_stats_in6, field);  \
-	else	    SNMP_INC_STATS((net)->mib.udp_stats_in6, field);      \
-} while(0)
+#define UDP_INC_STATS(net, field)		      SNMP_INC_STATS((net)->mib.udp_statistics, field)
+#define __UDP_INC_STATS(net, field) 	      __SNMP_INC_STATS((net)->mib.udp_statistics, field)
+
+#define __UDP6_INC_STATS(net, field)	    __SNMP_INC_STATS((net)->mib.udp_stats_in6, field)
+#define UDP6_INC_STATS(net, field)		    SNMP_INC_STATS((net)->mib.udp_stats_in6, field)
 
 #if IS_ENABLED(CONFIG_IPV6)
 #define __UDPX_MIB(sk, ipv4)						\
 ({									\
-	ipv4 ? (IS_UDPLITE(sk) ? sock_net(sk)->mib.udplite_statistics :	\
+	ipv4 ? (	\
 				 sock_net(sk)->mib.udp_statistics) :	\
-		(IS_UDPLITE(sk) ? sock_net(sk)->mib.udplite_stats_in6 :	\
+		(	\
 				 sock_net(sk)->mib.udp_stats_in6);	\
 })
 #else
 #define __UDPX_MIB(sk, ipv4)						\
 ({									\
-	IS_UDPLITE(sk) ? sock_net(sk)->mib.udplite_statistics :		\
+			\
 			 sock_net(sk)->mib.udp_statistics;		\
 })
 #endif
@@ -649,8 +637,6 @@
 
 static inline void udp_post_segment_fix_csum(struct sk_buff *skb)
 {
-	/* UDP-lite can't land here - no GRO */
-	WARN_ON_ONCE(UDP_SKB_CB(skb)->partial_cov);
 
 	/* UDP packets generated with UDP_SEGMENT and traversing:
 	 *
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/udp_tunnel.h linux-master/include/net/udp_tunnel.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/udp_tunnel.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/udp_tunnel.h	2025-10-20 00:41:14.000000000 -0300
@@ -31,7 +31,7 @@
 	__be16			local_udp_port;
 	__be16			peer_udp_port;
 	int			bind_ifindex;
-	unsigned int		use_udp_checksums:1,
+	unsigned int		XXXXX:1,
 				use_udp6_tx_checksums:1,
 				use_udp6_rx_checksums:1,
 				ipv6_v6only:1;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/xfrm.h linux-master/include/net/xfrm.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/net/xfrm.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/net/xfrm.h	2025-10-20 00:41:14.000000000 -0300
@@ -975,7 +975,6 @@
 	switch(fl->flowi_proto) {
 	case IPPROTO_TCP:
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE:
 	case IPPROTO_SCTP:
 		port = uli->ports.sport;
 		break;
@@ -1002,7 +1001,6 @@
 	switch(fl->flowi_proto) {
 	case IPPROTO_TCP:
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE:
 	case IPPROTO_SCTP:
 		port = uli->ports.dport;
 		break;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/trace/events/sock.h linux-master/include/trace/events/sock.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/trace/events/sock.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/trace/events/sock.h	2025-10-20 00:41:14.000000000 -0300
@@ -19,8 +19,7 @@
 /* The protocol traced by inet_sock_set_state */
 #define inet_protocol_names		\
 		EM(IPPROTO_TCP)			\
-		EM(IPPROTO_SCTP)		\
-		EMe(IPPROTO_MPTCP)
+		EM(IPPROTO_SCTP)		
 
 #define tcp_state_names			\
 		EM(TCP_ESTABLISHED)		\
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/bpf.h linux-master/include/uapi/linux/bpf.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/bpf.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/uapi/linux/bpf.h	2025-10-20 00:41:14.000000000 -0300
@@ -5612,12 +5612,6 @@
  * 		Map value associated to *key* on *cpu*, or **NULL** if no entry
  * 		was found or *cpu* is invalid.
  *
- * struct mptcp_sock *bpf_skc_to_mptcp_sock(void *sk)
- *	Description
- *		Dynamically cast a *sk* pointer to a *mptcp_sock* pointer.
- *	Return
- *		*sk* if casting is valid, or **NULL** otherwise.
- *
  * long bpf_dynptr_from_mem(void *data, u32 size, u64 flags, struct bpf_dynptr *ptr)
  *	Description
  *		Get a dynptr to local memory *data*.
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/inet_diag.h linux-master/include/uapi/linux/inet_diag.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/inet_diag.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/uapi/linux/inet_diag.h	2025-10-20 00:41:14.000000000 -0300
@@ -170,7 +170,6 @@
 	INET_ULP_INFO_UNSPEC,
 	INET_ULP_INFO_NAME,
 	INET_ULP_INFO_TLS,
-	INET_ULP_INFO_MPTCP,
 	__INET_ULP_INFO_MAX,
 };
 #define INET_ULP_INFO_MAX (__INET_ULP_INFO_MAX - 1)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/in.h linux-master/include/uapi/linux/in.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/in.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/uapi/linux/in.h	2025-10-20 00:41:14.000000000 -0300
@@ -73,8 +73,6 @@
 #define IPPROTO_L2TP		IPPROTO_L2TP
   IPPROTO_SCTP = 132,		/* Stream Control Transport Protocol	*/
 #define IPPROTO_SCTP		IPPROTO_SCTP
-  IPPROTO_UDPLITE = 136,	/* UDP-Lite (RFC 3828)			*/
-#define IPPROTO_UDPLITE		IPPROTO_UDPLITE
   IPPROTO_MPLS = 137,		/* MPLS in IP (RFC 4023)		*/
 #define IPPROTO_MPLS		IPPROTO_MPLS
   IPPROTO_ETHERNET = 143,	/* Ethernet-within-IPv6 Encapsulation	*/
@@ -85,8 +83,6 @@
 #define IPPROTO_RAW		IPPROTO_RAW
   IPPROTO_SMC = 256,		/* Shared Memory Communications		*/
 #define IPPROTO_SMC		IPPROTO_SMC
-  IPPROTO_MPTCP = 262,		/* Multipath TCP connection		*/
-#define IPPROTO_MPTCP		IPPROTO_MPTCP
   IPPROTO_MAX
 };
 #endif
@@ -166,7 +162,6 @@
 #define MCAST_MSFILTER			48
 #define IP_MULTICAST_ALL		49
 #define IP_UNICAST_IF			50
-#define IP_LOCAL_PORT_RANGE		51
 #define IP_PROTOCOL			52
 
 #define MCAST_EXCLUDE	0
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/netfilter/nfnetlink_cttimeout.h linux-master/include/uapi/linux/netfilter/nfnetlink_cttimeout.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/netfilter/nfnetlink_cttimeout.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/uapi/linux/netfilter/nfnetlink_cttimeout.h	2025-10-20 00:41:14.000000000 -0300
@@ -56,13 +56,6 @@
 };
 #define CTA_TIMEOUT_UDP_MAX (__CTA_TIMEOUT_UDP_MAX - 1)
 
-enum ctattr_timeout_udplite {
-	CTA_TIMEOUT_UDPLITE_UNSPEC,
-	CTA_TIMEOUT_UDPLITE_UNREPLIED,
-	CTA_TIMEOUT_UDPLITE_REPLIED,
-	__CTA_TIMEOUT_UDPLITE_MAX
-};
-#define CTA_TIMEOUT_UDPLITE_MAX (__CTA_TIMEOUT_UDPLITE_MAX - 1)
 
 enum ctattr_timeout_icmp {
 	CTA_TIMEOUT_ICMP_UNSPEC,
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/snmp.h linux-master/include/uapi/linux/snmp.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/snmp.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/uapi/linux/snmp.h	2025-10-20 00:41:14.000000000 -0300
@@ -258,13 +258,6 @@
 	LINUX_MIB_TCPOFOMERGE,			/* TCPOFOMerge */
 	LINUX_MIB_TCPCHALLENGEACK,		/* TCPChallengeACK */
 	LINUX_MIB_TCPSYNCHALLENGE,		/* TCPSYNChallenge */
-	LINUX_MIB_TCPFASTOPENACTIVE,		/* TCPFastOpenActive */
-	LINUX_MIB_TCPFASTOPENACTIVEFAIL,	/* TCPFastOpenActiveFail */
-	LINUX_MIB_TCPFASTOPENPASSIVE,		/* TCPFastOpenPassive*/
-	LINUX_MIB_TCPFASTOPENPASSIVEFAIL,	/* TCPFastOpenPassiveFail */
-	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW,	/* TCPFastOpenListenOverflow */
-	LINUX_MIB_TCPFASTOPENCOOKIEREQD,	/* TCPFastOpenCookieReqd */
-	LINUX_MIB_TCPFASTOPENBLACKHOLE,		/* TCPFastOpenBlackholeDetect */
 	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES, /* TCPSpuriousRtxHostQueues */
 	LINUX_MIB_BUSYPOLLRXPACKETS,		/* BusyPollRxPackets */
 	LINUX_MIB_TCPAUTOCORKING,		/* TCPAutoCorking */
@@ -293,7 +286,6 @@
 	LINUX_MIB_TCPZEROWINDOWDROP,		/* TCPZeroWindowDrop */
 	LINUX_MIB_TCPRCVQDROP,			/* TCPRcvQDrop */
 	LINUX_MIB_TCPWQUEUETOOBIG,		/* TCPWqueueTooBig */
-	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY,	/* TCPFastOpenPassiveAltKey */
 	LINUX_MIB_TCPTIMEOUTREHASH,		/* TCPTimeoutRehash */
 	LINUX_MIB_TCPDUPLICATEDATAREHASH,	/* TCPDuplicateDataRehash */
 	LINUX_MIB_TCPDSACKRECVSEGS,		/* TCPDSACKRecvSegs */
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/tc_act/tc_csum.h linux-master/include/uapi/linux/tc_act/tc_csum.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/tc_act/tc_csum.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/uapi/linux/tc_act/tc_csum.h	2025-10-20 00:41:14.000000000 -0300
@@ -20,7 +20,7 @@
 	TCA_CSUM_UPDATE_FLAG_IGMP    = 4,
 	TCA_CSUM_UPDATE_FLAG_TCP     = 8,
 	TCA_CSUM_UPDATE_FLAG_UDP     = 16,
-	TCA_CSUM_UPDATE_FLAG_UDPLITE = 32,
+	TCA_CSUM_UPDATE_FLAG_UDPZZZZ = 32,
 	TCA_CSUM_UPDATE_FLAG_SCTP    = 64,
 };
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/tcp.h linux-master/include/uapi/linux/tcp.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/include/uapi/linux/tcp.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/include/uapi/linux/tcp.h	2025-10-20 00:41:14.000000000 -0300
@@ -113,18 +113,14 @@
 #define TCP_REPAIR_QUEUE	20
 #define TCP_QUEUE_SEQ		21
 #define TCP_REPAIR_OPTIONS	22
-#define TCP_FASTOPEN		23	/* Enable FastOpen on listeners */
 #define TCP_TIMESTAMP		24
 #define TCP_NOTSENT_LOWAT	25	/* limit number of unsent bytes in write queue */
 #define TCP_CC_INFO		26	/* Get Congestion Control (optional) info */
 #define TCP_SAVE_SYN		27	/* Record SYN headers for new connections */
 #define TCP_SAVED_SYN		28	/* Get SYN headers recorded for connection */
 #define TCP_REPAIR_WINDOW	29	/* Get/set window parameters */
-#define TCP_FASTOPEN_CONNECT	30	/* Attempt FastOpen with connect */
 #define TCP_ULP			31	/* Attach a ULP to a TCP connection */
 #define TCP_MD5SIG_EXT		32	/* TCP MD5 Signature with extensions */
-#define TCP_FASTOPEN_KEY	33	/* Set the key for Fast Open (cookie) */
-#define TCP_FASTOPEN_NO_COOKIE	34	/* Enable TFO without a TFO cookie */
 #define TCP_ZEROCOPY_RECEIVE	35
 #define TCP_INQ			36	/* Notify bytes available to read as a cmsg on read */
 
@@ -138,7 +134,6 @@
 #define TCP_AO_GET_KEYS		41	/* List MKT(s) */
 #define TCP_AO_REPAIR		42	/* Get/Set SNEs and ISNs */
 
-#define TCP_IS_MPTCP		43	/* Is MPTCP being used? */
 #define TCP_RTO_MAX_MS		44	/* max rto time in ms */
 #define TCP_RTO_MIN_US		45	/* min rto time in us */
 #define TCP_DELACK_MAX_US	46	/* max delayed ack time in us */
@@ -168,21 +163,12 @@
 	TCP_QUEUES_NR,
 };
 
-/* why fastopen failed from client perspective */
-enum tcp_fastopen_client_fail {
-	TFO_STATUS_UNSPEC, /* catch-all */
-	TFO_COOKIE_UNAVAILABLE, /* if not in TFO_CLIENT_NO_COOKIE mode */
-	TFO_DATA_NOT_ACKED, /* SYN-ACK did not ack SYN data */
-	TFO_SYN_RETRANSMITTED, /* SYN-ACK did not ack SYN data after timeout */
-};
-
 /* for TCP_INFO socket option */
 #define TCPI_OPT_TIMESTAMPS	1
 #define TCPI_OPT_SACK		2
 #define TCPI_OPT_WSCALE		4
 #define TCPI_OPT_ECN		8 /* ECN was negociated at TCP session init */
 #define TCPI_OPT_ECN_SEEN	16 /* we received at least one packet with ECT */
-#define TCPI_OPT_SYN_DATA	32 /* SYN-ACK acked data in SYN sent or rcvd */
 #define TCPI_OPT_USEC_TS	64 /* usec timestamps */
 #define TCPI_OPT_TFO_CHILD	128 /* child from a Fast Open option on SYN */
 
@@ -234,7 +220,7 @@
 	__u8	tcpi_backoff;
 	__u8	tcpi_options;
 	__u8	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
-	__u8	tcpi_delivery_rate_app_limited:1, tcpi_fastopen_client_fail:2;
+	__u8	tcpi_delivery_rate_app_limited:1, XXXXXXXXXXXXXXX:2;
 
 	__u32	tcpi_rto;
 	__u32	tcpi_ato;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/Kconfig linux-master/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -29,6 +29,9 @@
 
 source "lib/Kconfig.debug"
 
-source "Documentation/Kconfig"
-
 source "io_uring/Kconfig"
+
+source "Kconfig2"
+source "Kconfig-sysctl"
+source "drivers/net/xgw/Kconfig"
+source "drivers/net/clf/Kconfig"
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/Kconfig2 linux-master/Kconfig2
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/Kconfig2	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/Kconfig2	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,40 @@
+
+config    NO_SNMP
+    bool "NO_SNMP"
+    default y
+
+config    VLAN
+    bool "VLAN"
+    default y
+
+config    VLAN_PASS
+    bool "VLAN_PASS"
+    default n
+
+config    VLAN_DROP
+    bool "VLAN_DROP"
+    default n
+
+config    VLAN_CORE
+    bool "VLAN_CORE"
+    default y
+
+config    VLAN_IXGBE
+    bool "VLAN_IXGBE"
+    default y
+
+menuconfig NET_SOCKMARKS
+    bool  "NET_SOCKMARKS"
+    default n
+
+if NET_SOCKMARKS
+
+config   NET_SOCKMARKS_0
+    int "NET_SOCKMARKS_0"
+    default 10
+
+config   NET_SOCKMARKS_N
+    int "NET_SOCKMARKS_N"
+    default 3
+
+endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/Kconfig-sysctl linux-master/Kconfig-sysctl
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/Kconfig-sysctl	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/Kconfig-sysctl	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,168 @@
+
+menu "SYSCTL"
+
+# IPDEFTTL
+config   SYSCTL_IP_DEFAULT_TTL
+    int "SYSCTL_IP_DEFAULT_TTL"
+    default 64
+
+# TCP_SYN_RETRIES
+config   SYSCTL_TCP_SYN_RETRIES
+    int "SYSCTL_TCP_SYN_RETRIES"
+    default 6
+
+# TCP_SYNACK_RETRIES
+config   SYSCTL_TCP_SYNACK_RETRIES
+    int "SYSCTL_TCP_SYNACK_RETRIES"
+    default 5
+
+# TCP_FIN_TIMEOUT -> TCP_TIMEWAIT_LEN -> (60*HZ)
+config   SYSCTL_TCP_FIN_TIMEOUT_
+    int "SYSCTL_TCP_FIN_TIMEOUT"
+    default 60
+
+config   SYSCTL_TCP_RETRANS_COLLAPSE
+    int "SYSCTL_TCP_RETRANS_COLLAPSE"
+    default 1
+
+config   SYSCTL_TCP_MAX_REORDERING
+    int "SYSCTL_TCP_MAX_REORDERING"
+    default 300
+
+config   SYSCTL_TCP_NOMETRICS_SAVE
+    int "SYSCTL_TCP_NOMETRICS_SAVE"
+    default 0
+
+config   SYSCTL_TCP_NO_SSTHRESH_METRICS_SAVE
+    int "SYSCTL_TCP_NO_SSTHRESH_METRICS_SAVE"
+    default 1
+
+config   SYSCTL_TCP_FRTO
+    int "SYSCTL_TCP_FRTO"
+    default 2
+
+config   SYSCTL_TCP_MODERATE_RCVBUF
+    int "SYSCTL_TCP_MODERATE_RCVBUF"
+    default 1
+
+config   SYSCTL_TCP_ABORT_ON_OVERFLOW
+    int "SYSCTL_TCP_ABORT_ON_OVERFLOW"
+    default 0
+
+config   SYSCTL_TCP_STDURG
+    int "SYSCTL_TCP_STDURG"
+    default 0
+
+config   SYSCTL_TCP_MIGRATE_REQ
+    int "SYSCTL_TCP_MIGRATE_REQ"
+    default 0
+
+config   SYSCTL_TCP_SYNCOOKIES
+    int "SYSCTL_TCP_SYNCOOKIES"
+    default 1
+
+config   SYSCTL_TCP_REORDERING
+    int "SYSCTL_TCP_REORDERING"
+    default 3
+
+config   SYSCTL_TCP_RETRIES1
+    int "SYSCTL_TCP_RETRIES1"
+    default 3
+
+config   SYSCTL_TCP_RETRIES2
+    int "SYSCTL_TCP_RETRIES2"
+    default 15
+
+config   SYSCTL_TCP_ORPHAN_RETRIES
+    int "SYSCTL_TCP_ORPHAN_RETRIES"
+    default 0
+
+config   SYSCTL_TCP_KEEPALIVE_INTVL_
+    int "SYSCTL_TCP_KEEPALIVE_INTVL"
+    default 75
+
+config   SYSCTL_TCP_KEEPALIVE_TIME_
+    int "SYSCTL_TCP_KEEPALIVE_TIME"
+    default 7200
+
+config   SYSCTL_TCP_KEEPALIVE_PROBES_
+    int "SYSCTL_TCP_KEEPALIVE_PROBES"
+    default 9
+
+config   SYSCTL_TCP_SYN_LINEAR_TIMEOUTS
+    int "SYSCTL_TCP_SYN_LINEAR_TIMEOUTS"
+    default 4
+
+config   SYSCTL_TCP_MIN_TSO_SEGS
+    int "SYSCTL_TCP_MIN_TSO_SEGS"
+    default 2
+
+config   SYSCTL_TCP_PROBE_INTERVAL
+    int "SYSCTL_TCP_PROBE_INTERVAL"
+    default 600
+
+config   SYSCTL_TCP_TIMESTAMPS
+    int "SYSCTL_TCP_TIMESTAMPS"
+    default 1
+
+config   SYSCTL_TCP_PROBE_THRESHOLD
+    int "SYSCTL_TCP_PROBE_THRESHOLD"
+    default 8
+
+config   SYSCTL_UDP_CHILD_HASH_ENTRIES
+    int "SYSCTL_UDP_CHILD_HASH_ENTRIES"
+    default 0
+
+config   SYSCTL_MAX_SYN_BACKLOG
+    int "SYSCTL_MAX_SYN_BACKLOG"
+    default 1024
+
+config   SYSCTL_IP_LOCAL_PORTS_MIN
+    int "SYSCTL_IP_LOCAL_PORTS_MIN"
+    default 2000
+
+config   SYSCTL_IP_LOCAL_PORTS_MAX
+    int "SYSCTL_IP_LOCAL_PORTS_MAX"
+    default 65533
+
+config   SYSCTL_ICMP_ECHO_IGNORE_ALL
+    int "SYSCTL_ICMP_ECHO_IGNORE_ALL"
+    default 0
+
+config   SYSCTL_ICMP_ECHO_IGNORE_BROADCASTS
+    int "SYSCTL_ICMP_ECHO_IGNORE_BROADCASTS"
+    default 1
+
+config   SYSCTL_ICMP_ECHO_ENABLE_PROBE
+    int "SYSCTL_ICMP_ECHO_ENABLE_PROBE"
+    default 0
+
+config   SYSCTL_ICMPV6_ECHO_IGNORE_ALL
+    int "SYSCTL_ICMPV6_ECHO_IGNORE_ALL"
+    default 0
+
+config   SYSCTL_ICMPV6_ECHO_IGNORE_MULTICAST
+    int "SYSCTL_ICMPV6_ECHO_IGNORE_MULTICAST"
+    default 0
+
+config   SYSCTL_ICMPV6_ECHO_IGNORE_ANYCAST
+    int "SYSCTL_ICMPV6_ECHO_IGNORE_ANYCAST"
+    default 0
+
+config   SYSCTL_ICMPV6_ERROR_ANYCAST_AS_UNICAST
+    int "SYSCTL_ICMPV6_ERROR_ANYCAST_AS_UNICAST"
+    default 0
+
+config   SYSCTL_ICMPV6_TIME_
+    int "SYSCTL_ICMPV6_TIME"
+    default 1
+
+config   SYSCTL_TCP_WORKAROUND_SIGNED_WINDOWS
+    int "SYSCTL_TCP_WORKAROUND_SIGNED_WINDOWS"
+    default 0
+
+config   SYSCTL_TCP_REFLECT_TOS
+    int "SYSCTL_TCP_REFLECT_TOS"
+    default 0
+    
+endmenu
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/kernel/bpf/verifier.c linux-master/kernel/bpf/verifier.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/kernel/bpf/verifier.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/kernel/bpf/verifier.c	2025-10-20 00:41:14.000000000 -0300
@@ -499,7 +499,6 @@
 		func_id == BPF_FUNC_skc_to_tcp_sock ||
 		func_id == BPF_FUNC_skc_to_tcp6_sock ||
 		func_id == BPF_FUNC_skc_to_udp6_sock ||
-		func_id == BPF_FUNC_skc_to_mptcp_sock ||
 		func_id == BPF_FUNC_skc_to_tcp_timewait_sock ||
 		func_id == BPF_FUNC_skc_to_tcp_request_sock;
 }
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/kernel/Kconfig.hz linux-master/kernel/Kconfig.hz
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/kernel/Kconfig.hz	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/kernel/Kconfig.hz	2025-10-20 00:41:14.000000000 -0300
@@ -16,6 +16,11 @@
 	 environment leading to NR_CPUS * HZ number of timer interrupts
 	 per second.
 
+	config HZ_24
+		bool "24 HZ"
+
+	config HZ_1812
+		bool "1812 HZ"
 
 	config HZ_100
 		bool "100 HZ"
@@ -50,10 +55,12 @@
 
 config HZ
 	int
+	default 24 if HZ_24
 	default 100 if HZ_100
 	default 250 if HZ_250
 	default 300 if HZ_300
 	default 1000 if HZ_1000
+	default 1812 if HZ_1812
 
 config SCHED_HRTICK
 	def_bool HIGH_RES_TIMERS
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/kernel/Kconfig.kexec linux-master/kernel/Kconfig.kexec
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/kernel/Kconfig.kexec	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/kernel/Kconfig.kexec	2025-10-20 00:41:14.000000000 -0300
@@ -127,9 +127,6 @@
 	  (CONFIG_RELOCATABLE=y).
 	  For more details see Documentation/admin-guide/kdump/kdump.rst
 
-	  For s390, this option also enables zfcpdump.
-	  See also <file:Documentation/arch/s390/zfcpdump.rst>
-
 config CRASH_DM_CRYPT
 	bool "Support saving crash dump to dm-crypt encrypted volume"
 	depends on KEXEC_FILE
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/kernel/trace/bpf_trace.c linux-master/kernel/trace/bpf_trace.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/kernel/trace/bpf_trace.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/kernel/trace/bpf_trace.c	2025-10-20 00:41:14.000000000 -0300
@@ -1706,8 +1706,6 @@
 		return &bpf_skc_to_udp6_sock_proto;
 	case BPF_FUNC_skc_to_unix_sock:
 		return &bpf_skc_to_unix_sock_proto;
-	case BPF_FUNC_skc_to_mptcp_sock:
-		return &bpf_skc_to_mptcp_sock_proto;
 	case BPF_FUNC_sk_storage_get:
 		return &bpf_sk_storage_get_tracing_proto;
 	case BPF_FUNC_sk_storage_delete:
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/crc/Makefile linux-master/lib/crc/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/crc/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/lib/crc/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -15,7 +15,6 @@
 CFLAGS_crc-t10dif-main.o += -I$(src)/$(SRCARCH)
 crc-t10dif-$(CONFIG_ARM) += arm/crc-t10dif-core.o
 crc-t10dif-$(CONFIG_ARM64) += arm64/crc-t10dif-core.o
-crc-t10dif-$(CONFIG_PPC) += powerpc/crct10dif-vpmsum_asm.o
 crc-t10dif-$(CONFIG_RISCV) += riscv/crc16_msb.o
 crc-t10dif-$(CONFIG_X86) += x86/crc16-msb-pclmul.o
 endif
@@ -26,10 +25,7 @@
 CFLAGS_crc32-main.o += -I$(src)/$(SRCARCH)
 crc32-$(CONFIG_ARM) += arm/crc32-core.o
 crc32-$(CONFIG_ARM64) += arm64/crc32-core.o
-crc32-$(CONFIG_PPC) += powerpc/crc32c-vpmsum_asm.o
 crc32-$(CONFIG_RISCV) += riscv/crc32_lsb.o riscv/crc32_msb.o
-crc32-$(CONFIG_S390) += s390/crc32le-vx.o s390/crc32be-vx.o
-crc32-$(CONFIG_SPARC) += sparc/crc32c_asm.o
 crc32-$(CONFIG_X86) += x86/crc32-pclmul.o
 crc32-$(CONFIG_X86_64) += x86/crc32c-3way.o
 endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/crypto/Makefile linux-master/lib/crypto/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/crypto/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/lib/crypto/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -62,9 +62,7 @@
 AFLAGS_mips/chacha-core.o += -O2 # needed to fill branch delay slots
 endif
 
-libchacha-$(CONFIG_PPC) += powerpc/chacha-p10le-8x.o
 libchacha-$(CONFIG_RISCV) += riscv/chacha-riscv64-zvkb.o
-libchacha-$(CONFIG_S390) += s390/chacha-s390.o
 libchacha-$(CONFIG_X86) += x86/chacha-ssse3-x86_64.o \
 			   x86/chacha-avx2-x86_64.o \
 			   x86/chacha-avx512vl-x86_64.o
@@ -97,7 +95,6 @@
 ifeq ($(CONFIG_CRYPTO_LIB_CURVE25519_ARCH),y)
 CFLAGS_curve25519.o += -I$(src)/$(SRCARCH)
 libcurve25519-$(CONFIG_ARM) += arm/curve25519-core.o
-libcurve25519-$(CONFIG_PPC) += powerpc/curve25519-ppc64le_asm.o
 endif
 
 ################################################################################
@@ -111,8 +108,6 @@
 libmd5-y := md5.o
 ifeq ($(CONFIG_CRYPTO_LIB_MD5_ARCH),y)
 CFLAGS_md5.o += -I$(src)/$(SRCARCH)
-libmd5-$(CONFIG_PPC) += powerpc/md5-asm.o
-libmd5-$(CONFIG_SPARC) += sparc/md5_asm.o
 endif # CONFIG_CRYPTO_LIB_MD5_ARCH
 
 ################################################################################
@@ -156,8 +151,6 @@
 targets += mips/poly1305-core.S
 endif
 
-libpoly1305-$(CONFIG_PPC) += powerpc/poly1305-p10le_64.o
-
 ifeq ($(CONFIG_RISCV),y)
 libpoly1305-y += riscv/poly1305-core.o
 poly1305-perlasm-flavour-$(CONFIG_32BIT) := 32
@@ -198,11 +191,6 @@
 				      arm/sha1-ce-core.o
 endif
 libsha1-$(CONFIG_ARM64) += arm64/sha1-ce-core.o
-ifeq ($(CONFIG_PPC),y)
-libsha1-y += powerpc/sha1-powerpc-asm.o
-libsha1-$(CONFIG_SPE) += powerpc/sha1-spe-asm.o
-endif
-libsha1-$(CONFIG_SPARC) += sparc/sha1_asm.o
 libsha1-$(CONFIG_X86) += x86/sha1-ssse3-and-avx.o \
 			 x86/sha1-avx2-asm.o \
 			 x86/sha1-ni-asm.o
@@ -229,9 +217,7 @@
 libsha256-$(CONFIG_KERNEL_MODE_NEON) += arm64/sha256-ce.o
 endif
 
-libsha256-$(CONFIG_PPC) += powerpc/sha256-spe-asm.o
 libsha256-$(CONFIG_RISCV) += riscv/sha256-riscv64-zvknha_or_zvknhb-zvkb.o
-libsha256-$(CONFIG_SPARC) += sparc/sha256_asm.o
 libsha256-$(CONFIG_X86) += x86/sha256-ssse3-asm.o \
 			   x86/sha256-avx-asm.o \
 			   x86/sha256-avx2-asm.o \
@@ -260,7 +246,6 @@
 endif
 
 libsha512-$(CONFIG_RISCV) += riscv/sha512-riscv64-zvknhb-zvkb.o
-libsha512-$(CONFIG_SPARC) += sparc/sha512_asm.o
 libsha512-$(CONFIG_X86) += x86/sha512-ssse3-asm.o \
 			   x86/sha512-avx-asm.o \
 			   x86/sha512-avx2-asm.o
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/Kconfig linux-master/lib/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/lib/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -180,13 +180,6 @@
 	tristate
 	select BITREVERSE
 
-config ZLIB_DFLTCC
-	def_bool y
-	depends on S390
-	prompt "Enable s390x DEFLATE CONVERSION CALL support for kernel zlib"
-	help
-	 Enable s390x hardware support for zlib in the kernel.
-
 config LZO_COMPRESS
 	tristate
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/Kconfig.debug linux-master/lib/Kconfig.debug
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/Kconfig.debug	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/lib/Kconfig.debug	2025-10-20 00:41:14.000000000 -0300
@@ -1862,35 +1862,6 @@
 
 source "kernel/trace/Kconfig"
 
-config PROVIDE_OHCI1394_DMA_INIT
-	bool "Remote debugging over FireWire early on boot"
-	depends on PCI && X86
-	help
-	  If you want to debug problems which hang or crash the kernel early
-	  on boot and the crashing machine has a FireWire port, you can use
-	  this feature to remotely access the memory of the crashed machine
-	  over FireWire. This employs remote DMA as part of the OHCI1394
-	  specification which is now the standard for FireWire controllers.
-
-	  With remote DMA, you can monitor the printk buffer remotely using
-	  firescope and access all memory below 4GB using fireproxy from gdb.
-	  Even controlling a kernel debugger is possible using remote DMA.
-
-	  Usage:
-
-	  If ohci1394_dma=early is used as boot parameter, it will initialize
-	  all OHCI1394 controllers which are found in the PCI config space.
-
-	  As all changes to the FireWire bus such as enabling and disabling
-	  devices cause a bus reset and thereby disable remote DMA for all
-	  devices, be sure to have the cable plugged and FireWire enabled on
-	  the debugging host before booting the debug target for debugging.
-
-	  This code (~1k) is freed after boot. By then, the firewire stack
-	  in charge of the OHCI-1394 controllers should be used instead.
-
-	  See Documentation/core-api/debugging-via-ohci1394.rst for more information.
-
 source "samples/Kconfig"
 
 config ARCH_HAS_DEVMEM_IS_ALLOWED
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/Makefile linux-master/lib/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/lib/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -153,7 +153,6 @@
 obj-$(CONFIG_842_DECOMPRESS) += 842/
 obj-$(CONFIG_ZLIB_INFLATE) += zlib_inflate/
 obj-$(CONFIG_ZLIB_DEFLATE) += zlib_deflate/
-obj-$(CONFIG_ZLIB_DFLTCC) += zlib_dfltcc/
 obj-$(CONFIG_REED_SOLOMON) += reed_solomon/
 obj-$(CONFIG_BCH) += bch.o
 obj-$(CONFIG_LZO_COMPRESS) += lzo/
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/raid6/Makefile linux-master/lib/raid6/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/lib/raid6/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/lib/raid6/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -8,7 +8,6 @@
 raid6_pq-$(CONFIG_ALTIVEC) += altivec1.o altivec2.o altivec4.o altivec8.o \
                               vpermxor1.o vpermxor2.o vpermxor4.o vpermxor8.o
 raid6_pq-$(CONFIG_KERNEL_MODE_NEON) += neon.o neon1.o neon2.o neon4.o neon8.o recov_neon.o recov_neon_inner.o
-raid6_pq-$(CONFIG_S390) += s390vx8.o recov_s390xc.o
 raid6_pq-$(CONFIG_LOONGARCH) += loongarch_simd.o recov_loongarch_simd.o
 raid6_pq-$(CONFIG_RISCV_ISA_V) += rvv.o recov_rvv.o
 
@@ -71,10 +70,6 @@
 $(obj)/neon%.c: $(src)/neon.uc $(src)/unroll.awk FORCE
 	$(call if_changed,unroll)
 
-targets += s390vx8.c
-$(obj)/s390vx%.c: $(src)/s390vx.uc $(src)/unroll.awk FORCE
-	$(call if_changed,unroll)
-
 quiet_cmd_mktable = TABLE   $@
       cmd_mktable = $(obj)/mktables > $@
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/Makefile linux-master/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -864,6 +864,16 @@
 endif # may-sync-config
 endif # need-config
 
+KBUILD_CFLAGS	+= -Wfatal-errors
+KBUILD_CFLAGS	+= -Wunused-function
+KBUILD_CFLAGS	+= -Wno-array-bounds
+KBUILD_CFLAGS	+= -Wno-unused-label
+KBUILD_CFLAGS	+= -Wno-unused-variable
+KBUILD_CFLAGS	+= -Wno-declaration-after-statement
+KBUILD_CFLAGS	+= -Wmaybe-uninitialized
+KBUILD_CFLAGS	+= -Wuninitialized
+KBUILD_CFLAGS	+= -Wunused-function
+KBUILD_CFLAGS	+= -Wno-error=unused-function
 KBUILD_CFLAGS	+= -fno-delete-null-pointer-checks
 
 ifdef CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE
@@ -1186,7 +1196,7 @@
 ifeq ($(KBUILD_EXTMOD),)
 
 build-dir	:= .
-clean-dirs	:= $(sort . Documentation \
+clean-dirs	:= $(sort . \
 		     $(patsubst %/,%,$(filter %/, $(core-) \
 			$(drivers-) $(libs-))))
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/MAKEPATCH linux-master/MAKEPATCH
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/MAKEPATCH	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/MAKEPATCH	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,42 @@
+#!/bin/bash
+
+set -u
+
+LINUX_OLD=${1}
+LINUX_NEW=${2}
+
+[ -f ${LINUX_OLD}/Makefile ] || exit 1
+[ -f ${LINUX_NEW}/Makefile ] || exit 1
+
+REMOVED_DIRS=(
+    $(
+        (
+            (cd ${LINUX_OLD} && find . -type d)
+            (cd ${LINUX_NEW} && find . -type d)
+        ) | sort --reverse | uniq -u
+    )
+)
+
+( cd ${LINUX_OLD} && rm -fR -- ${REMOVED_DIRS[*]} )
+
+REMOVED_FILES=(
+    $(
+        (
+            (cd ${LINUX_OLD} && find .)
+            (cd ${LINUX_NEW} && find .)
+        ) | sort | uniq -u
+    )
+)
+
+( cd ${LINUX_OLD} && rm -fR -- ${REMOVED_FILES[*]} )
+
+echo '#!/bin/sh'
+echo 'set -u'
+echo 'rm -fR --' ${REMOVED_DIRS[*]}
+echo 'rm -f  --' ${REMOVED_FILES[*]}
+echo 'patch -p1 < "${0}"'
+echo 'x=$?'
+echo 'rm -f -- $(find . -type f -iname "*.orig")'
+echo 'exit $x'
+
+diff -Naur ${LINUX_OLD} ${LINUX_NEW}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/mm/ksm.c linux-master/mm/ksm.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/mm/ksm.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/mm/ksm.c	2025-10-20 00:41:14.000000000 -0300
@@ -710,7 +710,7 @@
 	if (ksm_test_exit(mm))
 		return NULL;
 	vma = vma_lookup(mm, addr);
-	if (!vma || !(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)
+	if (!vma || !vma->anon_vma)
 		return NULL;
 	return vma;
 }
@@ -1190,7 +1190,7 @@
 			goto mm_exiting;
 
 		for_each_vma(vmi, vma) {
-			if (!(vma->vm_flags & VM_MERGEABLE) || !vma->anon_vma)
+			if (!vma->anon_vma)
 				continue;
 			err = unmerge_ksm_pages(vma,
 						vma->vm_start, vma->vm_end, false);
@@ -2534,8 +2534,6 @@
 		goto no_vmas;
 
 	for_each_vma(vmi, vma) {
-		if (!(vma->vm_flags & VM_MERGEABLE))
-			continue;
 		if (ksm_scan.address < vma->vm_start)
 			ksm_scan.address = vma->vm_start;
 		if (!vma->anon_vma)
@@ -2715,9 +2713,6 @@
 {
 	int err;
 
-	if (!(vma->vm_flags & VM_MERGEABLE))
-		return 0;
-
 	if (vma->anon_vma) {
 		err = unmerge_ksm_pages(vma, vma->vm_start, vma->vm_end, true);
 		if (err)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/appletalk/ddp.c linux-master/net/appletalk/ddp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/appletalk/ddp.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/appletalk/ddp.c	2025-10-20 00:41:14.000000000 -0300
@@ -1665,10 +1665,7 @@
 		goto out;
 	}
 
-	if (sk->sk_no_check_tx)
-		ddp->deh_sum = 0;
-	else
-		ddp->deh_sum = atalk_checksum(skb, len + sizeof(*ddp));
+	ddp->deh_sum = 0;
 
 	/*
 	 * Loopback broadcast packets to non gateway targets (ie routes
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/bridge/netfilter/ebt_ip6.c linux-master/net/bridge/netfilter/ebt_ip6.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/bridge/netfilter/ebt_ip6.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/bridge/netfilter/ebt_ip6.c	2025-10-20 00:41:14.000000000 -0300
@@ -117,7 +117,6 @@
 			return -EINVAL;
 		if (info->protocol != IPPROTO_TCP &&
 		    info->protocol != IPPROTO_UDP &&
-		    info->protocol != IPPROTO_UDPLITE &&
 		    info->protocol != IPPROTO_SCTP &&
 		    info->protocol != IPPROTO_DCCP)
 			return -EINVAL;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/bridge/netfilter/ebt_ip.c linux-master/net/bridge/netfilter/ebt_ip.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/bridge/netfilter/ebt_ip.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/bridge/netfilter/ebt_ip.c	2025-10-20 00:41:14.000000000 -0300
@@ -116,7 +116,6 @@
 			return -EINVAL;
 		if (info->protocol != IPPROTO_TCP &&
 		    info->protocol != IPPROTO_UDP &&
-		    info->protocol != IPPROTO_UDPLITE &&
 		    info->protocol != IPPROTO_SCTP &&
 		    info->protocol != IPPROTO_DCCP)
 			 return -EINVAL;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/bridge/netfilter/ebt_log.c linux-master/net/bridge/netfilter/ebt_log.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/bridge/netfilter/ebt_log.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/bridge/netfilter/ebt_log.c	2025-10-20 00:41:14.000000000 -0300
@@ -54,7 +54,6 @@
 {
 	if (protocol == IPPROTO_TCP ||
 	    protocol == IPPROTO_UDP ||
-	    protocol == IPPROTO_UDPLITE ||
 	    protocol == IPPROTO_SCTP ||
 	    protocol == IPPROTO_DCCP) {
 		const struct tcpudphdr *pptr;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/dev.c linux-master/net/core/dev.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/dev.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/core/dev.c	2025-10-20 00:41:14.000000000 -0300
@@ -5846,6 +5846,10 @@
 	return 0;
 }
 
+#ifdef CONFIG_XGW
+extern int xgw_dev_in (struct sk_buff*);
+#endif
+	
 static int __netif_receive_skb_core(struct sk_buff **pskb, bool pfmemalloc,
 				    struct packet_type **ppt_prev)
 {
@@ -5862,7 +5866,6 @@
 
 	trace_netif_receive_skb(skb);
 
-	orig_dev = skb->dev;
 
 	skb_reset_network_header(skb);
 #if !defined(CONFIG_DEBUG_NET)
@@ -5875,6 +5878,20 @@
 #endif
 	skb_reset_mac_len(skb);
 
+	// NOTE: OLHA A MUDANCA QUE FIZEMOS AQUI
+	// PRIMEIRO TEM QUE DAR O skb_reset_network_header(), skb_reset_transport_header(), skb_reset_mac_len()
+	// E SO SETAR O orig_dev DEPOIS DISSO AQUI
+	//   (NO CASO DO DROP, CONFIRMAR QUE NAO USA O orig_dev)
+	// TODO: FIXME: DESCOBRIR O QUE CAUSA TANTOS SKBS NAO LINEARES AQUI
+#ifdef CONFIG_XGW
+#if 0
+	if (skb->dev->flags & IFF_XGW)
+#endif
+		if (xgw_dev_in(skb))
+			goto drop;
+#endif
+	orig_dev = skb->dev;
+
 	pt_prev = NULL;
 
 another_round:
@@ -5896,11 +5913,17 @@
 		}
 	}
 
-	if (eth_type_vlan(skb->protocol)) {
+#ifndef CONFIG_VLAN_PASS
+    switch (skb->protocol) { // eth_type_vlan
+        case htons(ETH_P_8021Q):
+        case htons(ETH_P_8021AD):
+#ifndef CONFIG_VLAN_DROP
 		skb = skb_vlan_untag(skb);
 		if (unlikely(!skb))
+#endif
 			goto out;
-	}
+    }
+#endif
 
 	if (skb_skip_tc_classify(skb))
 		goto skip_classify;
@@ -5946,6 +5969,7 @@
 		goto drop;
 	}
 
+#ifdef CONFIG_VLAN
 	if (skb_vlan_tag_present(skb)) {
 		if (pt_prev) {
 			ret = deliver_skb(skb, pt_prev, orig_dev);
@@ -5956,6 +5980,7 @@
 		else if (unlikely(!skb))
 			goto out;
 	}
+#endif
 
 	rx_handler = rcu_dereference(skb->dev->rx_handler);
 	if (rx_handler) {
@@ -5979,6 +6004,7 @@
 		}
 	}
 
+#ifdef CONFIG_VLAN
 	if (unlikely(skb_vlan_tag_present(skb)) && !netdev_uses_dsa(skb->dev)) {
 check_vlan_id:
 		if (skb_vlan_tag_get_id(skb)) {
@@ -6015,6 +6041,7 @@
 		 */
 		__vlan_hwaccel_clear_tag(skb);
 	}
+#endif
 
 	type = skb->protocol;
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/filter.c linux-master/net/core/filter.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/filter.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/core/filter.c	2025-10-20 00:41:14.000000000 -0300
@@ -79,7 +79,6 @@
 #include <linux/btf_ids.h>
 #include <net/tls.h>
 #include <net/xdp.h>
-#include <net/mptcp.h>
 #include <net/netfilter/nf_conntrack_bpf.h>
 #include <net/netkit.h>
 #include <linux/un.h>
@@ -5365,7 +5364,7 @@
 	/* Only some options are supported */
 	switch (optname) {
 	case TCP_BPF_IW:
-		if (val <= 0 || tp->data_segs_out > tp->syn_data)
+		if (val <= 0 || tp->data_segs_out > 0)
 			return -EINVAL;
 		tcp_snd_cwnd_set(tp, val);
 		break;
@@ -7471,7 +7470,7 @@
 	if (sk->sk_protocol != IPPROTO_TCP || sk->sk_state != TCP_LISTEN)
 		return -EINVAL;
 
-	if (!READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_syncookies))
+	if (!CONFIG_SYSCTL_TCP_SYNCOOKIES)
 		return -EINVAL;
 
 	if (!th->ack || th->rst || th->syn)
@@ -7544,7 +7543,7 @@
 	if (sk->sk_protocol != IPPROTO_TCP || sk->sk_state != TCP_LISTEN)
 		return -EINVAL;
 
-	if (!READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_syncookies))
+	if (!CONFIG_SYSCTL_TCP_SYNCOOKIES)
 		return -ENOENT;
 
 	if (!th->syn || th->ack || th->fin || th->rst)
@@ -11934,20 +11933,6 @@
 	.ret_btf_id		= &btf_sock_ids[BTF_SOCK_TYPE_UNIX],
 };
 
-BPF_CALL_1(bpf_skc_to_mptcp_sock, struct sock *, sk)
-{
-	BTF_TYPE_EMIT(struct mptcp_sock);
-	return (unsigned long)bpf_mptcp_sock_from_subflow(sk);
-}
-
-const struct bpf_func_proto bpf_skc_to_mptcp_sock_proto = {
-	.func		= bpf_skc_to_mptcp_sock,
-	.gpl_only	= false,
-	.ret_type	= RET_PTR_TO_BTF_ID_OR_NULL,
-	.arg1_type	= ARG_PTR_TO_SOCK_COMMON,
-	.ret_btf_id	= &btf_sock_ids[BTF_SOCK_TYPE_MPTCP],
-};
-
 BPF_CALL_1(bpf_sock_from_file, struct file *, file)
 {
 	return (unsigned long)sock_from_file(file);
@@ -11990,9 +11975,6 @@
 	case BPF_FUNC_skc_to_unix_sock:
 		func = &bpf_skc_to_unix_sock_proto;
 		break;
-	case BPF_FUNC_skc_to_mptcp_sock:
-		func = &bpf_skc_to_mptcp_sock_proto;
-		break;
 	case BPF_FUNC_ktime_get_coarse_ns:
 		return &bpf_ktime_get_coarse_ns_proto;
 	default:
@@ -12145,7 +12127,7 @@
 	}
 
 	if (sk->sk_type != SOCK_STREAM || sk->sk_state != TCP_LISTEN ||
-	    sk_is_mptcp(sk))
+	    0)
 		return -EINVAL;
 
 	if (attrs->mss < min_mss)
@@ -12164,7 +12146,7 @@
 		return -EINVAL;
 
 	if (attrs->tstamp_ok) {
-		if (!READ_ONCE(net->ipv4.sysctl_tcp_timestamps))
+		if (!CONFIG_SYSCTL_TCP_TIMESTAMPS)
 			return -EINVAL;
 
 		tsoff = attrs->rcv_tsecr - tcp_ns_to_ts(attrs->usec_ts_ok, tcp_clock_ns());
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/flow_dissector.c linux-master/net/core/flow_dissector.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/flow_dissector.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/core/flow_dissector.c	2025-10-20 00:41:14.000000000 -0300
@@ -1941,7 +1941,6 @@
 		break;
 	}
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE:
 		poff += sizeof(struct udphdr);
 		break;
 	/* For the rest, we do not really care about header
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/request_sock.c linux-master/net/core/request_sock.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/request_sock.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/core/request_sock.c	2025-10-20 00:41:14.000000000 -0300
@@ -33,95 +33,6 @@
 
 void reqsk_queue_alloc(struct request_sock_queue *queue)
 {
-	queue->fastopenq.rskq_rst_head = NULL;
-	queue->fastopenq.rskq_rst_tail = NULL;
-	queue->fastopenq.qlen = 0;
 
 	queue->rskq_accept_head = NULL;
 }
-
-/*
- * This function is called to set a Fast Open socket's "fastopen_rsk" field
- * to NULL when a TFO socket no longer needs to access the request_sock.
- * This happens only after 3WHS has been either completed or aborted (e.g.,
- * RST is received).
- *
- * Before TFO, a child socket is created only after 3WHS is completed,
- * hence it never needs to access the request_sock. things get a lot more
- * complex with TFO. A child socket, accepted or not, has to access its
- * request_sock for 3WHS processing, e.g., to retransmit SYN-ACK pkts,
- * until 3WHS is either completed or aborted. Afterwards the req will stay
- * until either the child socket is accepted, or in the rare case when the
- * listener is closed before the child is accepted.
- *
- * In short, a request socket is only freed after BOTH 3WHS has completed
- * (or aborted) and the child socket has been accepted (or listener closed).
- * When a child socket is accepted, its corresponding req->sk is set to
- * NULL since it's no longer needed. More importantly, "req->sk == NULL"
- * will be used by the code below to determine if a child socket has been
- * accepted or not, and the check is protected by the fastopenq->lock
- * described below.
- *
- * Note that fastopen_rsk is only accessed from the child socket's context
- * with its socket lock held. But a request_sock (req) can be accessed by
- * both its child socket through fastopen_rsk, and a listener socket through
- * icsk_accept_queue.rskq_accept_head. To protect the access a simple spin
- * lock per listener "icsk->icsk_accept_queue.fastopenq->lock" is created.
- * only in the rare case when both the listener and the child locks are held,
- * e.g., in inet_csk_listen_stop() do we not need to acquire the lock.
- * The lock also protects other fields such as fastopenq->qlen, which is
- * decremented by this function when fastopen_rsk is no longer needed.
- *
- * Note that another solution was to simply use the existing socket lock
- * from the listener. But first socket lock is difficult to use. It is not
- * a simple spin lock - one must consider sock_owned_by_user() and arrange
- * to use sk_add_backlog() stuff. But what really makes it infeasible is the
- * locking hierarchy violation. E.g., inet_csk_listen_stop() may try to
- * acquire a child's lock while holding listener's socket lock.
- *
- * This function also sets "treq->tfo_listener" to false.
- * treq->tfo_listener is used by the listener so it is protected by the
- * fastopenq->lock in this function.
- */
-void reqsk_fastopen_remove(struct sock *sk, struct request_sock *req,
-			   bool reset)
-{
-	struct sock *lsk = req->rsk_listener;
-	struct fastopen_queue *fastopenq;
-
-	fastopenq = &inet_csk(lsk)->icsk_accept_queue.fastopenq;
-
-	RCU_INIT_POINTER(tcp_sk(sk)->fastopen_rsk, NULL);
-	spin_lock_bh(&fastopenq->lock);
-	fastopenq->qlen--;
-	tcp_rsk(req)->tfo_listener = false;
-	if (req->sk)	/* the child socket hasn't been accepted yet */
-		goto out;
-
-	if (!reset || lsk->sk_state != TCP_LISTEN) {
-		/* If the listener has been closed don't bother with the
-		 * special RST handling below.
-		 */
-		spin_unlock_bh(&fastopenq->lock);
-		reqsk_put(req);
-		return;
-	}
-	/* Wait for 60secs before removing a req that has triggered RST.
-	 * This is a simple defense against TFO spoofing attack - by
-	 * counting the req against fastopen.max_qlen, and disabling
-	 * TFO when the qlen exceeds max_qlen.
-	 *
-	 * For more details see CoNext'11 "TCP Fast Open" paper.
-	 */
-	req->rsk_timer.expires = jiffies + 60*HZ;
-	if (fastopenq->rskq_rst_head == NULL)
-		fastopenq->rskq_rst_head = req;
-	else
-		fastopenq->rskq_rst_tail->dl_next = req;
-
-	req->dl_next = NULL;
-	fastopenq->rskq_rst_tail = req;
-	fastopenq->qlen++;
-out:
-	spin_unlock_bh(&fastopenq->lock);
-}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/secure_seq.c linux-master/net/core/secure_seq.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/secure_seq.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/core/secure_seq.c	2025-10-20 00:41:14.000000000 -0300
@@ -64,7 +64,7 @@
 		.daddr = *(struct in6_addr *)daddr,
 	};
 
-	if (READ_ONCE(net->ipv4.sysctl_tcp_timestamps) != 1)
+	if (CONFIG_SYSCTL_TCP_TIMESTAMPS != 1)
 		return 0;
 
 	ts_secret_init();
@@ -120,7 +120,7 @@
 #ifdef CONFIG_INET
 u32 secure_tcp_ts_off(const struct net *net, __be32 saddr, __be32 daddr)
 {
-	if (READ_ONCE(net->ipv4.sysctl_tcp_timestamps) != 1)
+	if (CONFIG_SYSCTL_TCP_TIMESTAMPS != 1)
 		return 0;
 
 	ts_secret_init();
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/skbuff.c linux-master/net/core/skbuff.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/skbuff.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/core/skbuff.c	2025-10-20 00:41:14.000000000 -0300
@@ -76,7 +76,6 @@
 #include <net/ip6_checksum.h>
 #include <net/xfrm.h>
 #include <net/mpls.h>
-#include <net/mptcp.h>
 #include <net/mctp.h>
 #include <net/page_pool/helpers.h>
 #include <net/psp/types.h>
@@ -5057,9 +5056,6 @@
 #if IS_ENABLED(CONFIG_NET_TC_SKB_EXT)
 	[TC_SKB_EXT] = SKB_EXT_CHUNKSIZEOF(struct tc_skb_ext),
 #endif
-#if IS_ENABLED(CONFIG_MPTCP)
-	[SKB_EXT_MPTCP] = SKB_EXT_CHUNKSIZEOF(struct mptcp_ext),
-#endif
 #if IS_ENABLED(CONFIG_MCTP_FLOWS)
 	[SKB_EXT_MCTP] = SKB_EXT_CHUNKSIZEOF(struct mctp_flow),
 #endif
@@ -6195,6 +6191,7 @@
 }
 EXPORT_SYMBOL_GPL(skb_scrub_packet);
 
+#ifdef CONFIG_VLAN_CORE
 static struct sk_buff *skb_reorder_vlan_header(struct sk_buff *skb)
 {
 	int mac_len, meta_len;
@@ -6261,6 +6258,7 @@
 	return NULL;
 }
 EXPORT_SYMBOL(skb_vlan_untag);
+#endif
 
 int skb_ensure_writable(struct sk_buff *skb, unsigned int write_len)
 {
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/sock.c linux-master/net/core/sock.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/sock.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/core/sock.c	2025-10-20 00:41:14.000000000 -0300
@@ -1389,10 +1389,6 @@
 		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
 		break;
 
-	case SO_NO_CHECK:
-		sk->sk_no_check_tx = valbool;
-		break;
-
 	case SO_LINGER:
 		if (optlen < sizeof(ling)) {
 			ret = -EINVAL;	/* 1003.1g */
@@ -1798,10 +1794,6 @@
 		v.val = sock_flag(sk, SOCK_URGINLINE);
 		break;
 
-	case SO_NO_CHECK:
-		v.val = sk->sk_no_check_tx;
-		break;
-
 	case SO_PRIORITY:
 		v.val = READ_ONCE(sk->sk_priority);
 		break;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/sock_reuseport.c linux-master/net/core/sock_reuseport.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/core/sock_reuseport.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/core/sock_reuseport.c	2025-10-20 00:41:14.000000000 -0300
@@ -472,7 +472,7 @@
 		prog = rcu_dereference_protected(reuse->prog,
 						 lockdep_is_held(&reuseport_lock));
 
-		if (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_migrate_req) ||
+		if (CONFIG_SYSCTL_TCP_MIGRATE_REQ ||
 		    (prog && prog->expected_attach_type == BPF_SK_REUSEPORT_SELECT_OR_MIGRATE)) {
 			/* Migration capable, move sk from the listening section
 			 * to the closed section.
@@ -644,7 +644,7 @@
 	hash = migrating_sk->sk_hash;
 	prog = rcu_dereference(reuse->prog);
 	if (!prog || prog->expected_attach_type != BPF_SK_REUSEPORT_SELECT_OR_MIGRATE) {
-		if (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_migrate_req))
+		if (CONFIG_SYSCTL_TCP_MIGRATE_REQ)
 			goto select_by_hash;
 		goto failure;
 	}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/af_inet.c linux-master/net/ipv4/af_inet.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/af_inet.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/af_inet.c	2025-10-20 00:41:14.000000000 -0300
@@ -104,7 +104,6 @@
 #include <net/tcp.h>
 #include <net/psp.h>
 #include <net/udp.h>
-#include <net/udplite.h>
 #include <net/ping.h>
 #include <linux/skbuff.h>
 #include <net/sock.h>
@@ -193,7 +192,7 @@
 int __inet_listen_sk(struct sock *sk, int backlog)
 {
 	unsigned char old_state = sk->sk_state;
-	int err, tcp_fastopen;
+	int err;
 
 	if (!((1 << old_state) & (TCPF_CLOSE | TCPF_LISTEN)))
 		return -EINVAL;
@@ -203,19 +202,6 @@
 	 * we can only allow the backlog to be adjusted.
 	 */
 	if (old_state != TCP_LISTEN) {
-		/* Enable TFO w/o requiring TCP_FASTOPEN socket option.
-		 * Note that only TCP sockets (SOCK_STREAM) will reach here.
-		 * Also fastopen backlog may already been set via the option
-		 * because the socket was in TCP_LISTEN state previously but
-		 * was shutdown() rather than close().
-		 */
-		tcp_fastopen = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_fastopen);
-		if ((tcp_fastopen & TFO_SERVER_WO_SOCKOPT1) &&
-		    (tcp_fastopen & TFO_SERVER_ENABLE) &&
-		    !inet_csk(sk)->icsk_accept_queue.fastopenq.max_qlen) {
-			fastopen_queue_tune(sk, backlog);
-			tcp_fastopen_init_key_once(sock_net(sk));
-		}
 
 		err = inet_csk_listen_start(sk);
 		if (err)
@@ -697,8 +683,8 @@
 
 	if ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
 		int writebias = (sk->sk_protocol == IPPROTO_TCP) &&
-				tcp_sk(sk)->fastopen_req &&
-				tcp_sk(sk)->fastopen_req->data ? 1 : 0;
+				0 &&
+				0 ? 1 : 0;
 		int dis = sk->sk_disconnects;
 
 		/* Error code is set above */
@@ -1725,9 +1711,6 @@
 	net->mib.udp_statistics = alloc_percpu(struct udp_mib);
 	if (!net->mib.udp_statistics)
 		goto err_udp_mib;
-	net->mib.udplite_statistics = alloc_percpu(struct udp_mib);
-	if (!net->mib.udplite_statistics)
-		goto err_udplite_mib;
 	net->mib.icmp_statistics = alloc_percpu(struct icmp_mib);
 	if (!net->mib.icmp_statistics)
 		goto err_icmp_mib;
@@ -1742,8 +1725,6 @@
 err_icmpmsg_mib:
 	free_percpu(net->mib.icmp_statistics);
 err_icmp_mib:
-	free_percpu(net->mib.udplite_statistics);
-err_udplite_mib:
 	free_percpu(net->mib.udp_statistics);
 err_udp_mib:
 	free_percpu(net->mib.net_statistics);
@@ -1759,15 +1740,10 @@
 {
 	kfree(net->mib.icmpmsg_statistics);
 	free_percpu(net->mib.icmp_statistics);
-	free_percpu(net->mib.udplite_statistics);
 	free_percpu(net->mib.udp_statistics);
 	free_percpu(net->mib.net_statistics);
 	free_percpu(net->mib.ip_statistics);
 	free_percpu(net->mib.tcp_statistics);
-#ifdef CONFIG_MPTCP
-	/* allocated on demand, see mptcp_init_sock() */
-	free_percpu(net->mib.mptcp_statistics);
-#endif
 }
 
 static __net_initdata struct pernet_operations ipv4_mib_ops = {
@@ -1782,10 +1758,6 @@
 
 static __net_init int inet_init_net(struct net *net)
 {
-	/*
-	 * Set defaults for local port range
-	 */
-	net->ipv4.ip_local_ports.range = 60999u << 16 | 32768u;
 
 	seqlock_init(&net->ipv4.ping_group_range.lock);
 	/*
@@ -1798,16 +1770,12 @@
 	/* Default values for sysctl-controlled parameters.
 	 * We set them here, in case sysctl is not compiled.
 	 */
-	net->ipv4.sysctl_ip_default_ttl = IPDEFTTL;
 	net->ipv4.sysctl_ip_fwd_update_priority = 1;
 	net->ipv4.sysctl_ip_dynaddr = 0;
 	net->ipv4.sysctl_ip_early_demux = 1;
 	net->ipv4.sysctl_udp_early_demux = 1;
 	net->ipv4.sysctl_tcp_early_demux = 1;
 	net->ipv4.sysctl_nexthop_compat_mode = 1;
-#ifdef CONFIG_SYSCTL
-	net->ipv4.sysctl_ip_prot_sock = PROT_SOCK;
-#endif
 
 	/* Some igmp sysctl, whose values are always used */
 	net->ipv4.sysctl_igmp_max_memberships = 20;
@@ -1975,8 +1943,6 @@
 	/* Setup UDP memory threshold */
 	udp_init();
 
-	/* Add UDP-Lite (RFC 3828) */
-	udplite4_register();
 
 	raw_init();
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/fou_core.c linux-master/net/ipv4/fou_core.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/fou_core.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/fou_core.c	2025-10-20 00:41:14.000000000 -0300
@@ -1147,8 +1147,7 @@
 	 * recursion. Besides, this kind of encapsulation can't even be
 	 * configured currently. Discard this.
 	 */
-	if (guehdr->proto_ctype == IPPROTO_UDP ||
-	    guehdr->proto_ctype == IPPROTO_UDPLITE)
+	if (guehdr->proto_ctype == IPPROTO_UDP)
 		return -EOPNOTSUPP;
 
 	skb_set_transport_header(skb, -(int)sizeof(struct icmphdr));
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/icmp.c linux-master/net/ipv4/icmp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/icmp.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/icmp.c	2025-10-20 00:41:14.000000000 -0300
@@ -1023,7 +1023,7 @@
 
 	net = skb_dst_dev_net_rcu(skb);
 	/* should there be an ICMP stat for ignored echos? */
-	if (READ_ONCE(net->ipv4.sysctl_icmp_echo_ignore_all))
+	if (CONFIG_SYSCTL_ICMP_ECHO_IGNORE_ALL)
 		return SKB_NOT_DROPPED_YET;
 
 	icmp_param.data.icmph	   = *icmp_hdr(skb);
@@ -1060,7 +1060,7 @@
 	u16 ident_len;
 	u8 status;
 
-	if (!READ_ONCE(net->ipv4.sysctl_icmp_echo_enable_probe))
+	if (!CONFIG_SYSCTL_ICMP_ECHO_ENABLE_PROBE)
 		return false;
 
 	/* We currently only support probing interfaces on the proxy node
@@ -1270,7 +1270,7 @@
 		 */
 		if ((icmph->type == ICMP_ECHO ||
 		     icmph->type == ICMP_TIMESTAMP) &&
-		    READ_ONCE(net->ipv4.sysctl_icmp_echo_ignore_broadcasts)) {
+		    CONFIG_SYSCTL_ICMP_ECHO_IGNORE_BROADCASTS) {
 			reason = SKB_DROP_REASON_INVALID_PROTO;
 			goto error;
 		}
@@ -1479,10 +1479,6 @@
 
 static int __net_init icmp_sk_init(struct net *net)
 {
-	/* Control parameters for ECHO replies. */
-	net->ipv4.sysctl_icmp_echo_ignore_all = 0;
-	net->ipv4.sysctl_icmp_echo_enable_probe = 0;
-	net->ipv4.sysctl_icmp_echo_ignore_broadcasts = 1;
 
 	/* Control parameter - ignore bogus broadcast responses? */
 	net->ipv4.sysctl_icmp_ignore_bogus_error_responses = 1;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/inet_connection_sock.c linux-master/net/ipv4/inet_connection_sock.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/inet_connection_sock.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/inet_connection_sock.c	2025-10-20 00:41:14.000000000 -0300
@@ -129,27 +129,9 @@
  */
 bool inet_sk_get_local_port_range(const struct sock *sk, int *low, int *high)
 {
-	int lo, hi, sk_lo, sk_hi;
-	bool local_range = false;
-	u32 sk_range;
-
-	inet_get_local_port_range(sock_net(sk), &lo, &hi);
-
-	sk_range = READ_ONCE(inet_sk(sk)->local_port_range);
-	if (unlikely(sk_range)) {
-		sk_lo = sk_range & 0xffff;
-		sk_hi = sk_range >> 16;
-
-		if (lo <= sk_lo && sk_lo <= hi)
-			lo = sk_lo;
-		if (lo <= sk_hi && sk_hi <= hi)
-			hi = sk_hi;
-		local_range = true;
-	}
-
-	*low = lo;
-	*high = hi;
-	return local_range;
+	*low  = CONFIG_SYSCTL_IP_LOCAL_PORTS_MIN;
+	*high = CONFIG_SYSCTL_IP_LOCAL_PORTS_MAX;
+	return false;
 }
 EXPORT_SYMBOL(inet_sk_get_local_port_range);
 
@@ -694,22 +676,6 @@
 	arg->is_empty = reqsk_queue_empty(queue);
 	newsk = req->sk;
 
-	if (sk->sk_protocol == IPPROTO_TCP &&
-	    tcp_rsk(req)->tfo_listener) {
-		spin_lock_bh(&queue->fastopenq.lock);
-		if (tcp_rsk(req)->tfo_listener) {
-			/* We are still waiting for the final ACK from 3WHS
-			 * so can't free req now. Instead, we set req->sk to
-			 * NULL to signify that the child socket is taken
-			 * so reqsk_fastopen_remove() will free the req
-			 * when 3WHS finishes (or is aborted).
-			 */
-			req->sk = NULL;
-			req = NULL;
-		}
-		spin_unlock_bh(&queue->fastopenq.lock);
-	}
-
 	release_sock(sk);
 
 	if (mem_cgroup_sockets_enabled) {
@@ -978,12 +944,6 @@
 
 	nreq->rsk_listener = sk;
 
-	/* We need not acquire fastopenq->lock
-	 * because the child socket is locked in inet_csk_listen_stop().
-	 */
-	if (sk->sk_protocol == IPPROTO_TCP && tcp_rsk(nreq)->tfo_listener)
-		rcu_assign_pointer(tcp_sk(nreq->sk)->fastopen_rsk, nreq);
-
 	return nreq;
 }
 
@@ -1091,7 +1051,7 @@
 	icsk = inet_csk(sk_listener);
 	net = sock_net(sk_listener);
 	max_syn_ack_retries = READ_ONCE(icsk->icsk_syn_retries) ? :
-		READ_ONCE(net->ipv4.sysctl_tcp_synack_retries);
+		CONFIG_SYSCTL_TCP_SYNACK_RETRIES;
 	/* Normally all the openreqs are young and become mature
 	 * (i.e. converted to established socket) for first timeout.
 	 * If synack was not acknowledged for 1 second, it means
@@ -1382,18 +1342,6 @@
 
 	tcp_orphan_count_inc();
 
-	if (sk->sk_protocol == IPPROTO_TCP && tcp_rsk(req)->tfo_listener) {
-		BUG_ON(rcu_access_pointer(tcp_sk(child)->fastopen_rsk) != req);
-		BUG_ON(sk != req->rsk_listener);
-
-		/* Paranoid, to prevent race condition if
-		 * an inbound pkt destined for child is
-		 * blocked by sock lock in tcp_v4_rcv().
-		 * Also to satisfy an assertion in
-		 * tcp_v4_destroy_sock().
-		 */
-		RCU_INIT_POINTER(tcp_sk(child)->fastopen_rsk, NULL);
-	}
 	inet_csk_destroy_sock(child);
 }
 
@@ -1475,7 +1423,7 @@
 {
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct request_sock_queue *queue = &icsk->icsk_accept_queue;
-	struct request_sock *next, *req;
+	struct request_sock *req;
 
 	/* Following specs, it would be better either to send FIN
 	 * (and enter FIN-WAIT-1, it is normal close)
@@ -1527,18 +1475,6 @@
 
 		cond_resched();
 	}
-	if (queue->fastopenq.rskq_rst_head) {
-		/* Free all the reqs queued in rskq_rst_head. */
-		spin_lock_bh(&queue->fastopenq.lock);
-		req = queue->fastopenq.rskq_rst_head;
-		queue->fastopenq.rskq_rst_head = NULL;
-		spin_unlock_bh(&queue->fastopenq.lock);
-		while (req != NULL) {
-			next = req->dl_next;
-			reqsk_put(req);
-			req = next;
-		}
-	}
 	WARN_ON_ONCE(sk->sk_ack_backlog);
 }
 EXPORT_SYMBOL_GPL(inet_csk_listen_stop);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/ip_sockglue.c linux-master/net/ipv4/ip_sockglue.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/ip_sockglue.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/ip_sockglue.c	2025-10-20 00:41:14.000000000 -0300
@@ -923,7 +923,6 @@
 	case IP_CHECKSUM:
 	case IP_RECVFRAGSIZE:
 	case IP_RECVERR_RFC4884:
-	case IP_LOCAL_PORT_RANGE:
 		if (optlen >= sizeof(int)) {
 			if (copy_from_sockptr(&val, optval, sizeof(val)))
 				return -EFAULT;
@@ -1057,19 +1056,6 @@
 	case IP_TOS:	/* This sets both TOS and Precedence */
 		ip_sock_set_tos(sk, val);
 		return 0;
-	case IP_LOCAL_PORT_RANGE:
-	{
-		u16 lo = val;
-		u16 hi = val >> 16;
-
-		if (optlen != sizeof(u32))
-			return -EINVAL;
-		if (lo != 0 && hi != 0 && lo > hi)
-			return -EINVAL;
-
-		WRITE_ONCE(inet->local_port_range, val);
-		return 0;
-	}
 	}
 
 	err = 0;
@@ -1585,7 +1571,7 @@
 	case IP_TTL:
 		val = READ_ONCE(inet->uc_ttl);
 		if (val < 0)
-			val = READ_ONCE(sock_net(sk)->ipv4.sysctl_ip_default_ttl);
+			val = CONFIG_SYSCTL_IP_DEFAULT_TTL;
 		goto copyval;
 	case IP_MINTTL:
 		val = READ_ONCE(inet->min_ttl);
@@ -1693,9 +1679,6 @@
 			return -EFAULT;
 		return 0;
 	}
-	case IP_LOCAL_PORT_RANGE:
-		val = READ_ONCE(inet->local_port_range);
-		goto copyval;
 	}
 
 	if (needs_rtnl)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/Makefile linux-master/net/ipv4/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -8,9 +8,9 @@
 	     ip_output.o ip_sockglue.o inet_hashtables.o \
 	     inet_timewait_sock.o inet_connection_sock.o \
 	     tcp.o tcp_input.o tcp_output.o tcp_timer.o tcp_ipv4.o \
-	     tcp_minisocks.o tcp_cong.o tcp_metrics.o tcp_fastopen.o \
+	     tcp_minisocks.o tcp_cong.o tcp_metrics.o \
 	     tcp_rate.o tcp_recovery.o tcp_ulp.o \
-	     tcp_offload.o tcp_plb.o datagram.o raw.o udp.o udplite.o \
+	     tcp_offload.o tcp_plb.o datagram.o raw.o udp.o \
 	     udp_offload.o arp.o icmp.o devinet.o af_inet.o igmp.o \
 	     fib_frontend.o fib_semantics.o fib_trie.o fib_notifier.o \
 	     inet_fragment.o ping.o ip_tunnel_core.o gre_offload.o \
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/netfilter/nf_reject_ipv4.c linux-master/net/ipv4/netfilter/nf_reject_ipv4.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/netfilter/nf_reject_ipv4.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/netfilter/nf_reject_ipv4.c	2025-10-20 00:41:14.000000000 -0300
@@ -71,7 +71,7 @@
 
 	skb_reserve(nskb, LL_MAX_HEADER);
 	niph = nf_reject_iphdr_put(nskb, oldskb, IPPROTO_TCP,
-				   READ_ONCE(net->ipv4.sysctl_ip_default_ttl));
+				   CONFIG_SYSCTL_IP_DEFAULT_TTL);
 	nf_reject_ip_tcphdr_put(nskb, oldskb, oth);
 	niph->tot_len = htons(nskb->len);
 	ip_send_check(niph);
@@ -151,7 +151,7 @@
 
 	skb_reserve(nskb, LL_MAX_HEADER);
 	niph = nf_reject_iphdr_put(nskb, oldskb, IPPROTO_ICMP,
-				   READ_ONCE(net->ipv4.sysctl_ip_default_ttl));
+				   CONFIG_SYSCTL_IP_DEFAULT_TTL);
 
 	skb_reset_transport_header(nskb);
 	icmph = skb_put_zero(nskb, sizeof(struct icmphdr));
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/proc.c linux-master/net/ipv4/proc.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/proc.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/proc.c	2025-10-20 00:41:14.000000000 -0300
@@ -32,10 +32,8 @@
 #include <net/icmp.h>
 #include <net/protocol.h>
 #include <net/tcp.h>
-#include <net/mptcp.h>
 #include <net/proto_memory.h>
 #include <net/udp.h>
-#include <net/udplite.h>
 #include <linux/bottom_half.h>
 #include <linux/inetdevice.h>
 #include <linux/proc_fs.h>
@@ -65,8 +63,6 @@
 	seq_printf(seq, "UDP: inuse %d mem %ld\n",
 		   sock_prot_inuse_get(net, &udp_prot),
 		   proto_memory_allocated(&udp_prot));
-	seq_printf(seq, "UDPLITE: inuse %d\n",
-		   sock_prot_inuse_get(net, &udplite_prot));
 	seq_printf(seq, "RAW: inuse %d\n",
 		   sock_prot_inuse_get(net, &raw_prot));
 	seq_printf(seq,  "FRAG: inuse %u memory %lu\n",
@@ -257,13 +253,6 @@
 	SNMP_MIB_ITEM("TCPOFOMerge", LINUX_MIB_TCPOFOMERGE),
 	SNMP_MIB_ITEM("TCPChallengeACK", LINUX_MIB_TCPCHALLENGEACK),
 	SNMP_MIB_ITEM("TCPSYNChallenge", LINUX_MIB_TCPSYNCHALLENGE),
-	SNMP_MIB_ITEM("TCPFastOpenActive", LINUX_MIB_TCPFASTOPENACTIVE),
-	SNMP_MIB_ITEM("TCPFastOpenActiveFail", LINUX_MIB_TCPFASTOPENACTIVEFAIL),
-	SNMP_MIB_ITEM("TCPFastOpenPassive", LINUX_MIB_TCPFASTOPENPASSIVE),
-	SNMP_MIB_ITEM("TCPFastOpenPassiveFail", LINUX_MIB_TCPFASTOPENPASSIVEFAIL),
-	SNMP_MIB_ITEM("TCPFastOpenListenOverflow", LINUX_MIB_TCPFASTOPENLISTENOVERFLOW),
-	SNMP_MIB_ITEM("TCPFastOpenCookieReqd", LINUX_MIB_TCPFASTOPENCOOKIEREQD),
-	SNMP_MIB_ITEM("TCPFastOpenBlackhole", LINUX_MIB_TCPFASTOPENBLACKHOLE),
 	SNMP_MIB_ITEM("TCPSpuriousRtxHostQueues", LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES),
 	SNMP_MIB_ITEM("BusyPollRxPackets", LINUX_MIB_BUSYPOLLRXPACKETS),
 	SNMP_MIB_ITEM("TCPAutoCorking", LINUX_MIB_TCPAUTOCORKING),
@@ -292,7 +281,6 @@
 	SNMP_MIB_ITEM("TCPZeroWindowDrop", LINUX_MIB_TCPZEROWINDOWDROP),
 	SNMP_MIB_ITEM("TCPRcvQDrop", LINUX_MIB_TCPRCVQDROP),
 	SNMP_MIB_ITEM("TCPWqueueTooBig", LINUX_MIB_TCPWQUEUETOOBIG),
-	SNMP_MIB_ITEM("TCPFastOpenPassiveAltKey", LINUX_MIB_TCPFASTOPENPASSIVEALTKEY),
 	SNMP_MIB_ITEM("TcpTimeoutRehash", LINUX_MIB_TCPTIMEOUTREHASH),
 	SNMP_MIB_ITEM("TcpDuplicateDataRehash", LINUX_MIB_TCPDUPLICATEDATAREHASH),
 	SNMP_MIB_ITEM("TCPDSACKRecvSegs", LINUX_MIB_TCPDSACKRECVSEGS),
@@ -397,7 +385,7 @@
 
 	seq_printf(seq, "\nIp: %d %d",
 		   IPV4_DEVCONF_ALL_RO(net, FORWARDING) ? 1 : 2,
-		   READ_ONCE(net->ipv4.sysctl_ip_default_ttl));
+		   CONFIG_SYSCTL_IP_DEFAULT_TTL);
 
 	BUILD_BUG_ON(offsetof(struct ipstats_mib, mibs) != 0);
 	snmp_get_cpu_field64_batch_cnt(buff64, snmp4_ipstats_list, cnt,
@@ -449,17 +437,6 @@
 
 	memset(buff, 0, udp_cnt * sizeof(unsigned long));
 
-	/* the UDP and UDP-Lite MIBs are the same */
-	seq_puts(seq, "\nUdpLite:");
-	snmp_get_cpu_field_batch_cnt(buff, snmp4_udp_list,
-				     udp_cnt,
-				     net->mib.udplite_statistics);
-	for (i = 0; i < udp_cnt; i++)
-		seq_printf(seq, " %s", snmp4_udp_list[i].name);
-	seq_puts(seq, "\nUdpLite:");
-	for (i = 0; i < udp_cnt; i++)
-		seq_printf(seq, " %lu", buff[i]);
-
 	seq_putc(seq, '\n');
 	return 0;
 }
@@ -528,7 +505,6 @@
 	}
 	kfree(buff);
 	seq_putc(seq, '\n');
-	mptcp_seq_show(seq);
 	return 0;
 }
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/syncookies.c linux-master/net/ipv4/syncookies.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/syncookies.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/syncookies.c	2025-10-20 00:41:14.000000000 -0300
@@ -244,7 +244,7 @@
 		return true;
 	}
 
-	if (!READ_ONCE(net->ipv4.sysctl_tcp_timestamps))
+	if (!CONFIG_SYSCTL_TCP_TIMESTAMPS)
 		return false;
 
 	tcp_opt->sack_ok = (options & TS_OPT_SACK) ? TCP_SACK_SEEN : 0;
@@ -281,18 +281,12 @@
 
 	treq->snt_synack = 0;
 	treq->snt_tsval_first = 0;
-	treq->tfo_listener = false;
 	treq->txhash = net_tx_rndhash();
 	treq->rcv_isn = ntohl(th->seq) - 1;
 	treq->snt_isn = ntohl(th->ack_seq) - 1;
 	treq->syn_tos = TCP_SKB_CB(skb)->ip_dsfield;
 	treq->req_usec_ts = false;
 
-#if IS_ENABLED(CONFIG_MPTCP)
-	treq->is_mptcp = sk_is_mptcp(sk);
-	if (treq->is_mptcp)
-		return mptcp_subflow_init_cookie_req(req, sk, skb);
-#endif
 
 	return 0;
 }
@@ -324,9 +318,6 @@
 	struct tcp_request_sock *treq;
 	struct request_sock *req;
 
-	if (sk_is_mptcp(sk))
-		req = mptcp_subflow_reqsk_alloc(ops, sk, false);
-	else
 		req = inet_reqsk_alloc(ops, sk, false);
 
 	if (!req)
@@ -375,7 +366,7 @@
 
 	/* check for timestamp cookie support */
 	memset(&tcp_opt, 0, sizeof(tcp_opt));
-	tcp_parse_options(net, skb, &tcp_opt, 0, NULL);
+	tcp_parse_options(net, skb, &tcp_opt, 0);
 
 	if (tcp_opt.saw_tstamp && tcp_opt.rcv_tsecr) {
 		tsoff = secure_tcp_ts_off(net,
@@ -413,7 +404,7 @@
 	int full_space;
 	SKB_DR(reason);
 
-	if (!READ_ONCE(net->ipv4.sysctl_tcp_syncookies) ||
+	if (!CONFIG_SYSCTL_TCP_SYNCOOKIES ||
 	    !th->ack || th->rst)
 		goto out;
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/sysctl_net_ipv4.c linux-master/net/ipv4/sysctl_net_ipv4.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/sysctl_net_ipv4.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/sysctl_net_ipv4.c	2025-10-20 00:41:14.000000000 -0300
@@ -20,22 +20,10 @@
 #include <net/protocol.h>
 #include <net/netevent.h>
 
-static int tcp_retr1_max = 255;
-static int ip_local_port_range_min[] = { 1, 1 };
-static int ip_local_port_range_max[] = { 65535, 65535 };
-static int tcp_adv_win_scale_min = -31;
-static int tcp_adv_win_scale_max = 31;
 static int tcp_app_win_max = 31;
 static int tcp_min_snd_mss_min = TCP_MIN_SND_MSS;
 static int tcp_min_snd_mss_max = 65535;
 static int tcp_rto_max_max = TCP_RTO_MAX_SEC * MSEC_PER_SEC;
-static int ip_privileged_port_min;
-static int ip_privileged_port_max = 65535;
-static int ip_ttl_min = 1;
-static int ip_ttl_max = 255;
-static int tcp_syn_retries_min = 1;
-static int tcp_syn_retries_max = MAX_TCP_SYNCNT;
-static int tcp_syn_linear_timeouts_max = MAX_TCP_SYNCNT;
 static unsigned long ip_ping_group_range_min[] = { 0, 0 };
 static unsigned long ip_ping_group_range_max[] = { GID_T_MAX, GID_T_MAX };
 static u32 u32_max_div_HZ = UINT_MAX / HZ;
@@ -52,86 +40,6 @@
 /* obsolete */
 static int sysctl_tcp_low_latency __read_mostly;
 
-/* Update system visible IP port range */
-static void set_local_port_range(struct net *net, unsigned int low, unsigned int high)
-{
-	bool same_parity = !((low ^ high) & 1);
-
-	if (same_parity && !net->ipv4.ip_local_ports.warned) {
-		net->ipv4.ip_local_ports.warned = true;
-		pr_err_ratelimited("ip_local_port_range: prefer different parity for start/end values.\n");
-	}
-	WRITE_ONCE(net->ipv4.ip_local_ports.range, high << 16 | low);
-}
-
-/* Validate changes from /proc interface. */
-static int ipv4_local_port_range(const struct ctl_table *table, int write,
-				 void *buffer, size_t *lenp, loff_t *ppos)
-{
-	struct net *net = table->data;
-	int ret;
-	int range[2];
-	struct ctl_table tmp = {
-		.data = &range,
-		.maxlen = sizeof(range),
-		.mode = table->mode,
-		.extra1 = &ip_local_port_range_min,
-		.extra2 = &ip_local_port_range_max,
-	};
-
-	inet_get_local_port_range(net, &range[0], &range[1]);
-
-	ret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
-
-	if (write && ret == 0) {
-		/* Ensure that the upper limit is not smaller than the lower,
-		 * and that the lower does not encroach upon the privileged
-		 * port limit.
-		 */
-		if ((range[1] < range[0]) ||
-		    (range[0] < READ_ONCE(net->ipv4.sysctl_ip_prot_sock)))
-			ret = -EINVAL;
-		else
-			set_local_port_range(net, range[0], range[1]);
-	}
-
-	return ret;
-}
-
-/* Validate changes from /proc interface. */
-static int ipv4_privileged_ports(const struct ctl_table *table, int write,
-				void *buffer, size_t *lenp, loff_t *ppos)
-{
-	struct net *net = container_of(table->data, struct net,
-	    ipv4.sysctl_ip_prot_sock);
-	int ret;
-	int pports;
-	int range[2];
-	struct ctl_table tmp = {
-		.data = &pports,
-		.maxlen = sizeof(pports),
-		.mode = table->mode,
-		.extra1 = &ip_privileged_port_min,
-		.extra2 = &ip_privileged_port_max,
-	};
-
-	pports = READ_ONCE(net->ipv4.sysctl_ip_prot_sock);
-
-	ret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
-
-	if (write && ret == 0) {
-		inet_get_local_port_range(net, &range[0], &range[1]);
-		/* Ensure that the local port range doesn't overlap with the
-		 * privileged port range.
-		 */
-		if (range[0] < pports)
-			ret = -EINVAL;
-		else
-			WRITE_ONCE(net->ipv4.sysctl_ip_prot_sock, pports);
-	}
-
-	return ret;
-}
 
 static void inet_get_ping_group_range_table(const struct ctl_table *table,
 					    kgid_t *low, kgid_t *high)
@@ -268,110 +176,6 @@
 	return ret;
 }
 
-static int sscanf_key(char *buf, __le32 *key)
-{
-	u32 user_key[4];
-	int i, ret = 0;
-
-	if (sscanf(buf, "%x-%x-%x-%x", user_key, user_key + 1,
-		   user_key + 2, user_key + 3) != 4) {
-		ret = -EINVAL;
-	} else {
-		for (i = 0; i < ARRAY_SIZE(user_key); i++)
-			key[i] = cpu_to_le32(user_key[i]);
-	}
-	pr_debug("proc TFO key set 0x%x-%x-%x-%x <- 0x%s: %u\n",
-		 user_key[0], user_key[1], user_key[2], user_key[3], buf, ret);
-
-	return ret;
-}
-
-static int proc_tcp_fastopen_key(const struct ctl_table *table, int write,
-				 void *buffer, size_t *lenp, loff_t *ppos)
-{
-	struct net *net = container_of(table->data, struct net,
-	    ipv4.sysctl_tcp_fastopen);
-	/* maxlen to print the list of keys in hex (*2), with dashes
-	 * separating doublewords and a comma in between keys.
-	 */
-	struct ctl_table tbl = { .maxlen = ((TCP_FASTOPEN_KEY_LENGTH *
-					    2 * TCP_FASTOPEN_KEY_MAX) +
-					    (TCP_FASTOPEN_KEY_MAX * 5)) };
-	u32 user_key[TCP_FASTOPEN_KEY_BUF_LENGTH / sizeof(u32)];
-	__le32 key[TCP_FASTOPEN_KEY_BUF_LENGTH / sizeof(__le32)];
-	char *backup_data;
-	int ret, i = 0, off = 0, n_keys;
-
-	tbl.data = kmalloc(tbl.maxlen, GFP_KERNEL);
-	if (!tbl.data)
-		return -ENOMEM;
-
-	n_keys = tcp_fastopen_get_cipher(net, NULL, (u64 *)key);
-	if (!n_keys) {
-		memset(&key[0], 0, TCP_FASTOPEN_KEY_LENGTH);
-		n_keys = 1;
-	}
-
-	for (i = 0; i < n_keys * 4; i++)
-		user_key[i] = le32_to_cpu(key[i]);
-
-	for (i = 0; i < n_keys; i++) {
-		off += snprintf(tbl.data + off, tbl.maxlen - off,
-				"%08x-%08x-%08x-%08x",
-				user_key[i * 4],
-				user_key[i * 4 + 1],
-				user_key[i * 4 + 2],
-				user_key[i * 4 + 3]);
-
-		if (WARN_ON_ONCE(off >= tbl.maxlen - 1))
-			break;
-
-		if (i + 1 < n_keys)
-			off += snprintf(tbl.data + off, tbl.maxlen - off, ",");
-	}
-
-	ret = proc_dostring(&tbl, write, buffer, lenp, ppos);
-
-	if (write && ret == 0) {
-		backup_data = strchr(tbl.data, ',');
-		if (backup_data) {
-			*backup_data = '\0';
-			backup_data++;
-		}
-		if (sscanf_key(tbl.data, key)) {
-			ret = -EINVAL;
-			goto bad_key;
-		}
-		if (backup_data) {
-			if (sscanf_key(backup_data, key + 4)) {
-				ret = -EINVAL;
-				goto bad_key;
-			}
-		}
-		tcp_fastopen_reset_cipher(net, NULL, key,
-					  backup_data ? key + 4 : NULL);
-	}
-
-bad_key:
-	kfree(tbl.data);
-	return ret;
-}
-
-static int proc_tfo_blackhole_detect_timeout(const struct ctl_table *table,
-					     int write, void *buffer,
-					     size_t *lenp, loff_t *ppos)
-{
-	struct net *net = container_of(table->data, struct net,
-	    ipv4.sysctl_tcp_fastopen_blackhole_timeout);
-	int ret;
-
-	ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
-	if (write && ret == 0)
-		atomic_set(&net->ipv4.tfo_active_disable_times, 0);
-
-	return ret;
-}
-
 static int proc_tcp_available_ulp(const struct ctl_table *ctl,
 				  int write, void *buffer, size_t *lenp,
 				  loff_t *ppos)
@@ -413,28 +217,6 @@
 	return proc_dointvec(&tbl, write, buffer, lenp, ppos);
 }
 
-static int proc_udp_hash_entries(const struct ctl_table *table, int write,
-				 void *buffer, size_t *lenp, loff_t *ppos)
-{
-	struct net *net = container_of(table->data, struct net,
-				       ipv4.sysctl_udp_child_hash_entries);
-	int udp_hash_entries;
-	struct ctl_table tbl;
-
-	udp_hash_entries = net->ipv4.udp_table->mask + 1;
-
-	/* A negative number indicates that the child netns
-	 * shares the global udp_table.
-	 */
-	if (!net_eq(net, &init_net) && net->ipv4.udp_table == &udp_table)
-		udp_hash_entries *= -1;
-
-	memset(&tbl, 0, sizeof(tbl));
-	tbl.data = &udp_hash_entries;
-	tbl.maxlen = sizeof(int);
-
-	return proc_dointvec(&tbl, write, buffer, lenp, ppos);
-}
 
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 static int proc_fib_multipath_hash_policy(const struct ctl_table *table, int write,
@@ -630,33 +412,6 @@
 		.proc_handler	= proc_dointvec
 	},
 	{
-		.procname	= "icmp_echo_ignore_all",
-		.data		= &init_net.ipv4.sysctl_icmp_echo_ignore_all,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE
-	},
-	{
-		.procname	= "icmp_echo_enable_probe",
-		.data		= &init_net.ipv4.sysctl_icmp_echo_enable_probe,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE
-	},
-	{
-		.procname	= "icmp_echo_ignore_broadcasts",
-		.data		= &init_net.ipv4.sysctl_icmp_echo_ignore_broadcasts,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE
-	},
-	{
 		.procname	= "icmp_ignore_bogus_error_responses",
 		.data		= &init_net.ipv4.sysctl_icmp_ignore_bogus_error_responses,
 		.maxlen		= sizeof(u8),
@@ -796,29 +551,6 @@
 		.extra2		= SYSCTL_ONE,
 	},
 	{
-		.procname	= "ip_default_ttl",
-		.data		= &init_net.ipv4.sysctl_ip_default_ttl,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra1		= &ip_ttl_min,
-		.extra2		= &ip_ttl_max,
-	},
-	{
-		.procname	= "ip_local_port_range",
-		.maxlen		= 0,
-		.data		= &init_net,
-		.mode		= 0644,
-		.proc_handler	= ipv4_local_port_range,
-	},
-	{
-		.procname	= "ip_local_reserved_ports",
-		.data		= &init_net.ipv4.sysctl_local_reserved_ports,
-		.maxlen		= 65536,
-		.mode		= 0644,
-		.proc_handler	= proc_do_large_bitmap,
-	},
-	{
 		.procname	= "ip_no_pmtu_disc",
 		.data		= &init_net.ipv4.sysctl_ip_no_pmtu_disc,
 		.maxlen		= sizeof(u8),
@@ -915,21 +647,6 @@
 		.extra2		= &tcp_min_snd_mss_max,
 	},
 	{
-		.procname	= "tcp_probe_threshold",
-		.data		= &init_net.ipv4.sysctl_tcp_probe_threshold,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec,
-	},
-	{
-		.procname	= "tcp_probe_interval",
-		.data		= &init_net.ipv4.sysctl_tcp_probe_interval,
-		.maxlen		= sizeof(u32),
-		.mode		= 0644,
-		.proc_handler	= proc_douintvec_minmax,
-		.extra2		= &u32_max_div_HZ,
-	},
-	{
 		.procname	= "igmp_link_local_mcast_reports",
 		.data		= &init_net.ipv4.sysctl_igmp_llm_reports,
 		.maxlen		= sizeof(u8),
@@ -980,97 +697,6 @@
 		.proc_handler   = proc_allowed_congestion_control,
 	},
 	{
-		.procname	= "tcp_keepalive_time",
-		.data		= &init_net.ipv4.sysctl_tcp_keepalive_time,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_jiffies,
-	},
-	{
-		.procname	= "tcp_keepalive_probes",
-		.data		= &init_net.ipv4.sysctl_tcp_keepalive_probes,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
-		.procname	= "tcp_keepalive_intvl",
-		.data		= &init_net.ipv4.sysctl_tcp_keepalive_intvl,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_jiffies,
-	},
-	{
-		.procname	= "tcp_syn_retries",
-		.data		= &init_net.ipv4.sysctl_tcp_syn_retries,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra1		= &tcp_syn_retries_min,
-		.extra2		= &tcp_syn_retries_max
-	},
-	{
-		.procname	= "tcp_synack_retries",
-		.data		= &init_net.ipv4.sysctl_tcp_synack_retries,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-#ifdef CONFIG_SYN_COOKIES
-	{
-		.procname	= "tcp_syncookies",
-		.data		= &init_net.ipv4.sysctl_tcp_syncookies,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-#endif
-	{
-		.procname	= "tcp_migrate_req",
-		.data		= &init_net.ipv4.sysctl_tcp_migrate_req,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE
-	},
-	{
-		.procname	= "tcp_reordering",
-		.data		= &init_net.ipv4.sysctl_tcp_reordering,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec
-	},
-	{
-		.procname	= "tcp_retries1",
-		.data		= &init_net.ipv4.sysctl_tcp_retries1,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra2		= &tcp_retr1_max
-	},
-	{
-		.procname	= "tcp_retries2",
-		.data		= &init_net.ipv4.sysctl_tcp_retries2,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
-		.procname	= "tcp_orphan_retries",
-		.data		= &init_net.ipv4.sysctl_tcp_orphan_retries,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
-		.procname	= "tcp_fin_timeout",
-		.data		= &init_net.ipv4.sysctl_tcp_fin_timeout,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_jiffies,
-	},
-	{
 		.procname	= "tcp_notsent_lowat",
 		.data		= &init_net.ipv4.sysctl_tcp_notsent_lowat,
 		.maxlen		= sizeof(unsigned int),
@@ -1095,40 +721,6 @@
 		.extra1		= SYSCTL_ONE,
 		.extra2		= &tcp_tw_reuse_delay_max,
 	},
-	{
-		.procname	= "tcp_max_syn_backlog",
-		.data		= &init_net.ipv4.sysctl_max_syn_backlog,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec
-	},
-	{
-		.procname	= "tcp_fastopen",
-		.data		= &init_net.ipv4.sysctl_tcp_fastopen,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec,
-	},
-	{
-		.procname	= "tcp_fastopen_key",
-		.mode		= 0600,
-		.data		= &init_net.ipv4.sysctl_tcp_fastopen,
-		/* maxlen to print the list of keys in hex (*2), with dashes
-		 * separating doublewords and a comma in between keys.
-		 */
-		.maxlen		= ((TCP_FASTOPEN_KEY_LENGTH *
-				   2 * TCP_FASTOPEN_KEY_MAX) +
-				   (TCP_FASTOPEN_KEY_MAX * 5)),
-		.proc_handler	= proc_tcp_fastopen_key,
-	},
-	{
-		.procname	= "tcp_fastopen_blackhole_timeout_sec",
-		.data		= &init_net.ipv4.sysctl_tcp_fastopen_blackhole_timeout,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_tfo_blackhole_detect_timeout,
-		.extra1		= SYSCTL_ZERO,
-	},
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 	{
 		.procname	= "fib_multipath_use_neigh",
@@ -1165,13 +757,6 @@
 		.proc_handler	= proc_fib_multipath_hash_seed,
 	},
 #endif
-	{
-		.procname	= "ip_unprivileged_port_start",
-		.maxlen		= sizeof(int),
-		.data		= &init_net.ipv4.sysctl_ip_prot_sock,
-		.mode		= 0644,
-		.proc_handler	= ipv4_privileged_ports,
-	},
 #ifdef CONFIG_NET_L3_MASTER_DEV
 	{
 		.procname	= "udp_l3mdev_accept",
@@ -1198,13 +783,6 @@
 		.proc_handler	= proc_dou8vec_minmax,
 	},
 	{
-		.procname	= "tcp_timestamps",
-		.data		= &init_net.ipv4.sysctl_tcp_timestamps,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
 		.procname	= "tcp_early_retrans",
 		.data		= &init_net.ipv4.sysctl_tcp_early_retrans,
 		.maxlen		= sizeof(u8),
@@ -1235,20 +813,6 @@
 		.proc_handler	= proc_dou8vec_minmax,
 	},
 	{
-		.procname	= "tcp_retrans_collapse",
-		.data		= &init_net.ipv4.sysctl_tcp_retrans_collapse,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
-		.procname	= "tcp_stdurg",
-		.data		= &init_net.ipv4.sysctl_tcp_stdurg,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
 		.procname	= "tcp_rfc1337",
 		.data		= &init_net.ipv4.sysctl_tcp_rfc1337,
 		.maxlen		= sizeof(u8),
@@ -1256,27 +820,6 @@
 		.proc_handler	= proc_dou8vec_minmax,
 	},
 	{
-		.procname	= "tcp_abort_on_overflow",
-		.data		= &init_net.ipv4.sysctl_tcp_abort_on_overflow,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
-		.procname	= "tcp_fack",
-		.data		= &init_net.ipv4.sysctl_tcp_fack,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
-		.procname	= "tcp_max_reordering",
-		.data		= &init_net.ipv4.sysctl_tcp_max_reordering,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec
-	},
-	{
 		.procname	= "tcp_dsack",
 		.data		= &init_net.ipv4.sysctl_tcp_dsack,
 		.maxlen		= sizeof(u8),
@@ -1293,45 +836,6 @@
 		.extra2		= &tcp_app_win_max,
 	},
 	{
-		.procname	= "tcp_adv_win_scale",
-		.data		= &init_net.ipv4.sysctl_tcp_adv_win_scale,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= &tcp_adv_win_scale_min,
-		.extra2		= &tcp_adv_win_scale_max,
-	},
-	{
-		.procname	= "tcp_frto",
-		.data		= &init_net.ipv4.sysctl_tcp_frto,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
-		.procname	= "tcp_no_metrics_save",
-		.data		= &init_net.ipv4.sysctl_tcp_nometrics_save,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
-		.procname	= "tcp_no_ssthresh_metrics_save",
-		.data		= &init_net.ipv4.sysctl_tcp_no_ssthresh_metrics_save,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE,
-	},
-	{
-		.procname	= "tcp_moderate_rcvbuf",
-		.data		= &init_net.ipv4.sysctl_tcp_moderate_rcvbuf,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
 		.procname	= "tcp_tso_win_divisor",
 		.data		= &init_net.ipv4.sysctl_tcp_tso_win_divisor,
 		.maxlen		= sizeof(u8),
@@ -1339,13 +843,6 @@
 		.proc_handler	= proc_dou8vec_minmax,
 	},
 	{
-		.procname	= "tcp_workaround_signed_windows",
-		.data		= &init_net.ipv4.sysctl_tcp_workaround_signed_windows,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-	},
-	{
 		.procname	= "tcp_limit_output_bytes",
 		.data		= &init_net.ipv4.sysctl_tcp_limit_output_bytes,
 		.maxlen		= sizeof(int),
@@ -1360,14 +857,6 @@
 		.proc_handler	= proc_dointvec
 	},
 	{
-		.procname	= "tcp_min_tso_segs",
-		.data		= &init_net.ipv4.sysctl_tcp_min_tso_segs,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ONE,
-	},
-	{
 		.procname	= "tcp_tso_rtt_log",
 		.data		= &init_net.ipv4.sysctl_tcp_tso_rtt_log,
 		.maxlen		= sizeof(u8),
@@ -1465,15 +954,6 @@
 		.extra2		= SYSCTL_ONE,
 	},
 	{
-		.procname       = "tcp_reflect_tos",
-		.data           = &init_net.ipv4.sysctl_tcp_reflect_tos,
-		.maxlen         = sizeof(u8),
-		.mode           = 0644,
-		.proc_handler   = proc_dou8vec_minmax,
-		.extra1         = SYSCTL_ZERO,
-		.extra2         = SYSCTL_ONE,
-	},
-	{
 		.procname	= "tcp_ehash_entries",
 		.data		= &init_net.ipv4.sysctl_tcp_child_ehash_entries,
 		.mode		= 0444,
@@ -1489,21 +969,6 @@
 		.extra2		= &tcp_child_ehash_entries_max,
 	},
 	{
-		.procname	= "udp_hash_entries",
-		.data		= &init_net.ipv4.sysctl_udp_child_hash_entries,
-		.mode		= 0444,
-		.proc_handler	= proc_udp_hash_entries,
-	},
-	{
-		.procname	= "udp_child_hash_entries",
-		.data		= &init_net.ipv4.sysctl_udp_child_hash_entries,
-		.maxlen		= sizeof(unsigned int),
-		.mode		= 0644,
-		.proc_handler	= proc_douintvec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= &udp_child_hash_entries_max,
-	},
-	{
 		.procname	= "udp_rmem_min",
 		.data		= &init_net.ipv4.sysctl_udp_rmem_min,
 		.maxlen		= sizeof(init_net.ipv4.sysctl_udp_rmem_min),
@@ -1570,15 +1035,6 @@
 		.extra2         = &tcp_plb_max_cong_thresh,
 	},
 	{
-		.procname	= "tcp_syn_linear_timeouts",
-		.data		= &init_net.ipv4.sysctl_tcp_syn_linear_timeouts,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= &tcp_syn_linear_timeouts_max,
-	},
-	{
 		.procname	= "tcp_shrink_window",
 		.data		= &init_net.ipv4.sysctl_tcp_shrink_window,
 		.maxlen		= sizeof(u8),
@@ -1647,9 +1103,6 @@
 	if (!net->ipv4.ipv4_hdr)
 		goto err_reg;
 
-	net->ipv4.sysctl_local_reserved_ports = kzalloc(65536 / 8, GFP_KERNEL);
-	if (!net->ipv4.sysctl_local_reserved_ports)
-		goto err_ports;
 
 	proc_fib_multipath_hash_set_seed(net, 0);
 
@@ -1668,7 +1121,6 @@
 {
 	const struct ctl_table *table;
 
-	kfree(net->ipv4.sysctl_local_reserved_ports);
 	table = net->ipv4.ipv4_hdr->ctl_table_arg;
 	unregister_net_sysctl_table(net->ipv4.ipv4_hdr);
 	kfree(table);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_bbr.c linux-master/net/ipv4/tcp_bbr.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_bbr.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/tcp_bbr.c	2025-10-20 00:41:14.000000000 -0300
@@ -295,7 +295,7 @@
 		WRITE_ONCE(sk->sk_pacing_rate, rate);
 }
 
-/* override sysctl_tcp_min_tso_segs */
+/* override CONFIG_SYSCTL_TCP_MIN_TSO_SEGS */
 __bpf_kfunc static u32 bbr_min_tso_segs(struct sock *sk)
 {
 	return READ_ONCE(sk->sk_pacing_rate) < (bbr_min_tso_rate >> 3) ? 1 : 2;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp.c linux-master/net/ipv4/tcp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/tcp.c	2025-10-20 00:41:14.000000000 -0300
@@ -273,7 +273,6 @@
 #include <net/inet_ecn.h>
 #include <net/tcp.h>
 #include <net/tcp_ecn.h>
-#include <net/mptcp.h>
 #include <net/proto_memory.h>
 #include <net/xfrm.h>
 #include <net/ip.h>
@@ -477,7 +476,7 @@
 	tp->snd_cwnd_clamp = ~0;
 	tp->mss_cache = TCP_MSS_DEFAULT;
 
-	tp->reordering = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reordering);
+	tp->reordering = CONFIG_SYSCTL_TCP_REORDERING;
 	tcp_assign_congestion_control(sk);
 
 	tp->tsoffset = 0;
@@ -589,7 +588,7 @@
 
 	/* Connected or passive Fast Open socket? */
 	if (state != TCP_SYN_SENT &&
-	    (state != TCP_SYN_RECV || rcu_access_pointer(tp->fastopen_rsk))) {
+	    (state != TCP_SYN_RECV || 0)) {
 		int target = sock_rcvlowat(sk, 0, INT_MAX);
 		u16 urg_data = READ_ONCE(tp->urg_data);
 
@@ -732,6 +731,7 @@
  * autocorking if we only have an ACK in Qdisc/NIC queues,
  * or if TX completion was delayed after we processed ACK packet.
  */
+#if 0
 static bool tcp_should_autocork(struct sock *sk, struct sk_buff *skb,
 				int size_goal)
 {
@@ -741,6 +741,9 @@
 	       refcount_read(&sk->sk_wmem_alloc) > skb->truesize &&
 	       tcp_skb_can_collapse_to(skb);
 }
+#else
+#define tcp_should_autocork(sk, skb, size_goal) false
+#endif
 
 void tcp_push(struct sock *sk, int flags, int mss_now,
 	      int nonagle, int size_goal)
@@ -1020,61 +1023,6 @@
 	return min(copy, sk->sk_forward_alloc);
 }
 
-void tcp_free_fastopen_req(struct tcp_sock *tp)
-{
-	if (tp->fastopen_req) {
-		kfree(tp->fastopen_req);
-		tp->fastopen_req = NULL;
-	}
-}
-
-int tcp_sendmsg_fastopen(struct sock *sk, struct msghdr *msg, int *copied,
-			 size_t size, struct ubuf_info *uarg)
-{
-	struct tcp_sock *tp = tcp_sk(sk);
-	struct inet_sock *inet = inet_sk(sk);
-	struct sockaddr *uaddr = msg->msg_name;
-	int err, flags;
-
-	if (!(READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_fastopen) &
-	      TFO_CLIENT_ENABLE) ||
-	    (uaddr && msg->msg_namelen >= sizeof(uaddr->sa_family) &&
-	     uaddr->sa_family == AF_UNSPEC))
-		return -EOPNOTSUPP;
-	if (tp->fastopen_req)
-		return -EALREADY; /* Another Fast Open is in progress */
-
-	tp->fastopen_req = kzalloc(sizeof(struct tcp_fastopen_request),
-				   sk->sk_allocation);
-	if (unlikely(!tp->fastopen_req))
-		return -ENOBUFS;
-	tp->fastopen_req->data = msg;
-	tp->fastopen_req->size = size;
-	tp->fastopen_req->uarg = uarg;
-
-	if (inet_test_bit(DEFER_CONNECT, sk)) {
-		err = tcp_connect(sk);
-		/* Same failure procedure as in tcp_v4/6_connect */
-		if (err) {
-			tcp_set_state(sk, TCP_CLOSE);
-			inet->inet_dport = 0;
-			sk->sk_route_caps = 0;
-		}
-	}
-	flags = (msg->msg_flags & MSG_DONTWAIT) ? O_NONBLOCK : 0;
-	err = __inet_stream_connect(sk->sk_socket, uaddr,
-				    msg->msg_namelen, flags, 1);
-	/* fastopen_req could already be freed in __inet_stream_connect
-	 * if the connection times out or gets rst
-	 */
-	if (tp->fastopen_req) {
-		*copied = tp->fastopen_req->copied;
-		tcp_free_fastopen_req(tp);
-		inet_clear_bit(DEFER_CONNECT, sk);
-	}
-	return err;
-}
-
 int tcp_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t size)
 {
 	struct net_devmem_dmabuf_binding *binding = NULL;
@@ -1137,16 +1085,6 @@
 		goto out_err;
 	}
 
-	if (unlikely(flags & MSG_FASTOPEN ||
-		     inet_test_bit(DEFER_CONNECT, sk)) &&
-	    !tp->repair) {
-		err = tcp_sendmsg_fastopen(sk, msg, &copied_syn, size, uarg);
-		if (err == -EINPROGRESS && copied_syn > 0)
-			goto out;
-		else if (err)
-			goto out_err;
-	}
-
 	timeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);
 
 	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */
@@ -1156,7 +1094,7 @@
 	 * is fully established.
 	 */
 	if (((1 << sk->sk_state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &&
-	    !tcp_passive_fastopen(sk)) {
+	    !0) {
 		err = sk_stream_wait_connect(sk, &timeo);
 		if (err != 0)
 			goto do_error;
@@ -3273,16 +3211,6 @@
 	}
 
 	if (sk->sk_state == TCP_CLOSE) {
-		struct request_sock *req;
-
-		req = rcu_dereference_protected(tcp_sk(sk)->fastopen_rsk,
-						lockdep_sock_is_held(sk));
-		/* We could get here with a non-NULL req if the socket is
-		 * aborted (e.g., closed with unread data) before 3WHS
-		 * finishes.
-		 */
-		if (req)
-			reqsk_fastopen_remove(sk, req, false);
 		inet_csk_destroy_sock(sk);
 	}
 	/* Otherwise, socket is reprieved until protocol close. */
@@ -3382,7 +3310,6 @@
 	WRITE_ONCE(tp->urg_data, 0);
 	sk_set_peek_off(sk, -1);
 	tcp_write_queue_purge(sk);
-	tcp_fastopen_active_disable_ofo_check(sk);
 	skb_rbtree_purge(&tp->out_of_order_queue);
 
 	inet->inet_dport = 0;
@@ -3463,8 +3390,6 @@
 	tp->rack.last_delivered = 0;
 	tp->rack.reo_wnd_persist = 0;
 	tp->rack.dsack_seen = 0;
-	tp->syn_data_acked = 0;
-	tp->syn_fastopen_child = 0;
 	tp->rx_opt.saw_tstamp = 0;
 	tp->rx_opt.dsack = 0;
 	tp->rx_opt.num_sacks = 0;
@@ -3472,13 +3397,7 @@
 
 
 	/* Clean up fastopen related fields */
-	req = rcu_dereference_protected(tp->fastopen_rsk,
-					lockdep_sock_is_held(sk));
-	if (req)
-		reqsk_fastopen_remove(sk, req, false);
-	tcp_free_fastopen_req(tp);
 	inet_clear_bit(DEFER_CONNECT, sk);
-	tp->fastopen_client_fail = 0;
 
 	WARN_ON(inet->inet_num && !icsk->icsk_bind_hash);
 
@@ -3806,7 +3725,6 @@
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct inet_connection_sock *icsk = inet_csk(sk);
-	struct net *net = sock_net(sk);
 	int val;
 	int err = 0;
 
@@ -3849,25 +3767,6 @@
 		sockopt_release_sock(sk);
 		return err;
 	}
-	case TCP_FASTOPEN_KEY: {
-		__u8 key[TCP_FASTOPEN_KEY_BUF_LENGTH];
-		__u8 *backup_key = NULL;
-
-		/* Allow a backup key as well to facilitate key rotation
-		 * First key is the active one.
-		 */
-		if (optlen != TCP_FASTOPEN_KEY_LENGTH &&
-		    optlen != TCP_FASTOPEN_KEY_BUF_LENGTH)
-			return -EINVAL;
-
-		if (copy_from_sockptr(key, optval, optlen))
-			return -EFAULT;
-
-		if (optlen == TCP_FASTOPEN_KEY_BUF_LENGTH)
-			backup_key = key + TCP_FASTOPEN_KEY_LENGTH;
-
-		return tcp_fastopen_reset_cipher(net, sk, key, backup_key);
-	}
 	default:
 		/* fallthru */
 		break;
@@ -4062,37 +3961,6 @@
 		err = tp->af_specific->md5_parse(sk, optname, optval, optlen);
 		break;
 #endif
-	case TCP_FASTOPEN:
-		if (val >= 0 && ((1 << sk->sk_state) & (TCPF_CLOSE |
-		    TCPF_LISTEN))) {
-			tcp_fastopen_init_key_once(net);
-
-			fastopen_queue_tune(sk, val);
-		} else {
-			err = -EINVAL;
-		}
-		break;
-	case TCP_FASTOPEN_CONNECT:
-		if (val > 1 || val < 0) {
-			err = -EINVAL;
-		} else if (READ_ONCE(net->ipv4.sysctl_tcp_fastopen) &
-			   TFO_CLIENT_ENABLE) {
-			if (sk->sk_state == TCP_CLOSE)
-				tp->fastopen_connect = val;
-			else
-				err = -EINVAL;
-		} else {
-			err = -EOPNOTSUPP;
-		}
-		break;
-	case TCP_FASTOPEN_NO_COOKIE:
-		if (val > 1 || val < 0)
-			err = -EINVAL;
-		else if (!((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN)))
-			err = -EINVAL;
-		else
-			tp->fastopen_no_cookie = val;
-		break;
 	case TCP_TIMESTAMP:
 		if (!tp->repair) {
 			err = -EPERM;
@@ -4226,12 +4094,8 @@
 		info->tcpi_options |= TCPI_OPT_ECN;
 	if (tp->ecn_flags & TCP_ECN_SEEN)
 		info->tcpi_options |= TCPI_OPT_ECN_SEEN;
-	if (tp->syn_data_acked)
-		info->tcpi_options |= TCPI_OPT_SYN_DATA;
 	if (tp->tcp_usec_ts)
 		info->tcpi_options |= TCPI_OPT_USEC_TS;
-	if (tp->syn_fastopen_child)
-		info->tcpi_options |= TCPI_OPT_TFO_CHILD;
 
 	info->tcpi_rto = jiffies_to_usecs(icsk->icsk_rto);
 	info->tcpi_ato = jiffies_to_usecs(min_t(u32, icsk->icsk_ack.ato,
@@ -4290,7 +4154,6 @@
 	info->tcpi_snd_wnd = tp->snd_wnd;
 	info->tcpi_rcv_wnd = tp->rcv_wnd;
 	info->tcpi_rehash = tp->plb_rehash + tp->timeout_rehash;
-	info->tcpi_fastopen_client_fail = tp->fastopen_client_fail;
 
 	info->tcpi_total_rto = tp->total_rto;
 	info->tcpi_total_rto_recoveries = tp->total_rto_recoveries;
@@ -4428,7 +4291,6 @@
 {
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
-	struct net *net = sock_net(sk);
 	int user_mss;
 	int val, len;
 
@@ -4467,12 +4329,12 @@
 		break;
 	case TCP_SYNCNT:
 		val = READ_ONCE(icsk->icsk_syn_retries) ? :
-			READ_ONCE(net->ipv4.sysctl_tcp_syn_retries);
+			CONFIG_SYSCTL_TCP_SYN_RETRIES;
 		break;
 	case TCP_LINGER2:
 		val = READ_ONCE(tp->linger2);
 		if (val >= 0)
-			val = (val ? : READ_ONCE(net->ipv4.sysctl_tcp_fin_timeout)) / HZ;
+			val = (val ? : CONFIG_SYSCTL_TCP_FIN_TIMEOUT) / HZ;
 		break;
 	case TCP_DEFER_ACCEPT:
 		val = READ_ONCE(icsk->icsk_accept_queue.rskq_defer_accept);
@@ -4547,22 +4409,6 @@
 			return -EFAULT;
 		return 0;
 
-	case TCP_FASTOPEN_KEY: {
-		u64 key[TCP_FASTOPEN_KEY_BUF_LENGTH / sizeof(u64)];
-		unsigned int key_len;
-
-		if (copy_from_sockptr(&len, optlen, sizeof(int)))
-			return -EFAULT;
-
-		key_len = tcp_fastopen_get_cipher(net, icsk, key) *
-				TCP_FASTOPEN_KEY_LENGTH;
-		len = min_t(unsigned int, len, key_len);
-		if (copy_to_sockptr(optlen, &len, sizeof(int)))
-			return -EFAULT;
-		if (copy_to_sockptr(optval, key, len))
-			return -EFAULT;
-		return 0;
-	}
 	case TCP_THIN_LINEAR_TIMEOUTS:
 		val = tp->thin_lto;
 		break;
@@ -4617,18 +4463,6 @@
 		val = READ_ONCE(icsk->icsk_user_timeout);
 		break;
 
-	case TCP_FASTOPEN:
-		val = READ_ONCE(icsk->icsk_accept_queue.fastopenq.max_qlen);
-		break;
-
-	case TCP_FASTOPEN_CONNECT:
-		val = tp->fastopen_connect;
-		break;
-
-	case TCP_FASTOPEN_NO_COOKIE:
-		val = tp->fastopen_no_cookie;
-		break;
-
 	case TCP_TX_DELAY:
 		val = READ_ONCE(tp->tcp_tx_delay);
 		break;
@@ -4765,9 +4599,6 @@
 
 		return err;
 	}
-	case TCP_IS_MPTCP:
-		val = 0;
-		break;
 	case TCP_RTO_MAX_MS:
 		val = jiffies_to_msecs(tcp_rto_max(sk));
 		break;
@@ -4986,21 +4817,12 @@
 
 void tcp_done(struct sock *sk)
 {
-	struct request_sock *req;
-
-	/* We might be called with a new socket, after
-	 * inet_csk_prepare_forced_close() has been called
-	 * so we can not use lockdep_sock_is_held(sk)
-	 */
-	req = rcu_dereference_protected(tcp_sk(sk)->fastopen_rsk, 1);
 
 	if (sk->sk_state == TCP_SYN_SENT || sk->sk_state == TCP_SYN_RECV)
 		TCP_INC_STATS(sock_net(sk), TCP_MIB_ATTEMPTFAILS);
 
 	tcp_set_state(sk, TCP_CLOSE);
 	tcp_clear_xmit_timers(sk);
-	if (req)
-		reqsk_fastopen_remove(sk, req, false);
 
 	WRITE_ONCE(sk->sk_shutdown, SHUTDOWN_MASK);
 
@@ -5285,5 +5107,4 @@
 	tcp_metrics_init();
 	BUG_ON(tcp_register_congestion_control(&tcp_reno) != 0);
 	tcp_tsq_work_init();
-	mptcp_init();
 }
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_input.c linux-master/net/ipv4/tcp_input.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_input.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/tcp_input.c	2025-10-20 00:41:14.000000000 -0300
@@ -82,7 +82,6 @@
 #include <trace/events/tcp.h>
 #include <linux/jump_label_ratelimit.h>
 #include <net/busy_poll.h>
-#include <net/mptcp.h>
 
 int sysctl_tcp_max_orphans __read_mostly = NR_FILE;
 
@@ -897,7 +896,7 @@
 	struct tcp_sock *tp = tcp_sk(sk);
 	int rcvwin, rcvbuf, cap;
 
-	if (!READ_ONCE(net->ipv4.sysctl_tcp_moderate_rcvbuf) ||
+	if (!CONFIG_SYSCTL_TCP_MODERATE_RCVBUF ||
 	    (sk->sk_userlocks & SOCK_RCVBUF_LOCK))
 		return;
 
@@ -1254,7 +1253,7 @@
 			 tp->undo_marker ? tp->undo_retrans : 0);
 #endif
 		tp->reordering = min_t(u32, (metric + mss - 1) / mss,
-				       READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_max_reordering));
+				       CONFIG_SYSCTL_TCP_MAX_REORDERING);
 	}
 
 	/* This exciting event is worth to be remembered. 8) */
@@ -2214,7 +2213,7 @@
 		return;
 
 	tp->reordering = min_t(u32, tp->packets_out + addend,
-			       READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_max_reordering));
+			       CONFIG_SYSCTL_TCP_MAX_REORDERING);
 	tp->reord_seen++;
 	NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRENOREORDER);
 }
@@ -2350,7 +2349,7 @@
 	/* Timeout in disordered state after receiving substantial DUPACKs
 	 * suggests that the degree of reordering is over-estimated.
 	 */
-	reordering = READ_ONCE(net->ipv4.sysctl_tcp_reordering);
+	reordering = CONFIG_SYSCTL_TCP_REORDERING;
 	if (icsk->icsk_ca_state <= TCP_CA_Disorder &&
 	    tp->sacked_out >= reordering)
 		tp->reordering = min_t(unsigned int, tp->reordering,
@@ -2365,7 +2364,7 @@
 	 * loss recovery is underway except recurring timeout(s) on
 	 * the same SND.UNA (sec 3.2). Disable F-RTO on path MTU probing
 	 */
-	tp->frto = READ_ONCE(net->ipv4.sysctl_tcp_frto) &&
+	tp->frto = CONFIG_SYSCTL_TCP_FRTO &&
 		   (new_recovery || icsk->icsk_retransmits) &&
 		   !inet_csk(sk)->icsk_mtup.probe_size;
 }
@@ -2910,19 +2909,6 @@
 	struct sk_buff *skb;
 	int mss;
 
-	/* A fastopen SYN request is stored as two separate packets within
-	 * the retransmit queue, this is done by tcp_send_syn_data().
-	 * As a result simply checking the MSS of the frames in the queue
-	 * will not work for the SYN packet.
-	 *
-	 * Us being here is an indication of a path MTU issue so we can
-	 * assume that the fastopen SYN was lost and just mark all the
-	 * frames in the retransmit queue as lost. We will use an MSS of
-	 * -1 to mark all frames as lost, otherwise compute the current MSS.
-	 */
-	if (tp->syn_data && sk->sk_state == TCP_SYN_SENT)
-		mss = -1;
-	else
 		mss = tcp_current_mss(sk);
 
 	skb_rbtree_walk(skb, &sk->tcp_rtx_queue) {
@@ -2990,7 +2976,7 @@
 	struct tcp_sock *tp = tcp_sk(sk);
 	bool recovered = !before(tp->snd_una, tp->high_seq);
 
-	if ((flag & FLAG_SND_UNA_ADVANCED || rcu_access_pointer(tp->fastopen_rsk)) &&
+	if ((flag & FLAG_SND_UNA_ADVANCED || 0) &&
 	    tcp_try_undo_loss(sk, false))
 		return;
 
@@ -3124,7 +3110,7 @@
 	/* D. Check state exit conditions. State can be terminated
 	 *    when high_seq is ACKed. */
 	if (icsk->icsk_ca_state == TCP_CA_Open) {
-		WARN_ON(tp->retrans_out != 0 && !tp->syn_data);
+		WARN_ON(tp->retrans_out != 0 && !0);
 		tp->retrans_stamp = 0;
 	} else if (!before(tp->snd_una, tp->high_seq)) {
 		switch (icsk->icsk_ca_state) {
@@ -3299,12 +3285,6 @@
 	const struct inet_connection_sock *icsk = inet_csk(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
 
-	/* If the retrans timer is currently being used by Fast Open
-	 * for SYN-ACK retrans purpose, stay put.
-	 */
-	if (rcu_access_pointer(tp->fastopen_rsk))
-		return;
-
 	if (!tp->packets_out) {
 		inet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);
 	} else {
@@ -3617,7 +3597,7 @@
 	 * cwnd in tcp_fastretrans_alert() based on more states.
 	 */
 	if (tcp_sk(sk)->reordering >
-	    READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reordering))
+	    CONFIG_SYSCTL_TCP_REORDERING)
 		return flag & FLAG_FORWARD_PROGRESS;
 
 	return flag & FLAG_DATA_ACKED;
@@ -4176,23 +4156,6 @@
 	return 0;
 }
 
-static void tcp_parse_fastopen_option(int len, const unsigned char *cookie,
-				      bool syn, struct tcp_fastopen_cookie *foc,
-				      bool exp_opt)
-{
-	/* Valid only in SYN or SYN-ACK with an even length.  */
-	if (!foc || !syn || len < 0 || (len & 1))
-		return;
-
-	if (len >= TCP_FASTOPEN_COOKIE_MIN &&
-	    len <= TCP_FASTOPEN_COOKIE_MAX)
-		memcpy(foc->val, cookie, len);
-	else if (len != 0)
-		len = -1;
-	foc->len = len;
-	foc->exp = exp_opt;
-}
-
 static bool smc_parse_options(const struct tcphdr *th,
 			      struct tcp_options_received *opt_rx,
 			      const unsigned char *ptr,
@@ -4260,8 +4223,7 @@
  */
 void tcp_parse_options(const struct net *net,
 		       const struct sk_buff *skb,
-		       struct tcp_options_received *opt_rx, int estab,
-		       struct tcp_fastopen_cookie *foc)
+		       struct tcp_options_received *opt_rx, int estab)
 {
 	const unsigned char *ptr;
 	const struct tcphdr *th = tcp_hdr(skb);
@@ -4320,7 +4282,7 @@
 			case TCPOPT_TIMESTAMP:
 				if ((opsize == TCPOLEN_TIMESTAMP) &&
 				    ((estab && opt_rx->tstamp_ok) ||
-				     (!estab && READ_ONCE(net->ipv4.sysctl_tcp_timestamps)))) {
+				     (!estab && CONFIG_SYSCTL_TCP_TIMESTAMPS))) {
 					opt_rx->saw_tstamp = 1;
 					opt_rx->rcv_tsval = get_unaligned_be32(ptr);
 					opt_rx->rcv_tsecr = get_unaligned_be32(ptr + 4);
@@ -4355,11 +4317,6 @@
 				 */
 				break;
 #endif
-			case TCPOPT_FASTOPEN:
-				tcp_parse_fastopen_option(
-					opsize - TCPOLEN_FASTOPEN_BASE,
-					ptr, th->syn, foc, false);
-				break;
 
 			case TCPOPT_ACCECN0:
 			case TCPOPT_ACCECN1:
@@ -4368,15 +4325,10 @@
 				break;
 
 			case TCPOPT_EXP:
-				/* Fast Open option shares code 254 using a
-				 * 16 bits magic number.
-				 */
-				if (opsize >= TCPOLEN_EXP_FASTOPEN_BASE &&
+				if (opsize >= 4 &&
 				    get_unaligned_be16(ptr) ==
-				    TCPOPT_FASTOPEN_MAGIC) {
-					tcp_parse_fastopen_option(opsize -
-						TCPOLEN_EXP_FASTOPEN_BASE,
-						ptr + 2, th->syn, foc, true);
+				    0xF989) {
+                    // TODO:
 					break;
 				}
 
@@ -4437,7 +4389,7 @@
 		}
 	}
 
-	tcp_parse_options(net, skb, &tp->rx_opt, 1, NULL);
+	tcp_parse_options(net, skb, &tp->rx_opt, 1);
 	if (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)
 		tp->rx_opt.rcv_tsecr -= tp->tsoffset;
 
@@ -4629,12 +4581,6 @@
 
 	trace_tcp_receive_reset(sk);
 
-	/* mptcp can't tell us to ignore reset pkts,
-	 * so just ignore the return value of mptcp_incoming_options().
-	 */
-	if (sk_is_mptcp(sk))
-		mptcp_incoming_options(sk, skb);
-
 	/* We want the right error as BSD sees it (and indeed as we do). */
 	switch (sk->sk_state) {
 	case TCP_SYN_SENT:
@@ -5358,10 +5304,6 @@
 	/* If a subflow has been reset, the packet should not continue
 	 * to be processed, drop the packet.
 	 */
-	if (sk_is_mptcp(sk) && !mptcp_incoming_options(sk, skb)) {
-		__kfree_skb(skb);
-		return;
-	}
 
 	if (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq) {
 		__kfree_skb(skb);
@@ -5603,7 +5545,6 @@
 		else
 			__skb_queue_tail(&tmp, nskb); /* defer rbtree insertion */
 		skb_set_owner_r(nskb, sk);
-		mptcp_skb_ext_move(nskb, skb);
 
 		/* Copy data, releasing collapsed skbs. */
 		while (copy > 0) {
@@ -5968,7 +5909,7 @@
 	struct tcp_sock *tp = tcp_sk(sk);
 	u32 ptr = ntohs(th->urg_ptr);
 
-	if (ptr && !READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_stdurg))
+	if (ptr && !CONFIG_SYSCTL_TCP_STDURG)
 		ptr--;
 	ptr += ntohl(th->seq);
 
@@ -6169,13 +6110,6 @@
 				goto reset;
 		}
 
-		/* Disable TFO if RST is out-of-order
-		 * and no data has been received
-		 * for current active TFO socket
-		 */
-		if (tp->syn_fastopen && !tp->data_segs_in &&
-		    sk->sk_state == TCP_ESTABLISHED)
-			tcp_fastopen_active_disable(sk);
 		tcp_send_challenge_ack(sk, false);
 		SKB_DR_SET(reason, TCP_RESET);
 		goto discard;
@@ -6514,69 +6448,6 @@
 		tp->pred_flags = 0;
 }
 
-static bool tcp_rcv_fastopen_synack(struct sock *sk, struct sk_buff *synack,
-				    struct tcp_fastopen_cookie *cookie)
-{
-	struct tcp_sock *tp = tcp_sk(sk);
-	struct sk_buff *data = tp->syn_data ? tcp_rtx_queue_head(sk) : NULL;
-	u16 mss = tp->rx_opt.mss_clamp, try_exp = 0;
-	bool syn_drop = false;
-
-	if (mss == READ_ONCE(tp->rx_opt.user_mss)) {
-		struct tcp_options_received opt;
-
-		/* Get original SYNACK MSS value if user MSS sets mss_clamp */
-		tcp_clear_options(&opt);
-		opt.user_mss = opt.mss_clamp = 0;
-		tcp_parse_options(sock_net(sk), synack, &opt, 0, NULL);
-		mss = opt.mss_clamp;
-	}
-
-	if (!tp->syn_fastopen) {
-		/* Ignore an unsolicited cookie */
-		cookie->len = -1;
-	} else if (tp->total_retrans) {
-		/* SYN timed out and the SYN-ACK neither has a cookie nor
-		 * acknowledges data. Presumably the remote received only
-		 * the retransmitted (regular) SYNs: either the original
-		 * SYN-data or the corresponding SYN-ACK was dropped.
-		 */
-		syn_drop = (cookie->len < 0 && data);
-	} else if (cookie->len < 0 && !tp->syn_data) {
-		/* We requested a cookie but didn't get it. If we did not use
-		 * the (old) exp opt format then try so next time (try_exp=1).
-		 * Otherwise we go back to use the RFC7413 opt (try_exp=2).
-		 */
-		try_exp = tp->syn_fastopen_exp ? 2 : 1;
-	}
-
-	tcp_fastopen_cache_set(sk, mss, cookie, syn_drop, try_exp);
-
-	if (data) { /* Retransmit unacked data in SYN */
-		if (tp->total_retrans)
-			tp->fastopen_client_fail = TFO_SYN_RETRANSMITTED;
-		else
-			tp->fastopen_client_fail = TFO_DATA_NOT_ACKED;
-		skb_rbtree_walk_from(data)
-			 tcp_mark_skb_lost(sk, data);
-		tcp_non_congestion_loss_retransmit(sk);
-		NET_INC_STATS(sock_net(sk),
-				LINUX_MIB_TCPFASTOPENACTIVEFAIL);
-		return true;
-	}
-	tp->syn_data_acked = tp->syn_data;
-	if (tp->syn_data_acked) {
-		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPFASTOPENACTIVE);
-		/* SYN-data is counted as two separate packets in tcp_ack() */
-		if (tp->delivered > 1)
-			--tp->delivered;
-	}
-
-	tcp_fastopen_add_skb(sk, synack);
-
-	return false;
-}
-
 static void smc_check_reset_syn(struct tcp_sock *tp)
 {
 #if IS_ENABLED(CONFIG_SMC)
@@ -6607,12 +6478,10 @@
 {
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
-	struct tcp_fastopen_cookie foc = { .len = -1 };
 	int saved_clamp = tp->rx_opt.mss_clamp;
-	bool fastopen_fail;
 	SKB_DR(reason);
 
-	tcp_parse_options(sock_net(sk), skb, &tp->rx_opt, 0, &foc);
+	tcp_parse_options(sock_net(sk), skb, &tp->rx_opt, 0);
 	if (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)
 		tp->rx_opt.rcv_tsecr -= tp->tsoffset;
 
@@ -6726,15 +6595,10 @@
 
 		tcp_finish_connect(sk, skb);
 
-		fastopen_fail = (tp->syn_fastopen || tp->syn_data) &&
-				tcp_rcv_fastopen_synack(sk, skb, &foc);
-
 		if (!sock_flag(sk, SOCK_DEAD)) {
 			sk->sk_state_change(sk);
 			sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);
 		}
-		if (fastopen_fail)
-			return -1;
 		if (sk->sk_write_pending ||
 		    READ_ONCE(icsk->icsk_accept_queue.rskq_defer_accept) ||
 		    inet_csk_in_pingpong_mode(sk)) {
@@ -6851,47 +6715,6 @@
 	return reason;
 }
 
-static void tcp_rcv_synrecv_state_fastopen(struct sock *sk)
-{
-	struct tcp_sock *tp = tcp_sk(sk);
-	struct request_sock *req;
-
-	/* If we are still handling the SYNACK RTO, see if timestamp ECR allows
-	 * undo. If peer SACKs triggered fast recovery, we can't undo here.
-	 */
-	if (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss && !tp->packets_out)
-		tcp_try_undo_recovery(sk);
-
-	tcp_update_rto_time(tp);
-	WRITE_ONCE(inet_csk(sk)->icsk_retransmits, 0);
-	/* In tcp_fastopen_synack_timer() on the first SYNACK RTO we set
-	 * retrans_stamp but don't enter CA_Loss, so in case that happened we
-	 * need to zero retrans_stamp here to prevent spurious
-	 * retransmits_timed_out(). However, if the ACK of our SYNACK caused us
-	 * to enter CA_Recovery then we need to leave retrans_stamp as it was
-	 * set entering CA_Recovery, for correct retransmits_timed_out() and
-	 * undo behavior.
-	 */
-	tcp_retrans_stamp_cleanup(sk);
-
-	/* Once we leave TCP_SYN_RECV or TCP_FIN_WAIT_1,
-	 * we no longer need req so release it.
-	 */
-	req = rcu_dereference_protected(tp->fastopen_rsk,
-					lockdep_sock_is_held(sk));
-	reqsk_fastopen_remove(sk, req, false);
-
-	/* Re-arm the timer because data may have been sent out.
-	 * This is similar to the regular data transmission case
-	 * when new data has just been ack'ed.
-	 *
-	 * (TFO) - we could try to be more aggressive and
-	 * retransmitting any data sooner based on when they
-	 * are sent out.
-	 */
-	tcp_rearm_rto(sk);
-}
-
 /*
  *	This function implements the receiving procedure of RFC 793 for
  *	all states except ESTABLISHED and TIME_WAIT.
@@ -6905,7 +6728,6 @@
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	const struct tcphdr *th = tcp_hdr(skb);
-	struct request_sock *req;
 	int queued = 0;
 	SKB_DR(reason);
 
@@ -6958,18 +6780,6 @@
 
 	tcp_mstamp_refresh(tp);
 	tp->rx_opt.saw_tstamp = 0;
-	req = rcu_dereference_protected(tp->fastopen_rsk,
-					lockdep_sock_is_held(sk));
-	if (req) {
-		bool req_stolen;
-
-		WARN_ON_ONCE(sk->sk_state != TCP_SYN_RECV &&
-		    sk->sk_state != TCP_FIN_WAIT1);
-
-		SKB_DR_SET(reason, TCP_FASTOPEN);
-		if (!tcp_check_req(sk, skb, req, true, &req_stolen, &reason))
-			goto discard;
-	}
 
 	if (!th->ack && !th->rst && !th->syn) {
 		SKB_DR_SET(reason, TCP_FLAGS);
@@ -7002,14 +6812,12 @@
 	case TCP_SYN_RECV:
 		tp->delivered++; /* SYN-ACK delivery isn't tracked in tcp_ack */
 		if (!tp->srtt_us)
-			tcp_synack_rtt_meas(sk, req);
+			tcp_synack_rtt_meas(sk, NULL);
 
 		if (tp->rx_opt.tstamp_ok)
 			tp->advmss -= TCPOLEN_TSTAMP_ALIGNED;
 
-		if (req) {
-			tcp_rcv_synrecv_state_fastopen(sk);
-		} else {
+		{
 			tcp_try_undo_spurious_syn(sk);
 			tp->retrans_stamp = 0;
 			tcp_init_transfer(sk, BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB,
@@ -7050,9 +6858,6 @@
 	case TCP_FIN_WAIT1: {
 		int tmo;
 
-		if (req)
-			tcp_rcv_synrecv_state_fastopen(sk);
-
 		if (tp->snd_una != tp->write_seq)
 			break;
 
@@ -7075,8 +6880,6 @@
 		if (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&
 		    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {
 			/* Receive out of order FIN after close() */
-			if (tp->syn_fastopen && th->fin)
-				tcp_fastopen_active_disable(sk);
 			tcp_done(sk);
 			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);
 			return SKB_DROP_REASON_TCP_ABORT_ON_DATA;
@@ -7128,8 +6931,6 @@
 			/* If a subflow has been reset, the packet should not
 			 * continue to be processed, drop the packet.
 			 */
-			if (sk_is_mptcp(sk) && !mptcp_incoming_options(sk, skb))
-				goto discard;
 			break;
 		}
 		fallthrough;
@@ -7282,7 +7083,7 @@
 	bool want_cookie = false;
 	u8 syncookies;
 
-	syncookies = READ_ONCE(net->ipv4.sysctl_tcp_syncookies);
+	syncookies = CONFIG_SYSCTL_TCP_SYNCOOKIES;
 
 #ifdef CONFIG_SYN_COOKIES
 	if (syncookies) {
@@ -7350,7 +7151,7 @@
 	struct tcp_sock *tp = tcp_sk(sk);
 	u16 mss;
 
-	if (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_syncookies) != 2 &&
+	if (CONFIG_SYSCTL_TCP_SYNCOOKIES != 2 &&
 	    !inet_csk_reqsk_queue_is_full(sk))
 		return 0;
 
@@ -7374,11 +7175,9 @@
 		     const struct tcp_request_sock_ops *af_ops,
 		     struct sock *sk, struct sk_buff *skb)
 {
-	struct tcp_fastopen_cookie foc = { .len = -1 };
 	struct tcp_options_received tmp_opt;
 	const struct tcp_sock *tp = tcp_sk(sk);
 	struct net *net = sock_net(sk);
-	struct sock *fastopen_sk = NULL;
 	struct request_sock *req;
 	bool want_cookie = false;
 	struct dst_entry *dst;
@@ -7398,7 +7197,7 @@
 		 */
 		__this_cpu_write(tcp_tw_isn, 0);
 	} else {
-		syncookies = READ_ONCE(net->ipv4.sysctl_tcp_syncookies);
+		syncookies = CONFIG_SYSCTL_TCP_SYNCOOKIES;
 
 		if (syncookies == 2 || inet_csk_reqsk_queue_is_full(sk)) {
 			want_cookie = tcp_syn_flood_action(sk,
@@ -7421,15 +7220,11 @@
 	tcp_rsk(req)->af_specific = af_ops;
 	tcp_rsk(req)->ts_off = 0;
 	tcp_rsk(req)->req_usec_ts = false;
-#if IS_ENABLED(CONFIG_MPTCP)
-	tcp_rsk(req)->is_mptcp = 0;
-#endif
 
 	tcp_clear_options(&tmp_opt);
 	tmp_opt.mss_clamp = af_ops->mss_clamp;
 	tmp_opt.user_mss  = READ_ONCE(tp->rx_opt.user_mss);
-	tcp_parse_options(sock_net(sk), skb, &tmp_opt, 0,
-			  want_cookie ? NULL : &foc);
+	tcp_parse_options(sock_net(sk), skb, &tmp_opt, 0);
 
 	if (want_cookie && !tmp_opt.saw_tstamp)
 		tcp_clear_options(&tmp_opt);
@@ -7453,7 +7248,7 @@
 		tcp_rsk(req)->ts_off = af_ops->init_ts_off(net, skb);
 	}
 	if (!want_cookie && !isn) {
-		int max_syn_backlog = READ_ONCE(net->ipv4.sysctl_max_syn_backlog);
+		int max_syn_backlog = CONFIG_SYSCTL_MAX_SYN_BACKLOG;
 
 		/* Kill the following clause, if you dislike this way. */
 		if (!syncookies &&
@@ -7502,22 +7297,10 @@
 	sk_rx_queue_set(req_to_sk(req), skb);
 	if (!want_cookie) {
 		tcp_reqsk_record_syn(sk, req, skb);
-		fastopen_sk = tcp_try_fastopen(sk, skb, req, &foc, dst);
 	}
-	if (fastopen_sk) {
-		af_ops->send_synack(fastopen_sk, dst, &fl, req,
-				    &foc, TCP_SYNACK_FASTOPEN, skb);
-		/* Add the child socket directly into the accept queue */
-		if (!inet_csk_reqsk_queue_add(sk, req, fastopen_sk)) {
-			bh_unlock_sock(fastopen_sk);
-			sock_put(fastopen_sk);
-			goto drop_and_free;
-		}
-		sk->sk_data_ready(sk);
-		bh_unlock_sock(fastopen_sk);
-		sock_put(fastopen_sk);
+	if (0) {
+
 	} else {
-		tcp_rsk(req)->tfo_listener = false;
 		if (!want_cookie) {
 			req->timeout = tcp_timeout_init((struct sock *)req);
 			if (unlikely(!inet_csk_reqsk_queue_hash_add(sk, req,
@@ -7528,7 +7311,7 @@
 			}
 
 		}
-		af_ops->send_synack(sk, dst, &fl, req, &foc,
+		af_ops->send_synack(sk, dst, &fl, req,
 				    !want_cookie ? TCP_SYNACK_NORMAL :
 						   TCP_SYNACK_COOKIE,
 				    skb);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_ipv4.c linux-master/net/ipv4/tcp_ipv4.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_ipv4.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/tcp_ipv4.c	2025-10-20 00:41:14.000000000 -0300
@@ -339,8 +339,6 @@
 
 	atomic_set(&inet->inet_id, get_random_u16());
 
-	if (tcp_fastopen_defer_connect(sk, &err))
-		return err;
 	if (err)
 		goto failure;
 
@@ -502,7 +500,6 @@
 	struct net *net = dev_net_rcu(skb->dev);
 	const int type = icmp_hdr(skb)->type;
 	const int code = icmp_hdr(skb)->code;
-	struct request_sock *fastopen;
 	struct tcp_sock *tp;
 	u32 seq, snd_una;
 	struct sock *sk;
@@ -557,9 +554,7 @@
 	}
 
 	tp = tcp_sk(sk);
-	/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */
-	fastopen = rcu_dereference(tp->fastopen_rsk);
-	snd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;
+	snd_una = tp->snd_una;
 	if (sk->sk_state != TCP_LISTEN &&
 	    !between(seq, snd_una, tp->snd_nxt)) {
 		__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);
@@ -603,7 +598,7 @@
 		/* check if this ICMP message allows revert of backoff.
 		 * (see RFC 6069)
 		 */
-		if (!fastopen &&
+		if (!0 &&
 		    (code == ICMP_NET_UNREACH || code == ICMP_HOST_UNREACH))
 			tcp_ld_RTO_revert(sk, seq);
 		break;
@@ -617,11 +612,6 @@
 	switch (sk->sk_state) {
 	case TCP_SYN_SENT:
 	case TCP_SYN_RECV:
-		/* Only in fast or simultaneous open. If a fast open socket is
-		 * already accepted it is treated as a connected one below.
-		 */
-		if (fastopen && !fastopen->sk)
-			break;
 
 		ip_icmp_error(sk, skb, err, th->dest, info, (u8 *)th);
 
@@ -863,7 +853,7 @@
 #endif
 	/* Can't co-exist with TCPMD5, hence check rep.opt[0] */
 	if (rep.opt[0] == 0) {
-		__be32 mrst = mptcp_reset_option(skb);
+		__be32 mrst = htonl(0u);
 
 		if (mrst) {
 			rep.opt[0] = mrst;
@@ -1187,7 +1177,6 @@
 static int tcp_v4_send_synack(const struct sock *sk, struct dst_entry *dst,
 			      struct flowi *fl,
 			      struct request_sock *req,
-			      struct tcp_fastopen_cookie *foc,
 			      enum tcp_synack_type synack_type,
 			      struct sk_buff *syn_skb)
 {
@@ -1201,7 +1190,7 @@
 	if (!dst && (dst = inet_csk_route_req(sk, &fl4, req)) == NULL)
 		return -1;
 
-	skb = tcp_make_synack(sk, dst, req, foc, synack_type, syn_skb);
+	skb = tcp_make_synack(sk, dst, req, synack_type, syn_skb);
 
 	if (skb) {
 		tcp_rsk(req)->syn_ect_snt = inet_sk(sk)->tos & INET_ECN_MASK;
@@ -1209,7 +1198,7 @@
 
 		tos = READ_ONCE(inet_sk(sk)->tos);
 
-		if (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reflect_tos))
+		if (CONFIG_SYSCTL_TCP_REFLECT_TOS)
 			tos = (tcp_rsk(req)->syn_tos & ~INET_ECN_MASK) |
 			      (tos & INET_ECN_MASK);
 
@@ -1796,7 +1785,7 @@
 	/* Set ToS of the new socket based upon the value of incoming SYN.
 	 * ECT bits are set later in tcp_init_transfer().
 	 */
-	if (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reflect_tos))
+	if (CONFIG_SYSCTL_TCP_REFLECT_TOS)
 		newinet->tos = tcp_rsk(req)->syn_tos & ~INET_ECN_MASK;
 
 	if (!dst) {
@@ -2294,7 +2283,7 @@
 			th = (const struct tcphdr *)skb->data;
 			iph = ip_hdr(skb);
 			tcp_v4_fill_cb(skb, iph, th);
-			nsk = tcp_check_req(sk, skb, req, false, &req_stolen,
+			nsk = tcp_check_req(sk, skb, req, &req_stolen,
 					    &drop_reason);
 		}
 		if (!nsk) {
@@ -2566,9 +2555,6 @@
 	/* Cleanup up the write buffer. */
 	tcp_write_queue_purge(sk);
 
-	/* Check if we want to disable active TFO */
-	tcp_fastopen_active_disable_ofo_check(sk);
-
 	/* Cleans up our, hopefully empty, out_of_order_queue. */
 	skb_rbtree_purge(&tp->out_of_order_queue);
 
@@ -2576,11 +2562,7 @@
 	if (inet_csk(sk)->icsk_bind_hash)
 		inet_put_port(sk);
 
-	BUG_ON(rcu_access_pointer(tp->fastopen_rsk));
-
 	/* If socket is aborted during connect operation */
-	tcp_free_fastopen_req(tp);
-	tcp_fastopen_destroy_cipher(sk);
 	tcp_saved_syn_free(tp);
 
 	sk_sockets_allocated_dec(sk);
@@ -2905,7 +2887,6 @@
 	const struct tcp_sock *tp = tcp_sk(sk);
 	const struct inet_connection_sock *icsk = inet_csk(sk);
 	const struct inet_sock *inet = inet_sk(sk);
-	const struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;
 	__be32 dest = inet->inet_daddr;
 	__be32 src = inet->inet_rcv_saddr;
 	__u16 destp = ntohs(inet->inet_dport);
@@ -2958,7 +2939,7 @@
 		(icsk->icsk_ack.quick << 1) | inet_csk_in_pingpong_mode(sk),
 		tcp_snd_cwnd(tp),
 		state == TCP_LISTEN ?
-		    fastopenq->max_qlen :
+		    0 :
 		    (tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh));
 }
 
@@ -3567,7 +3548,6 @@
 
 	net->ipv4.tcp_death_row.hashinfo = hinfo;
 	net->ipv4.tcp_death_row.sysctl_max_tw_buckets = ehash_entries / 2;
-	net->ipv4.sysctl_max_syn_backlog = max(128U, ehash_entries / 128);
 }
 
 static int __net_init tcp_sk_init(struct net *net)
@@ -3579,43 +3559,22 @@
 
 	net->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;
 	net->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;
-	net->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;
-	net->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;
 	net->ipv4.sysctl_tcp_mtu_probe_floor = TCP_MIN_SND_MSS;
 
-	net->ipv4.sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;
-	net->ipv4.sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;
-	net->ipv4.sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;
-
-	net->ipv4.sysctl_tcp_syn_retries = TCP_SYN_RETRIES;
-	net->ipv4.sysctl_tcp_synack_retries = TCP_SYNACK_RETRIES;
-	net->ipv4.sysctl_tcp_syncookies = 1;
-	net->ipv4.sysctl_tcp_reordering = TCP_FASTRETRANS_THRESH;
-	net->ipv4.sysctl_tcp_retries1 = TCP_RETR1;
-	net->ipv4.sysctl_tcp_retries2 = TCP_RETR2;
-	net->ipv4.sysctl_tcp_orphan_retries = 0;
-	net->ipv4.sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;
 	net->ipv4.sysctl_tcp_notsent_lowat = UINT_MAX;
 	net->ipv4.sysctl_tcp_tw_reuse = 2;
 	net->ipv4.sysctl_tcp_tw_reuse_delay = 1 * MSEC_PER_SEC;
-	net->ipv4.sysctl_tcp_no_ssthresh_metrics_save = 1;
 
 	refcount_set(&net->ipv4.tcp_death_row.tw_refcount, 1);
 	tcp_set_hashinfo(net);
 
 	net->ipv4.sysctl_tcp_sack = 1;
 	net->ipv4.sysctl_tcp_window_scaling = 1;
-	net->ipv4.sysctl_tcp_timestamps = 1;
 	net->ipv4.sysctl_tcp_early_retrans = 3;
 	net->ipv4.sysctl_tcp_recovery = TCP_RACK_LOSS_DETECTION;
 	net->ipv4.sysctl_tcp_slow_start_after_idle = 1; /* By default, RFC2861 behavior.  */
-	net->ipv4.sysctl_tcp_retrans_collapse = 1;
-	net->ipv4.sysctl_tcp_max_reordering = 300;
 	net->ipv4.sysctl_tcp_dsack = 1;
 	net->ipv4.sysctl_tcp_app_win = 31;
-	net->ipv4.sysctl_tcp_adv_win_scale = 1;
-	net->ipv4.sysctl_tcp_frto = 2;
-	net->ipv4.sysctl_tcp_moderate_rcvbuf = 1;
 	/* This limits the percentage of the congestion window which we
 	 * will allow a single TSO frame to consume.  Building TSO frames
 	 * which are too large can cause TCP streams to be bursty.
@@ -3627,7 +3586,6 @@
 	/* rfc5961 challenge ack rate limiting, per net-ns, disabled by default. */
 	net->ipv4.sysctl_tcp_challenge_ack_limit = INT_MAX;
 
-	net->ipv4.sysctl_tcp_min_tso_segs = 2;
 	net->ipv4.sysctl_tcp_tso_rtt_log = 9;  /* 2^9 = 512 usec */
 	net->ipv4.sysctl_tcp_min_rtt_wlen = 300;
 	net->ipv4.sysctl_tcp_autocorking = 1;
@@ -3646,9 +3604,6 @@
 	net->ipv4.sysctl_tcp_comp_sack_slack_ns = 100 * NSEC_PER_USEC;
 	net->ipv4.sysctl_tcp_comp_sack_nr = 44;
 	net->ipv4.sysctl_tcp_backlog_ack_defer = 1;
-	net->ipv4.sysctl_tcp_fastopen = TFO_CLIENT_ENABLE;
-	net->ipv4.sysctl_tcp_fastopen_blackhole_timeout = 0;
-	atomic_set(&net->ipv4.tfo_active_disable_times, 0);
 
 	/* Set default values for PLB */
 	net->ipv4.sysctl_tcp_plb_enabled = 0; /* Disabled by default */
@@ -3666,7 +3621,6 @@
 	else
 		net->ipv4.tcp_congestion_control = &tcp_reno;
 
-	net->ipv4.sysctl_tcp_syn_linear_timeouts = 4;
 	net->ipv4.sysctl_tcp_shrink_window = 0;
 
 	net->ipv4.sysctl_tcp_pingpong_thresh = 1;
@@ -3695,7 +3649,6 @@
 	list_for_each_entry(net, net_exit_list, exit_list) {
 		inet_pernet_hashinfo_free(net->ipv4.tcp_death_row.hashinfo);
 		WARN_ON_ONCE(!refcount_dec_and_test(&net->ipv4.tcp_death_row.tw_refcount));
-		tcp_fastopen_ctx_destroy(net);
 	}
 
 	mutex_unlock(&tcp_exit_batch_mutex);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_metrics.c linux-master/net/ipv4/tcp_metrics.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_metrics.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/tcp_metrics.c	2025-10-20 00:41:14.000000000 -0300
@@ -25,14 +25,6 @@
 						   const struct inetpeer_addr *daddr,
 						   struct net *net, unsigned int hash);
 
-struct tcp_fastopen_metrics {
-	u16	mss;
-	u16	syn_loss:10,		/* Recurring Fast Open SYN losses */
-		try_exp:2;		/* Request w/ exp. option (once) */
-	unsigned long	last_syn_loss;	/* Last Fast Open SYN loss */
-	struct	tcp_fastopen_cookie	cookie;
-};
-
 /* TCP_METRIC_MAX includes 2 extra fields for userspace compatibility
  * Kernel only stores RTT and RTTVAR in usec resolution
  */
@@ -46,7 +38,6 @@
 	unsigned long			tcpm_stamp;
 	u32				tcpm_lock;
 	u32				tcpm_vals[TCP_METRIC_MAX_KERNEL + 1];
-	struct tcp_fastopen_metrics	tcpm_fastopen;
 
 	struct rcu_head			rcu_head;
 };
@@ -93,11 +84,9 @@
 static unsigned int		tcp_metrics_hash_log __read_mostly;
 
 static DEFINE_SPINLOCK(tcp_metrics_lock);
-static DEFINE_SEQLOCK(fastopen_seqlock);
 
 static void tcpm_suck_dst(struct tcp_metrics_block *tm,
-			  const struct dst_entry *dst,
-			  bool fastopen_clear)
+			  const struct dst_entry *dst)
 {
 	u32 msval;
 	u32 val;
@@ -129,15 +118,6 @@
 		       dst_metric_raw(dst, RTAX_CWND));
 	tcp_metric_set(tm, TCP_METRIC_REORDERING,
 		       dst_metric_raw(dst, RTAX_REORDERING));
-	if (fastopen_clear) {
-		write_seqlock(&fastopen_seqlock);
-		tm->tcpm_fastopen.mss = 0;
-		tm->tcpm_fastopen.syn_loss = 0;
-		tm->tcpm_fastopen.try_exp = 0;
-		tm->tcpm_fastopen.cookie.exp = false;
-		tm->tcpm_fastopen.cookie.len = 0;
-		write_sequnlock(&fastopen_seqlock);
-	}
 }
 
 #define TCP_METRICS_TIMEOUT		(60 * 60 * HZ)
@@ -151,7 +131,7 @@
 		return;
 	limit = READ_ONCE(tm->tcpm_stamp) + TCP_METRICS_TIMEOUT;
 	if (unlikely(time_after(jiffies, limit)))
-		tcpm_suck_dst(tm, dst, false);
+		tcpm_suck_dst(tm, dst);
 }
 
 #define TCP_METRICS_RECLAIM_DEPTH	5
@@ -207,7 +187,7 @@
 	tm->tcpm_saddr = *saddr;
 	tm->tcpm_daddr = *daddr;
 
-	tcpm_suck_dst(tm, dst, reclaim);
+	tcpm_suck_dst(tm, dst);
 
 	if (likely(!reclaim)) {
 		tm->tcpm_next = tcp_metrics_hash[hash].chain;
@@ -349,7 +329,7 @@
 	int m;
 
 	sk_dst_confirm(sk);
-	if (READ_ONCE(net->ipv4.sysctl_tcp_nometrics_save) || !dst)
+	if (CONFIG_SYSCTL_TCP_NOMETRICS_SAVE || !dst)
 		return;
 
 	rcu_read_lock();
@@ -405,7 +385,7 @@
 
 	if (tcp_in_initial_slowstart(tp)) {
 		/* Slow start still did not finish. */
-		if (!READ_ONCE(net->ipv4.sysctl_tcp_no_ssthresh_metrics_save) &&
+		if (!CONFIG_SYSCTL_TCP_NO_SSTHRESH_METRICS_SAVE &&
 		    !tcp_metric_locked(tm, TCP_METRIC_SSTHRESH)) {
 			val = tcp_metric_get(tm, TCP_METRIC_SSTHRESH);
 			if (val && (tcp_snd_cwnd(tp) >> 1) > val)
@@ -421,7 +401,7 @@
 	} else if (!tcp_in_slow_start(tp) &&
 		   icsk->icsk_ca_state == TCP_CA_Open) {
 		/* Cong. avoidance phase, cwnd is reliable. */
-		if (!READ_ONCE(net->ipv4.sysctl_tcp_no_ssthresh_metrics_save) &&
+		if (!CONFIG_SYSCTL_TCP_NO_SSTHRESH_METRICS_SAVE &&
 		    !tcp_metric_locked(tm, TCP_METRIC_SSTHRESH))
 			tcp_metric_set(tm, TCP_METRIC_SSTHRESH,
 				       max(tcp_snd_cwnd(tp) >> 1, tp->snd_ssthresh));
@@ -438,7 +418,7 @@
 			tcp_metric_set(tm, TCP_METRIC_CWND,
 				       (val + tp->snd_ssthresh) >> 1);
 		}
-		if (!READ_ONCE(net->ipv4.sysctl_tcp_no_ssthresh_metrics_save) &&
+		if (!CONFIG_SYSCTL_TCP_NO_SSTHRESH_METRICS_SAVE &&
 		    !tcp_metric_locked(tm, TCP_METRIC_SSTHRESH)) {
 			val = tcp_metric_get(tm, TCP_METRIC_SSTHRESH);
 			if (val && tp->snd_ssthresh > val)
@@ -449,7 +429,7 @@
 			val = tcp_metric_get(tm, TCP_METRIC_REORDERING);
 			if (val < tp->reordering &&
 			    tp->reordering !=
-			    READ_ONCE(net->ipv4.sysctl_tcp_reordering))
+			    CONFIG_SYSCTL_TCP_REORDERING)
 				tcp_metric_set(tm, TCP_METRIC_REORDERING,
 					       tp->reordering);
 		}
@@ -487,7 +467,7 @@
 	if (tcp_metric_locked(tm, TCP_METRIC_CWND))
 		tp->snd_cwnd_clamp = tcp_metric_get(tm, TCP_METRIC_CWND);
 
-	val = READ_ONCE(net->ipv4.sysctl_tcp_no_ssthresh_metrics_save) ?
+	val = CONFIG_SYSCTL_TCP_NO_SSTHRESH_METRICS_SAVE ?
 	      0 : tcp_metric_get(tm, TCP_METRIC_SSTHRESH);
 	if (val) {
 		tp->snd_ssthresh = val;
@@ -558,61 +538,6 @@
 	return ret;
 }
 
-void tcp_fastopen_cache_get(struct sock *sk, u16 *mss,
-			    struct tcp_fastopen_cookie *cookie)
-{
-	struct tcp_metrics_block *tm;
-
-	rcu_read_lock();
-	tm = tcp_get_metrics(sk, __sk_dst_get(sk), false);
-	if (tm) {
-		struct tcp_fastopen_metrics *tfom = &tm->tcpm_fastopen;
-		unsigned int seq;
-
-		do {
-			seq = read_seqbegin(&fastopen_seqlock);
-			if (tfom->mss)
-				*mss = tfom->mss;
-			*cookie = tfom->cookie;
-			if (cookie->len <= 0 && tfom->try_exp == 1)
-				cookie->exp = true;
-		} while (read_seqretry(&fastopen_seqlock, seq));
-	}
-	rcu_read_unlock();
-}
-
-void tcp_fastopen_cache_set(struct sock *sk, u16 mss,
-			    struct tcp_fastopen_cookie *cookie, bool syn_lost,
-			    u16 try_exp)
-{
-	struct dst_entry *dst = __sk_dst_get(sk);
-	struct tcp_metrics_block *tm;
-
-	if (!dst)
-		return;
-	rcu_read_lock();
-	tm = tcp_get_metrics(sk, dst, true);
-	if (tm) {
-		struct tcp_fastopen_metrics *tfom = &tm->tcpm_fastopen;
-
-		write_seqlock_bh(&fastopen_seqlock);
-		if (mss)
-			tfom->mss = mss;
-		if (cookie && cookie->len > 0)
-			tfom->cookie = *cookie;
-		else if (try_exp > tfom->try_exp &&
-			 tfom->cookie.len <= 0 && !tfom->cookie.exp)
-			tfom->try_exp = try_exp;
-		if (syn_lost) {
-			++tfom->syn_loss;
-			tfom->last_syn_loss = jiffies;
-		} else
-			tfom->syn_loss = 0;
-		write_sequnlock_bh(&fastopen_seqlock);
-	}
-	rcu_read_unlock();
-}
-
 static struct genl_family tcp_metrics_nl_family;
 
 static const struct nla_policy tcp_metrics_nl_policy[TCP_METRICS_ATTR_MAX + 1] = {
@@ -632,11 +557,6 @@
 	[TCP_METRICS_ATTR_TW_TSVAL]	= { .type = NLA_U32, },
 	[TCP_METRICS_ATTR_TW_TS_STAMP]	= { .type = NLA_S32, },
 	[TCP_METRICS_ATTR_VALS]		= { .type = NLA_NESTED, },
-	[TCP_METRICS_ATTR_FOPEN_MSS]	= { .type = NLA_U16, },
-	[TCP_METRICS_ATTR_FOPEN_SYN_DROPS]	= { .type = NLA_U16, },
-	[TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS]	= { .type = NLA_MSECS, },
-	[TCP_METRICS_ATTR_FOPEN_COOKIE]	= { .type = NLA_BINARY,
-					    .len = TCP_FASTOPEN_COOKIE_MAX, },
 #endif
 };
 
@@ -708,33 +628,6 @@
 			nla_nest_cancel(msg, nest);
 	}
 
-	{
-		struct tcp_fastopen_metrics tfom_copy[1], *tfom;
-		unsigned int seq;
-
-		do {
-			seq = read_seqbegin(&fastopen_seqlock);
-			tfom_copy[0] = tm->tcpm_fastopen;
-		} while (read_seqretry(&fastopen_seqlock, seq));
-
-		tfom = tfom_copy;
-		if (tfom->mss &&
-		    nla_put_u16(msg, TCP_METRICS_ATTR_FOPEN_MSS,
-				tfom->mss) < 0)
-			goto nla_put_failure;
-		if (tfom->syn_loss &&
-		    (nla_put_u16(msg, TCP_METRICS_ATTR_FOPEN_SYN_DROPS,
-				tfom->syn_loss) < 0 ||
-		     nla_put_msecs(msg, TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS,
-				jiffies - tfom->last_syn_loss,
-				TCP_METRICS_ATTR_PAD) < 0))
-			goto nla_put_failure;
-		if (tfom->cookie.len > 0 &&
-		    nla_put(msg, TCP_METRICS_ATTR_FOPEN_COOKIE,
-			    tfom->cookie.len, tfom->cookie.val) < 0)
-			goto nla_put_failure;
-	}
-
 	return 0;
 
 nla_put_failure:
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_minisocks.c linux-master/net/ipv4/tcp_minisocks.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_minisocks.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/tcp_minisocks.c	2025-10-20 00:41:14.000000000 -0300
@@ -118,7 +118,7 @@
 	tmp_opt.saw_tstamp = 0;
 	ts_recent_stamp = READ_ONCE(tcptw->tw_ts_recent_stamp);
 	if (th->doff > (sizeof(*th) >> 2) && ts_recent_stamp) {
-		tcp_parse_options(twsk_net(tw), skb, &tmp_opt, 0, NULL);
+		tcp_parse_options(twsk_net(tw), skb, &tmp_opt, 0);
 
 		if (tmp_opt.saw_tstamp) {
 			if (tmp_opt.rcv_tsecr)
@@ -657,8 +657,6 @@
 		newicsk->icsk_ack.last_seg_size = skb->len - newtp->tcp_header_len;
 	newtp->rx_opt.mss_clamp = req->mss;
 	tcp_ecn_openreq_child(newsk, req, skb);
-	newtp->fastopen_req = NULL;
-	RCU_INIT_POINTER(newtp->fastopen_rsk, NULL);
 
 	newtp->bpf_chg_cc_inprogress = 0;
 	tcp_bpf_clone(sk, newsk);
@@ -681,13 +679,12 @@
  *
  * We don't need to initialize tmp_opt.sack_ok as we don't use the results
  *
- * Note: If @fastopen is true, this can be called from process context.
- *       Otherwise, this is from BH context.
+ *       this is from BH context.
  */
 
 struct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,
 			   struct request_sock *req,
-			   bool fastopen, bool *req_stolen,
+			   bool *req_stolen,
 			   enum skb_drop_reason *drop_reason)
 {
 	struct tcp_options_received tmp_opt;
@@ -701,12 +698,12 @@
 	tmp_opt.saw_tstamp = 0;
 	tmp_opt.accecn = 0;
 	if (th->doff > (sizeof(struct tcphdr)>>2)) {
-		tcp_parse_options(sock_net(sk), skb, &tmp_opt, 0, NULL);
+		tcp_parse_options(sock_net(sk), skb, &tmp_opt, 0);
 
 		if (tmp_opt.saw_tstamp) {
 			tmp_opt.ts_recent = req->ts_recent;
 			if (tmp_opt.rcv_tsecr) {
-				if (inet_rsk(req)->tstamp_ok && !fastopen)
+				if (inet_rsk(req)->tstamp_ok && !0)
 					tsecr_reject = !between(tmp_opt.rcv_tsecr,
 							tcp_rsk(req)->snt_tsval_first,
 							READ_ONCE(tcp_rsk(req)->snt_tsval_last));
@@ -756,7 +753,7 @@
 			unsigned long expires = jiffies;
 
 			expires += reqsk_timeout(req, TCP_RTO_MAX);
-			if (!fastopen)
+			if (!0)
 				mod_timer_pending(&req->rsk_timer, expires);
 			else
 				req->rsk_timer.expires = expires;
@@ -821,7 +818,7 @@
 	 * elsewhere and is checked directly against the child socket rather
 	 * than req because user data may have been sent out.
 	 */
-	if ((flg & TCP_FLAG_ACK) && !fastopen &&
+	if ((flg & TCP_FLAG_ACK) && !0 &&
 	    (TCP_SKB_CB(skb)->ack_seq !=
 	     tcp_rsk(req)->snt_isn + 1))
 		return sk;
@@ -889,12 +886,6 @@
 		}
 	}
 
-	/* For Fast Open no more processing is needed (sk is the
-	 * child socket).
-	 */
-	if (fastopen)
-		return sk;
-
 	/* While TCP_DEFER_ACCEPT is active, drop bare ACK. */
 	if (req->num_timeout < READ_ONCE(inet_csk(sk)->icsk_accept_queue.rskq_defer_accept) &&
 	    TCP_SKB_CB(skb)->end_seq == tcp_rsk(req)->rcv_isn + 1) {
@@ -918,11 +909,6 @@
 	    !after(TCP_SKB_CB(skb)->seq, tcp_rsk(req)->rcv_nxt))
 		tcp_sk(child)->rx_opt.ts_recent = tmp_opt.rcv_tsval;
 
-	if (own_req && rsk_drop_req(req)) {
-		reqsk_queue_removed(&inet_csk(req->rsk_listener)->icsk_accept_queue, req);
-		inet_csk_reqsk_queue_drop_and_put(req->rsk_listener, req);
-		return child;
-	}
 
 	sock_rps_save_rxhash(child, skb);
 	tcp_synack_rtt_meas(child, req);
@@ -934,7 +920,7 @@
 	if (sk != req->rsk_listener)
 		__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMIGRATEREQFAILURE);
 
-	if (!READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_abort_on_overflow)) {
+	if (!CONFIG_SYSCTL_TCP_ABORT_ON_OVERFLOW) {
 		inet_rsk(req)->acked = 1;
 		return NULL;
 	}
@@ -947,11 +933,8 @@
 		 * resetting legit local connections.
 		 */
 		req->rsk_ops->send_reset(sk, skb, SK_RST_REASON_INVALID_SYN);
-	} else if (fastopen) { /* received a valid RST pkt */
-		reqsk_fastopen_remove(sk, req, true);
-		tcp_reset(sk, skb);
 	}
-	if (!fastopen) {
+	if (!0) {
 		bool unlinked = inet_csk_reqsk_queue_drop(sk, req);
 
 		if (unlinked)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_output.c linux-master/net/ipv4/tcp_output.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_output.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/tcp_output.c	2025-10-20 00:41:14.000000000 -0300
@@ -39,7 +39,6 @@
 
 #include <net/tcp.h>
 #include <net/tcp_ecn.h>
-#include <net/mptcp.h>
 #include <net/proto_memory.h>
 #include <net/psp.h>
 
@@ -231,7 +230,7 @@
 	 * which we interpret as a sign the remote TCP is not
 	 * misinterpreting the window field as a signed quantity.
 	 */
-	if (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_workaround_signed_windows))
+	if (CONFIG_SYSCTL_TCP_WORKAROUND_SIGNED_WINDOWS)
 		(*rcv_wnd) = min(space, MAX_TCP_WINDOW);
 	else
 		(*rcv_wnd) = space;
@@ -301,7 +300,7 @@
 	 * scaled window.
 	 */
 	if (!tp->rx_opt.rcv_wscale &&
-	    READ_ONCE(net->ipv4.sysctl_tcp_workaround_signed_windows))
+	    CONFIG_SYSCTL_TCP_WORKAROUND_SIGNED_WINDOWS)
 		new_win = min(new_win, MAX_TCP_WINDOW);
 	else
 		new_win = min(new_win, (65535U << tp->rx_opt.rcv_wscale));
@@ -384,9 +383,7 @@
 #define OPTION_TS		BIT(1)
 #define OPTION_MD5		BIT(2)
 #define OPTION_WSCALE		BIT(3)
-#define OPTION_FAST_OPEN_COOKIE	BIT(8)
 #define OPTION_SMC		BIT(9)
-#define OPTION_MPTCP		BIT(10)
 #define OPTION_AO		BIT(11)
 #define OPTION_ACCECN		BIT(12)
 
@@ -416,20 +413,8 @@
 	u8 bpf_opt_len;		/* length of BPF hdr option */
 	__u8 *hash_location;	/* temporary pointer, overloaded */
 	__u32 tsval, tsecr;	/* need to include OPTION_TS */
-	struct tcp_fastopen_cookie *fastopen_cookie;	/* Fast open cookie */
-	struct mptcp_out_options mptcp;
 };
 
-static void mptcp_options_write(struct tcphdr *th, __be32 *ptr,
-				struct tcp_sock *tp,
-				struct tcp_out_options *opts)
-{
-#if IS_ENABLED(CONFIG_MPTCP)
-	if (unlikely(OPTION_MPTCP & opts->options))
-		mptcp_write_options(th, ptr, tp, &opts->mptcp);
-#endif
-}
-
 #ifdef CONFIG_CGROUP_BPF
 static int bpf_skops_write_hdr_opt_arg0(struct sk_buff *skb,
 					enum tcp_synack_type synack_type)
@@ -773,33 +758,7 @@
 		leftover_lowbyte = TCPOPT_NOP;
 	}
 
-	if (unlikely(OPTION_FAST_OPEN_COOKIE & options)) {
-		struct tcp_fastopen_cookie *foc = opts->fastopen_cookie;
-		u8 *p = (u8 *)ptr;
-		u32 len; /* Fast Open option length */
-
-		if (foc->exp) {
-			len = TCPOLEN_EXP_FASTOPEN_BASE + foc->len;
-			*ptr = htonl((TCPOPT_EXP << 24) | (len << 16) |
-				     TCPOPT_FASTOPEN_MAGIC);
-			p += TCPOLEN_EXP_FASTOPEN_BASE;
-		} else {
-			len = TCPOLEN_FASTOPEN_BASE + foc->len;
-			*p++ = TCPOPT_FASTOPEN;
-			*p++ = len;
-		}
-
-		memcpy(p, foc->val, foc->len);
-		if ((len & 3) == 2) {
-			p[foc->len] = TCPOPT_NOP;
-			p[foc->len + 1] = TCPOPT_NOP;
-		}
-		ptr += (len + 3) >> 2;
-	}
-
 	smc_options_write(ptr, &options);
-
-	mptcp_options_write(th, ptr, tp, opts);
 }
 
 static void smc_set_option(const struct tcp_sock *tp,
@@ -835,22 +794,6 @@
 #endif
 }
 
-static void mptcp_set_option_cond(const struct request_sock *req,
-				  struct tcp_out_options *opts,
-				  unsigned int *remaining)
-{
-	if (rsk_is_mptcp(req)) {
-		unsigned int size;
-
-		if (mptcp_synack_options(req, &size, &opts->mptcp)) {
-			if (*remaining >= size) {
-				opts->options |= OPTION_MPTCP;
-				*remaining -= size;
-			}
-		}
-	}
-}
-
 static u32 tcp_synack_options_combine_saving(struct tcp_out_options *opts)
 {
 	/* How much there's room for combining with the alignment padding? */
@@ -934,7 +877,6 @@
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 	unsigned int remaining = MAX_TCP_OPTION_SPACE;
-	struct tcp_fastopen_request *fastopen = tp->fastopen_req;
 	bool timestamps;
 
 	/* Better than switch (key.type) as it has static branches */
@@ -943,7 +885,7 @@
 		opts->options |= OPTION_MD5;
 		remaining -= TCPOLEN_MD5SIG_ALIGNED;
 	} else {
-		timestamps = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_timestamps);
+		timestamps = CONFIG_SYSCTL_TCP_TIMESTAMPS;
 		if (tcp_key_is_ao(key)) {
 			opts->options |= OPTION_AO;
 			remaining -= tcp_ao_len_aligned(key->ao_key);
@@ -979,33 +921,9 @@
 			remaining -= TCPOLEN_SACKPERM_ALIGNED;
 	}
 
-	if (fastopen && fastopen->cookie.len >= 0) {
-		u32 need = fastopen->cookie.len;
-
-		need += fastopen->cookie.exp ? TCPOLEN_EXP_FASTOPEN_BASE :
-					       TCPOLEN_FASTOPEN_BASE;
-		need = (need + 3) & ~3U;  /* Align to 32 bits */
-		if (remaining >= need) {
-			opts->options |= OPTION_FAST_OPEN_COOKIE;
-			opts->fastopen_cookie = &fastopen->cookie;
-			remaining -= need;
-			tp->syn_fastopen = 1;
-			tp->syn_fastopen_exp = fastopen->cookie.exp ? 1 : 0;
-		}
-	}
 
 	smc_set_option(tp, opts, &remaining);
 
-	if (sk_is_mptcp(sk)) {
-		unsigned int size;
-
-		if (mptcp_syn_options(sk, skb, &size, &opts->mptcp)) {
-			if (remaining >= size) {
-				opts->options |= OPTION_MPTCP;
-				remaining -= size;
-			}
-		}
-	}
 
 	/* Simultaneous open SYN/ACK needs AccECN option but not SYN.
 	 * It is attempted to negotiate the use of AccECN also on the first
@@ -1032,7 +950,6 @@
 				       unsigned int mss, struct sk_buff *skb,
 				       struct tcp_out_options *opts,
 				       const struct tcp_key *key,
-				       struct tcp_fastopen_cookie *foc,
 				       enum tcp_synack_type synack_type,
 				       struct sk_buff *syn_skb)
 {
@@ -1084,20 +1001,6 @@
 		if (unlikely(!ireq->tstamp_ok))
 			remaining -= TCPOLEN_SACKPERM_ALIGNED;
 	}
-	if (foc != NULL && foc->len >= 0) {
-		u32 need = foc->len;
-
-		need += foc->exp ? TCPOLEN_EXP_FASTOPEN_BASE :
-				   TCPOLEN_FASTOPEN_BASE;
-		need = (need + 3) & ~3U;  /* Align to 32 bits */
-		if (remaining >= need) {
-			opts->options |= OPTION_FAST_OPEN_COOKIE;
-			opts->fastopen_cookie = foc;
-			remaining -= need;
-		}
-	}
-
-	mptcp_set_option_cond(req, opts, &remaining);
 
 	smc_set_option_cond(tcp_sk(sk), ireq, opts, &remaining);
 
@@ -1144,23 +1047,6 @@
 		size += TCPOLEN_TSTAMP_ALIGNED;
 	}
 
-	/* MPTCP options have precedence over SACK for the limited TCP
-	 * option space because a MPTCP connection would be forced to
-	 * fall back to regular TCP if a required multipath option is
-	 * missing. SACK still gets a chance to use whatever space is
-	 * left.
-	 */
-	if (sk_is_mptcp(sk)) {
-		unsigned int remaining = MAX_TCP_OPTION_SPACE - size;
-		unsigned int opt_size = 0;
-
-		if (mptcp_established_options(sk, skb, &opt_size, remaining,
-					      &opts->mptcp)) {
-			opts->options |= OPTION_MPTCP;
-			size += opt_size;
-		}
-	}
-
 	eff_sacks = tp->rx_opt.num_sacks + tp->rx_opt.dsack;
 	if (unlikely(eff_sacks)) {
 		const unsigned int remaining = MAX_TCP_OPTION_SPACE - size;
@@ -1791,7 +1677,6 @@
 	if (!buff)
 		return -ENOMEM; /* We'll just try again later. */
 	skb_copy_decrypted(buff, skb);
-	mptcp_skb_ext_copy(buff, skb);
 
 	sk_wmem_queued_add(sk, buff->truesize);
 	sk_mem_charge(sk, buff->truesize);
@@ -2194,7 +2079,7 @@
 
 	min_tso = ca_ops->min_tso_segs ?
 			ca_ops->min_tso_segs(sk) :
-			READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_min_tso_segs);
+			CONFIG_SYSCTL_TCP_MIN_TSO_SEGS;
 
 	tso_segs = tcp_tso_autosize(sk, mss_now, min_tso);
 	return min_t(u32, tso_segs, sk->sk_gso_max_segs);
@@ -2325,7 +2210,6 @@
 	if (unlikely(!buff))
 		return -ENOMEM;
 	skb_copy_decrypted(buff, skb);
-	mptcp_skb_ext_copy(buff, skb);
 
 	sk_wmem_queued_add(sk, buff->truesize);
 	sk_mem_charge(sk, buff->truesize);
@@ -2484,7 +2368,7 @@
 	u32 interval;
 	s32 delta;
 
-	interval = READ_ONCE(net->ipv4.sysctl_tcp_probe_interval);
+	interval = CONFIG_SYSCTL_TCP_PROBE_INTERVAL;
 	delta = tcp_jiffies32 - icsk->icsk_mtup.probe_timestamp;
 	if (unlikely(delta >= interval * HZ)) {
 		int mss = tcp_current_mss(sk);
@@ -2632,7 +2516,7 @@
 	 * probing process by not resetting search range to its orignal.
 	 */
 	if (probe_size > tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_high) ||
-	    interval < READ_ONCE(net->ipv4.sysctl_tcp_probe_threshold)) {
+	    interval < CONFIG_SYSCTL_TCP_PROBE_THRESHOLD) {
 		/* Check whether enough time has elaplased for
 		 * another round of probing.
 		 */
@@ -2676,7 +2560,6 @@
 
 	skb = tcp_send_head(sk);
 	skb_copy_decrypted(nskb, skb);
-	mptcp_skb_ext_copy(nskb, skb);
 
 	TCP_SKB_CB(nskb)->seq = TCP_SKB_CB(skb)->seq;
 	TCP_SKB_CB(nskb)->end_seq = TCP_SKB_CB(skb)->seq + probe_size;
@@ -3040,12 +2923,6 @@
 	u32 timeout, timeout_us, rto_delta_us;
 	int early_retrans;
 
-	/* Don't do any loss probe on a Fast Open connection before 3WHS
-	 * finishes.
-	 */
-	if (rcu_access_pointer(tp->fastopen_rsk))
-		return false;
-
 	early_retrans = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_early_retrans);
 	/* Schedule a loss probe in 2*RTT for SACK capable connections
 	 * not in loss recovery, that are either limited by cwnd or application.
@@ -3264,9 +3141,6 @@
 	int allowed_space = tcp_full_space(sk);
 	int full_space, window;
 
-	if (sk_is_mptcp(sk))
-		mptcp_space(sk, &free_space, &allowed_space);
-
 	full_space = min_t(int, tp->window_clamp, allowed_space);
 
 	if (unlikely(mss > full_space)) {
@@ -3450,7 +3324,7 @@
 	struct sk_buff *skb = to, *tmp;
 	bool first = true;
 
-	if (!READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_retrans_collapse))
+	if (!CONFIG_SYSCTL_TCP_RETRANS_COLLAPSE)
 		return;
 	if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN)
 		return;
@@ -3880,13 +3754,11 @@
  * @dst: dst entry attached to the SYNACK. It is consumed and caller
  *       should not use it again.
  * @req: request_sock pointer
- * @foc: cookie for tcp fast open
  * @synack_type: Type of synack to prepare
  * @syn_skb: SYN packet just received.  It could be NULL for rtx case.
  */
 struct sk_buff *tcp_make_synack(const struct sock *sk, struct dst_entry *dst,
 				struct request_sock *req,
-				struct tcp_fastopen_cookie *foc,
 				enum tcp_synack_type synack_type,
 				struct sk_buff *syn_skb)
 {
@@ -3917,13 +3789,8 @@
 		 * to avoid false sharing.
 		 */
 		break;
-	case TCP_SYNACK_FASTOPEN:
-		/* sk is a const pointer, because we want to express multiple
-		 * cpu might call us concurrently.
-		 * sk->sk_wmem_alloc in an atomic, we can promote to rw.
-		 */
-		skb_set_owner_w(skb, (struct sock *)sk);
-		break;
+    case __NOTFO_TCP_SYNACK_FASTOPEN:
+        break;
 	}
 	skb_dst_set(skb, dst);
 
@@ -3982,7 +3849,7 @@
 	/* bpf program will be interested in the tcp_flags */
 	TCP_SKB_CB(skb)->tcp_flags = TCPHDR_SYN | TCPHDR_ACK;
 	tcp_header_size = tcp_synack_options(sk, req, mss, skb, &opts,
-					     &key, foc, synack_type, syn_skb)
+					     &key, synack_type, syn_skb)
 					+ sizeof(*th);
 
 	skb_push(skb, tcp_header_size);
@@ -4066,7 +3933,7 @@
 	 * See tcp_input.c:tcp_rcv_state_process case TCP_SYN_SENT.
 	 */
 	tp->tcp_header_len = sizeof(struct tcphdr);
-	if (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_timestamps))
+	if (CONFIG_SYSCTL_TCP_TIMESTAMPS)
 		tp->tcp_header_len += TCPOLEN_TSTAMP_ALIGNED;
 
 	tcp_ao_connect_init(sk);
@@ -4142,109 +4009,6 @@
 	tp->packets_out += tcp_skb_pcount(skb);
 }
 
-/* Build and send a SYN with data and (cached) Fast Open cookie. However,
- * queue a data-only packet after the regular SYN, such that regular SYNs
- * are retransmitted on timeouts. Also if the remote SYN-ACK acknowledges
- * only the SYN sequence, the data are retransmitted in the first ACK.
- * If cookie is not cached or other error occurs, falls back to send a
- * regular SYN with Fast Open cookie request option.
- */
-static int tcp_send_syn_data(struct sock *sk, struct sk_buff *syn)
-{
-	struct inet_connection_sock *icsk = inet_csk(sk);
-	struct tcp_sock *tp = tcp_sk(sk);
-	struct tcp_fastopen_request *fo = tp->fastopen_req;
-	struct page_frag *pfrag = sk_page_frag(sk);
-	struct sk_buff *syn_data;
-	int space, err = 0;
-
-	tp->rx_opt.mss_clamp = tp->advmss;  /* If MSS is not cached */
-	if (!tcp_fastopen_cookie_check(sk, &tp->rx_opt.mss_clamp, &fo->cookie))
-		goto fallback;
-
-	/* MSS for SYN-data is based on cached MSS and bounded by PMTU and
-	 * user-MSS. Reserve maximum option space for middleboxes that add
-	 * private TCP options. The cost is reduced data space in SYN :(
-	 */
-	tp->rx_opt.mss_clamp = tcp_mss_clamp(tp, tp->rx_opt.mss_clamp);
-	/* Sync mss_cache after updating the mss_clamp */
-	tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
-
-	space = __tcp_mtu_to_mss(sk, icsk->icsk_pmtu_cookie) -
-		MAX_TCP_OPTION_SPACE;
-
-	space = min_t(size_t, space, fo->size);
-
-	if (space &&
-	    !skb_page_frag_refill(min_t(size_t, space, PAGE_SIZE),
-				  pfrag, sk->sk_allocation))
-		goto fallback;
-	syn_data = tcp_stream_alloc_skb(sk, sk->sk_allocation, false);
-	if (!syn_data)
-		goto fallback;
-	memcpy(syn_data->cb, syn->cb, sizeof(syn->cb));
-	if (space) {
-		space = min_t(size_t, space, pfrag->size - pfrag->offset);
-		space = tcp_wmem_schedule(sk, space);
-	}
-	if (space) {
-		space = copy_page_from_iter(pfrag->page, pfrag->offset,
-					    space, &fo->data->msg_iter);
-		if (unlikely(!space)) {
-			tcp_skb_tsorted_anchor_cleanup(syn_data);
-			kfree_skb(syn_data);
-			goto fallback;
-		}
-		skb_fill_page_desc(syn_data, 0, pfrag->page,
-				   pfrag->offset, space);
-		page_ref_inc(pfrag->page);
-		pfrag->offset += space;
-		skb_len_add(syn_data, space);
-		skb_zcopy_set(syn_data, fo->uarg, NULL);
-	}
-	/* No more data pending in inet_wait_for_connect() */
-	if (space == fo->size)
-		fo->data = NULL;
-	fo->copied = space;
-
-	tcp_connect_queue_skb(sk, syn_data);
-	if (syn_data->len)
-		tcp_chrono_start(sk, TCP_CHRONO_BUSY);
-
-	err = tcp_transmit_skb(sk, syn_data, 1, sk->sk_allocation);
-
-	skb_set_delivery_time(syn, syn_data->skb_mstamp_ns, SKB_CLOCK_MONOTONIC);
-
-	/* Now full SYN+DATA was cloned and sent (or not),
-	 * remove the SYN from the original skb (syn_data)
-	 * we keep in write queue in case of a retransmit, as we
-	 * also have the SYN packet (with no data) in the same queue.
-	 */
-	TCP_SKB_CB(syn_data)->seq++;
-	TCP_SKB_CB(syn_data)->tcp_flags = TCPHDR_ACK | TCPHDR_PSH;
-	if (!err) {
-		tp->syn_data = (fo->copied > 0);
-		tcp_rbtree_insert(&sk->tcp_rtx_queue, syn_data);
-		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPORIGDATASENT);
-		goto done;
-	}
-
-	/* data was not sent, put it in write_queue */
-	__skb_queue_tail(&sk->sk_write_queue, syn_data);
-	tp->packets_out -= tcp_skb_pcount(syn_data);
-
-fallback:
-	/* Send a regular SYN with Fast Open cookie request option */
-	if (fo->cookie.len > 0)
-		fo->cookie.len = 0;
-	err = tcp_transmit_skb(sk, syn, 1, sk->sk_allocation);
-	if (err)
-		tp->syn_fastopen = 0;
-done:
-	fo->cookie.len = -1;  /* Exclude Fast Open option for SYN retries */
-	return err;
-}
-
 /* Build a SYN and send it off. */
 int tcp_connect(struct sock *sk)
 {
@@ -4326,7 +4090,7 @@
 	tcp_rbtree_insert(&sk->tcp_rtx_queue, buff);
 
 	/* Send off SYN; include data in Fast Open. */
-	err = tp->fastopen_req ? tcp_send_syn_data(sk, buff) :
+	err = 
 	      tcp_transmit_skb(sk, buff, 1, sk->sk_allocation);
 	if (err == -ECONNREFUSED)
 		return err;
@@ -4572,7 +4336,7 @@
 
 	WRITE_ONCE(icsk->icsk_probes_out, icsk->icsk_probes_out + 1);
 	if (err <= 0) {
-		if (icsk->icsk_backoff < READ_ONCE(net->ipv4.sysctl_tcp_retries2))
+		if (icsk->icsk_backoff < CONFIG_SYSCTL_TCP_RETRIES2)
 			icsk->icsk_backoff++;
 		timeout = tcp_probe0_when(sk, tcp_rto_max(sk));
 	} else {
@@ -4595,18 +4359,11 @@
 	/* Paired with WRITE_ONCE() in sock_setsockopt() */
 	if (READ_ONCE(sk->sk_txrehash) == SOCK_TXREHASH_ENABLED)
 		WRITE_ONCE(tcp_rsk(req)->txhash, net_tx_rndhash());
-	res = af_ops->send_synack(sk, NULL, &fl, req, NULL, TCP_SYNACK_NORMAL,
+	res = af_ops->send_synack(sk, NULL, &fl, req, TCP_SYNACK_NORMAL,
 				  NULL);
 	if (!res) {
 		TCP_INC_STATS(sock_net(sk), TCP_MIB_RETRANSSEGS);
 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSYNRETRANS);
-		if (unlikely(tcp_passive_fastopen(sk))) {
-			/* sk has const attribute because listeners are lockless.
-			 * However in this case, we are dealing with a passive fastopen
-			 * socket thus we can change total_retrans value.
-			 */
-			tcp_sk_rw(sk)->total_retrans++;
-		}
 		trace_tcp_retransmit_synack(sk, req);
 		WRITE_ONCE(req->num_retrans, req->num_retrans + 1);
 	}
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_timer.c linux-master/net/ipv4/tcp_timer.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/tcp_timer.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/tcp_timer.c	2025-10-20 00:41:14.000000000 -0300
@@ -24,6 +24,9 @@
 #include <net/tcp.h>
 #include <net/rstreason.h>
 
+#if 1 // TODO: REMOVE struct inet_connection_sock icsk_user_timeout
+#define tcp_clamp_rto_to_user_timeout(sk) icsk->icsk_rto
+#else
 static u32 tcp_clamp_rto_to_user_timeout(const struct sock *sk)
 {
 	const struct inet_connection_sock *icsk = inet_csk(sk);
@@ -64,6 +67,7 @@
 
 	return min_t(u32, remaining, when);
 }
+#endif
 
 /**
  *  tcp_write_err() - close socket and save error info
@@ -147,7 +151,7 @@
  */
 static int tcp_orphan_retries(struct sock *sk, bool alive)
 {
-	int retries = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_orphan_retries); /* May be zero. */
+	int retries = CONFIG_SYSCTL_TCP_ORPHAN_RETRIES; /* May be zero. */
 
 	/* We know from an ICMP that something is wrong. */
 	if (READ_ONCE(sk->sk_err_soft) && !alive)
@@ -251,22 +255,22 @@
 			__dst_negative_advice(sk);
 		/* Paired with WRITE_ONCE() in tcp_sock_set_syncnt() */
 		retry_until = READ_ONCE(icsk->icsk_syn_retries) ? :
-			READ_ONCE(net->ipv4.sysctl_tcp_syn_retries);
+			CONFIG_SYSCTL_TCP_SYN_RETRIES;
 
 		max_retransmits = retry_until;
 		if (sk->sk_state == TCP_SYN_SENT)
-			max_retransmits += READ_ONCE(net->ipv4.sysctl_tcp_syn_linear_timeouts);
+			max_retransmits += CONFIG_SYSCTL_TCP_SYN_LINEAR_TIMEOUTS;
 
 		expired = icsk->icsk_retransmits >= max_retransmits;
 	} else {
-		if (retransmits_timed_out(sk, READ_ONCE(net->ipv4.sysctl_tcp_retries1), 0)) {
+		if (retransmits_timed_out(sk, CONFIG_SYSCTL_TCP_RETRIES1, 0)) {
 			/* Black hole detection */
 			tcp_mtu_probing(icsk, sk);
 
 			__dst_negative_advice(sk);
 		}
 
-		retry_until = READ_ONCE(net->ipv4.sysctl_tcp_retries2);
+		retry_until = CONFIG_SYSCTL_TCP_RETRIES2;
 		if (sock_flag(sk, SOCK_DEAD)) {
 			const bool alive = icsk->icsk_rto < tcp_rto_max(sk);
 
@@ -281,8 +285,6 @@
 	if (!expired)
 		expired = retransmits_timed_out(sk, retry_until,
 						READ_ONCE(icsk->icsk_user_timeout));
-	tcp_fastopen_active_detect_blackhole(sk, expired);
-	mptcp_active_detect_blackhole(sk, expired);
 
 	if (BPF_SOCK_OPS_TEST_FLAG(tp, BPF_SOCK_OPS_RTO_CB_FLAG))
 		tcp_call_bpf_3arg(sk, BPF_SOCK_OPS_RTO_CB,
@@ -415,7 +417,7 @@
 		     msecs_to_jiffies(user_timeout))
 			goto abort;
 	}
-	max_probes = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_retries2);
+	max_probes = CONFIG_SYSCTL_TCP_RETRIES2;
 	if (sock_flag(sk, SOCK_DEAD)) {
 		unsigned int rto_max = tcp_rto_max(sk);
 		const bool alive = inet_csk_rto_backoff(icsk, rto_max) < rto_max;
@@ -448,45 +450,6 @@
 	tp->total_rto++;
 }
 
-/*
- *	Timer for Fast Open socket to retransmit SYNACK. Note that the
- *	sk here is the child socket, not the parent (listener) socket.
- */
-static void tcp_fastopen_synack_timer(struct sock *sk, struct request_sock *req)
-{
-	struct inet_connection_sock *icsk = inet_csk(sk);
-	struct tcp_sock *tp = tcp_sk(sk);
-	int max_retries;
-
-	req->rsk_ops->syn_ack_timeout(req);
-
-	/* Add one more retry for fastopen.
-	 * Paired with WRITE_ONCE() in tcp_sock_set_syncnt()
-	 */
-	max_retries = READ_ONCE(icsk->icsk_syn_retries) ? :
-		READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_synack_retries) + 1;
-
-	if (req->num_timeout >= max_retries) {
-		tcp_write_err(sk);
-		return;
-	}
-	/* Lower cwnd after certain SYNACK timeout like tcp_init_transfer() */
-	if (icsk->icsk_retransmits == 1)
-		tcp_enter_loss(sk);
-	/* XXX (TFO) - Unlike regular SYN-ACK retransmit, we ignore error
-	 * returned from rtx_syn_ack() to make it more persistent like
-	 * regular retransmit because if the child socket has been accepted
-	 * it's not good to give up too easily.
-	 */
-	tcp_rtx_synack(sk, req);
-	req->num_timeout++;
-	tcp_update_rto_stats(sk);
-	if (!tp->retrans_stamp)
-		tp->retrans_stamp = tcp_time_stamp_ts(tp);
-	tcp_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
-			  req->timeout << req->num_timeout, false);
-}
-
 static bool tcp_rtx_probe0_timed_out(const struct sock *sk,
 				     const struct sk_buff *skb,
 				     u32 rtx_delta)
@@ -536,17 +499,7 @@
 	struct request_sock *req;
 	struct sk_buff *skb;
 
-	req = rcu_dereference_protected(tp->fastopen_rsk,
-					lockdep_sock_is_held(sk));
-	if (req) {
-		WARN_ON_ONCE(sk->sk_state != TCP_SYN_RECV &&
-			     sk->sk_state != TCP_FIN_WAIT1);
-		tcp_fastopen_synack_timer(sk, req);
-		/* Before we receive ACK to our SYN-ACK don't retransmit
-		 * anything else (e.g., data or FIN segments).
-		 */
-		return;
-	}
+	req = NULL;
 
 	if (!tp->packets_out)
 		return;
@@ -670,7 +623,7 @@
 				       tcp_rto_max(sk));
 	} else if (sk->sk_state != TCP_SYN_SENT ||
 		   tp->total_rto >
-		   READ_ONCE(net->ipv4.sysctl_tcp_syn_linear_timeouts)) {
+		   CONFIG_SYSCTL_TCP_SYN_LINEAR_TIMEOUTS) {
 		/* Use normal (exponential) backoff unless linear timeouts are
 		 * activated.
 		 */
@@ -679,7 +632,7 @@
 	}
 	tcp_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
 			     tcp_clamp_rto_to_user_timeout(sk), false);
-	if (retransmits_timed_out(sk, READ_ONCE(net->ipv4.sysctl_tcp_retries1) + 1, 0))
+	if (retransmits_timed_out(sk, CONFIG_SYSCTL_TCP_RETRIES1 + 1, 0))
 		__sk_dst_reset(sk);
 
 out:;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/udp.c linux-master/net/ipv4/udp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/udp.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/udp.c	2025-10-20 00:41:14.000000000 -0300
@@ -229,7 +229,7 @@
 }
 
 /**
- *  udp_lib_get_port  -  UDP/-Lite port lookup for IPv4 and IPv6
+ *  udp_lib_get_port  -  UDP port lookup for IPv4 and IPv6
  *
  *  @sk:          socket struct in question
  *  @snum:        port number to look up
@@ -1121,7 +1121,6 @@
 	struct inet_sock *inet = inet_sk(sk);
 	struct udphdr *uh;
 	int err;
-	int is_udplite = IS_UDPLITE(sk);
 	int offset = skb_transport_offset(skb);
 	int len = skb->len - offset;
 	int datalen = len - sizeof(*uh);
@@ -1148,11 +1147,11 @@
 			kfree_skb(skb);
 			return -EINVAL;
 		}
-		if (sk->sk_no_check_tx) {
+		if (1) {
 			kfree_skb(skb);
 			return -EINVAL;
 		}
-		if (is_udplite || dst_xfrm(skb_dst(skb))) {
+		if (dst_xfrm(skb_dst(skb))) {
 			kfree_skb(skb);
 			return -EIO;
 		}
@@ -1168,10 +1167,8 @@
 		}
 	}
 
-	if (is_udplite)  				 /*     UDP-Lite      */
-		csum = udplite_csum(skb);
 
-	else if (sk->sk_no_check_tx) {			 /* UDP csum off */
+	else if (1) {			 /* UDP csum off */
 
 		skb->ip_summed = CHECKSUM_NONE;
 		goto send;
@@ -1197,12 +1194,12 @@
 		if (err == -ENOBUFS &&
 		    !inet_test_bit(RECVERR, sk)) {
 			UDP_INC_STATS(sock_net(sk),
-				      UDP_MIB_SNDBUFERRORS, is_udplite);
+				      UDP_MIB_SNDBUFERRORS);
 			err = 0;
 		}
 	} else
 		UDP_INC_STATS(sock_net(sk),
-			      UDP_MIB_OUTDATAGRAMS, is_udplite);
+			      UDP_MIB_OUTDATAGRAMS);
 	return err;
 }
 
@@ -1282,7 +1279,7 @@
 	__be32 daddr, faddr, saddr;
 	u8 scope;
 	__be16 dport;
-	int err, is_udplite = IS_UDPLITE(sk);
+	int err;
 	int corkreq = udp_test_bit(CORK, sk) || msg->msg_flags & MSG_MORE;
 	int (*getfrag)(void *, char *, int, int, int, struct sk_buff *);
 	struct sk_buff *skb;
@@ -1299,7 +1296,7 @@
 	if (msg->msg_flags & MSG_OOB) /* Mirror BSD error message compatibility */
 		return -EOPNOTSUPP;
 
-	getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag;
+	getfrag = ip_generic_getfrag;
 
 	fl4 = &inet->cork.fl.u.ip4;
 	if (READ_ONCE(up->pending)) {
@@ -1534,7 +1531,7 @@
 	 */
 	if (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {
 		UDP_INC_STATS(sock_net(sk),
-			      UDP_MIB_SNDBUFERRORS, is_udplite);
+			      UDP_MIB_SNDBUFERRORS);
 	}
 	return err;
 
@@ -1875,10 +1872,8 @@
 
 	while ((skb = skb_peek(rcvq)) != NULL) {
 		if (udp_lib_checksum_complete(skb)) {
-			__UDP_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS,
-					IS_UDPLITE(sk));
-			__UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS,
-					IS_UDPLITE(sk));
+			__UDP_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS);
+			__UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS);
 			udp_drops_inc(sk);
 			__skb_unlink(skb, rcvq);
 			*total += skb->truesize;
@@ -2030,11 +2025,10 @@
 		return err;
 
 	if (udp_lib_checksum_complete(skb)) {
-		int is_udplite = IS_UDPLITE(sk);
 		struct net *net = sock_net(sk);
 
-		__UDP_INC_STATS(net, UDP_MIB_CSUMERRORS, is_udplite);
-		__UDP_INC_STATS(net, UDP_MIB_INERRORS, is_udplite);
+		__UDP_INC_STATS(net, UDP_MIB_CSUMERRORS);
+		__UDP_INC_STATS(net, UDP_MIB_INERRORS);
 		udp_drops_inc(sk);
 		kfree_skb_reason(skb, SKB_DROP_REASON_UDP_CSUM);
 		goto try_again;
@@ -2058,7 +2052,6 @@
 	struct sk_buff *skb;
 	unsigned int ulen, copied;
 	int off, err, peeking = flags & MSG_PEEK;
-	int is_udplite = IS_UDPLITE(sk);
 	bool checksum_valid = false;
 
 	if (flags & MSG_ERRQUEUE)
@@ -2084,7 +2077,7 @@
 	 */
 
 	if (copied < ulen || peeking ||
-	    (is_udplite && UDP_SKB_CB(skb)->partial_cov)) {
+	    (0 && 0)) {
 		checksum_valid = udp_skb_csum_unnecessary(skb) ||
 				!__udp_lib_checksum_complete(skb);
 		if (!checksum_valid)
@@ -2107,7 +2100,7 @@
 		if (!peeking) {
 			udp_drops_inc(sk);
 			UDP_INC_STATS(sock_net(sk),
-				      UDP_MIB_INERRORS, is_udplite);
+				      UDP_MIB_INERRORS);
 		}
 		kfree_skb(skb);
 		return err;
@@ -2115,7 +2108,7 @@
 
 	if (!peeking)
 		UDP_INC_STATS(sock_net(sk),
-			      UDP_MIB_INDATAGRAMS, is_udplite);
+			      UDP_MIB_INDATAGRAMS);
 
 	sock_recv_cmsgs(msg, sk, skb);
 
@@ -2148,8 +2141,8 @@
 csum_copy_err:
 	if (!__sk_queue_drop_skb(sk, &udp_sk(sk)->reader_queue, skb, flags,
 				 udp_skb_destructor)) {
-		UDP_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);
-		UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
+		UDP_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS);
+		UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS);
 	}
 	kfree_skb_reason(skb, SKB_DROP_REASON_UDP_CSUM);
 
@@ -2342,20 +2335,17 @@
 
 	rc = __udp_enqueue_schedule_skb(sk, skb);
 	if (rc < 0) {
-		int is_udplite = IS_UDPLITE(sk);
 		int drop_reason;
 
 		/* Note that an ENOMEM error is charged twice */
 		if (rc == -ENOMEM) {
-			UDP_INC_STATS(sock_net(sk), UDP_MIB_RCVBUFERRORS,
-					is_udplite);
+			UDP_INC_STATS(sock_net(sk), UDP_MIB_RCVBUFERRORS);
 			drop_reason = SKB_DROP_REASON_SOCKET_RCVBUFF;
 		} else {
-			UDP_INC_STATS(sock_net(sk), UDP_MIB_MEMERRORS,
-				      is_udplite);
+			UDP_INC_STATS(sock_net(sk), UDP_MIB_MEMERRORS);
 			drop_reason = SKB_DROP_REASON_PROTO_MEM;
 		}
-		UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
+		UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS);
 		trace_udp_fail_queue_rcv_skb(rc, sk, skb);
 		sk_skb_reason_drop(sk, skb, drop_reason);
 		return -1;
@@ -2376,7 +2366,6 @@
 {
 	enum skb_drop_reason drop_reason = SKB_DROP_REASON_NOT_SPECIFIED;
 	struct udp_sock *up = udp_sk(sk);
-	int is_udplite = IS_UDPLITE(sk);
 
 	/*
 	 *	Charge it to the socket, dropping if the queue is full.
@@ -2414,8 +2403,7 @@
 			ret = encap_rcv(sk, skb);
 			if (ret <= 0) {
 				__UDP_INC_STATS(sock_net(sk),
-						UDP_MIB_INDATAGRAMS,
-						is_udplite);
+						UDP_MIB_INDATAGRAMS);
 				return -ret;
 			}
 		}
@@ -2423,40 +2411,6 @@
 		/* FALLTHROUGH -- it's a UDP Packet */
 	}
 
-	/*
-	 * 	UDP-Lite specific tests, ignored on UDP sockets
-	 */
-	if (udp_test_bit(UDPLITE_RECV_CC, sk) && UDP_SKB_CB(skb)->partial_cov) {
-		u16 pcrlen = READ_ONCE(up->pcrlen);
-
-		/*
-		 * MIB statistics other than incrementing the error count are
-		 * disabled for the following two types of errors: these depend
-		 * on the application settings, not on the functioning of the
-		 * protocol stack as such.
-		 *
-		 * RFC 3828 here recommends (sec 3.3): "There should also be a
-		 * way ... to ... at least let the receiving application block
-		 * delivery of packets with coverage values less than a value
-		 * provided by the application."
-		 */
-		if (pcrlen == 0) {          /* full coverage was set  */
-			net_dbg_ratelimited("UDPLite: partial coverage %d while full coverage %d requested\n",
-					    UDP_SKB_CB(skb)->cscov, skb->len);
-			goto drop;
-		}
-		/* The next case involves violating the min. coverage requested
-		 * by the receiver. This is subtle: if receiver wants x and x is
-		 * greater than the buffersize/MTU then receiver will complain
-		 * that it wants x while sender emits packets of smaller size y.
-		 * Therefore the above ...()->partial_cov statement is essential.
-		 */
-		if (UDP_SKB_CB(skb)->cscov < pcrlen) {
-			net_dbg_ratelimited("UDPLite: coverage %d too small, need min %d\n",
-					    UDP_SKB_CB(skb)->cscov, pcrlen);
-			goto drop;
-		}
-	}
 
 	prefetch(&sk->sk_rmem_alloc);
 	if (rcu_access_pointer(sk->sk_filter) &&
@@ -2473,9 +2427,9 @@
 
 csum_error:
 	drop_reason = SKB_DROP_REASON_UDP_CSUM;
-	__UDP_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);
+	__UDP_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS);
 drop:
-	__UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
+	__UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS);
 	udp_drops_inc(sk);
 	sk_skb_reason_drop(sk, skb, drop_reason);
 	return -1;
@@ -2562,10 +2516,8 @@
 
 		if (unlikely(!nskb)) {
 			udp_drops_inc(sk);
-			__UDP_INC_STATS(net, UDP_MIB_RCVBUFERRORS,
-					IS_UDPLITE(sk));
-			__UDP_INC_STATS(net, UDP_MIB_INERRORS,
-					IS_UDPLITE(sk));
+			__UDP_INC_STATS(net, UDP_MIB_RCVBUFERRORS);
+			__UDP_INC_STATS(net, UDP_MIB_INERRORS);
 			continue;
 		}
 		if (udp_queue_rcv_skb(sk, nskb) > 0)
@@ -2583,8 +2535,7 @@
 			consume_skb(skb);
 	} else {
 		kfree_skb(skb);
-		__UDP_INC_STATS(net, UDP_MIB_IGNOREDMULTI,
-				proto == IPPROTO_UDPLITE);
+		__UDP_INC_STATS(net, UDP_MIB_IGNOREDMULTI);
 	}
 	return 0;
 }
@@ -2599,19 +2550,8 @@
 {
 	int err;
 
-	UDP_SKB_CB(skb)->partial_cov = 0;
 	UDP_SKB_CB(skb)->cscov = skb->len;
 
-	if (proto == IPPROTO_UDPLITE) {
-		err = udplite_checksum_init(skb, uh);
-		if (err)
-			return err;
-
-		if (UDP_SKB_CB(skb)->partial_cov) {
-			skb->csum = inet_compute_pseudo(skb, proto);
-			return 0;
-		}
-	}
 
 	/* Note, we are only interested in != 0 or == 0, thus the
 	 * force to int.
@@ -2644,7 +2584,7 @@
 {
 	int ret;
 
-	if (inet_get_convert_csum(sk) && uh->check && !IS_UDPLITE(sk))
+	if (inet_get_convert_csum(sk) && uh->check && !0)
 		skb_checksum_try_convert(skb, IPPROTO_UDP, inet_compute_pseudo);
 
 	ret = udp_queue_rcv_skb(sk, skb);
@@ -2734,7 +2674,7 @@
 		goto csum_error;
 
 	drop_reason = SKB_DROP_REASON_NO_SOCKET;
-	__UDP_INC_STATS(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);
+	__UDP_INC_STATS(net, UDP_MIB_NOPORTS);
 	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);
 
 	/*
@@ -2747,7 +2687,7 @@
 short_packet:
 	drop_reason = SKB_DROP_REASON_PKT_TOO_SMALL;
 	net_dbg_ratelimited("UDP%s: short packet: From %pI4:%u %d/%d to %pI4:%u\n",
-			    proto == IPPROTO_UDPLITE ? "Lite" : "",
+			    "",
 			    &saddr, ntohs(uh->source),
 			    ulen, skb->len,
 			    &daddr, ntohs(uh->dest));
@@ -2759,13 +2699,12 @@
 	 * the network is concerned, anyway) as per 4.1.3.4 (MUST).
 	 */
 	drop_reason = SKB_DROP_REASON_UDP_CSUM;
-	net_dbg_ratelimited("UDP%s: bad checksum. From %pI4:%u to %pI4:%u ulen %d\n",
-			    proto == IPPROTO_UDPLITE ? "Lite" : "",
+	net_dbg_ratelimited("UDP: bad checksum. From %pI4:%u to %pI4:%u ulen %d\n",
 			    &saddr, ntohs(uh->source), &daddr, ntohs(uh->dest),
 			    ulen);
-	__UDP_INC_STATS(net, UDP_MIB_CSUMERRORS, proto == IPPROTO_UDPLITE);
+	__UDP_INC_STATS(net, UDP_MIB_CSUMERRORS);
 drop:
-	__UDP_INC_STATS(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);
+	__UDP_INC_STATS(net, UDP_MIB_INERRORS);
 	sk_skb_reason_drop(sk, skb, drop_reason);
 	return 0;
 }
@@ -2972,7 +2911,6 @@
 	struct udp_sock *up = udp_sk(sk);
 	int val, valbool;
 	int err = 0;
-	int is_udplite = IS_UDPLITE(sk);
 
 	if (level == SOL_SOCKET) {
 		err = sk_setsockopt(sk, level, optname, optval, optlen);
@@ -3059,36 +2997,6 @@
 		sockopt_release_sock(sk);
 		break;
 
-	/*
-	 * 	UDP-Lite's partial checksum coverage (RFC 3828).
-	 */
-	/* The sender sets actual checksum coverage length via this option.
-	 * The case coverage > packet length is handled by send module. */
-	case UDPLITE_SEND_CSCOV:
-		if (!is_udplite)         /* Disable the option on UDP sockets */
-			return -ENOPROTOOPT;
-		if (val != 0 && val < 8) /* Illegal coverage: use default (8) */
-			val = 8;
-		else if (val > USHRT_MAX)
-			val = USHRT_MAX;
-		WRITE_ONCE(up->pcslen, val);
-		udp_set_bit(UDPLITE_SEND_CC, sk);
-		break;
-
-	/* The receiver specifies a minimum checksum coverage value. To make
-	 * sense, this should be set to at least 8 (as done below). If zero is
-	 * used, this again means full checksum coverage.                     */
-	case UDPLITE_RECV_CSCOV:
-		if (!is_udplite)         /* Disable the option on UDP sockets */
-			return -ENOPROTOOPT;
-		if (val != 0 && val < 8) /* Avoid silly minimal values.       */
-			val = 8;
-		else if (val > USHRT_MAX)
-			val = USHRT_MAX;
-		WRITE_ONCE(up->pcrlen, val);
-		udp_set_bit(UDPLITE_RECV_CC, sk);
-		break;
-
 	default:
 		err = -ENOPROTOOPT;
 		break;
@@ -3101,7 +3009,7 @@
 int udp_setsockopt(struct sock *sk, int level, int optname, sockptr_t optval,
 		   unsigned int optlen)
 {
-	if (level == SOL_UDP  ||  level == SOL_UDPLITE || level == SOL_SOCKET)
+	if (level == SOL_UDP  ||  level == SOL_SOCKET)
 		return udp_lib_setsockopt(sk, level, optname,
 					  optval, optlen,
 					  udp_push_pending_frames);
@@ -3147,15 +3055,6 @@
 		val = udp_test_bit(GRO_ENABLED, sk);
 		break;
 
-	/* The following two cannot be changed on UDP sockets, the return is
-	 * always 0 (which corresponds to the full checksum coverage of UDP). */
-	case UDPLITE_SEND_CSCOV:
-		val = READ_ONCE(up->pcslen);
-		break;
-
-	case UDPLITE_RECV_CSCOV:
-		val = READ_ONCE(up->pcrlen);
-		break;
 
 	default:
 		return -ENOPROTOOPT;
@@ -3172,7 +3071,7 @@
 int udp_getsockopt(struct sock *sk, int level, int optname,
 		   char __user *optval, int __user *optlen)
 {
-	if (level == SOL_UDP  ||  level == SOL_UDPLITE)
+	if (level == SOL_UDP  ||  0)
 		return udp_lib_getsockopt(sk, level, optname, optval, optlen);
 	return ip_getsockopt(sk, level, optname, optval, optlen);
 }
@@ -3891,7 +3790,7 @@
 		goto fallback;
 
 	old_net = current->nsproxy->net_ns;
-	hash_entries = READ_ONCE(old_net->ipv4.sysctl_udp_child_hash_entries);
+	hash_entries = CONFIG_SYSCTL_UDP_CHILD_HASH_ENTRIES;
 	if (!hash_entries)
 		goto fallback;
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/udp_diag.c linux-master/net/ipv4/udp_diag.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/udp_diag.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/udp_diag.c	2025-10-20 00:41:14.000000000 -0300
@@ -10,7 +10,6 @@
 #include <linux/inet_diag.h>
 #include <linux/udp.h>
 #include <net/udp.h>
-#include <net/udplite.h>
 #include <linux/sock_diag.h>
 
 static int sk_diag_dump(struct sock *sk, struct sk_buff *skb,
@@ -224,11 +223,6 @@
 	return __udp_diag_destroy(in_skb, req, sock_net(in_skb->sk)->ipv4.udp_table);
 }
 
-static int udplite_diag_destroy(struct sk_buff *in_skb,
-				const struct inet_diag_req_v2 *req)
-{
-	return __udp_diag_destroy(in_skb, req, &udplite_table);
-}
 
 #endif
 
@@ -244,50 +238,18 @@
 #endif
 };
 
-static void udplite_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,
-			      const struct inet_diag_req_v2 *r)
-{
-	udp_dump(&udplite_table, skb, cb, r);
-}
 
-static int udplite_diag_dump_one(struct netlink_callback *cb,
-				 const struct inet_diag_req_v2 *req)
-{
-	return udp_dump_one(&udplite_table, cb, req);
-}
-
-static const struct inet_diag_handler udplite_diag_handler = {
-	.owner		 = THIS_MODULE,
-	.dump		 = udplite_diag_dump,
-	.dump_one	 = udplite_diag_dump_one,
-	.idiag_get_info  = udp_diag_get_info,
-	.idiag_type	 = IPPROTO_UDPLITE,
-	.idiag_info_size = 0,
-#ifdef CONFIG_INET_DIAG_DESTROY
-	.destroy	 = udplite_diag_destroy,
-#endif
-};
 
 static int __init udp_diag_init(void)
 {
 	int err;
 
 	err = inet_diag_register(&udp_diag_handler);
-	if (err)
-		goto out;
-	err = inet_diag_register(&udplite_diag_handler);
-	if (err)
-		goto out_lite;
-out:
 	return err;
-out_lite:
-	inet_diag_unregister(&udp_diag_handler);
-	goto out;
 }
 
 static void __exit udp_diag_exit(void)
 {
-	inet_diag_unregister(&udplite_diag_handler);
 	inet_diag_unregister(&udp_diag_handler);
 }
 
@@ -296,4 +258,3 @@
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("UDP socket monitoring via SOCK_DIAG");
 MODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 2-17 /* AF_INET - IPPROTO_UDP */);
-MODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 2-136 /* AF_INET - IPPROTO_UDPLITE */);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/udp_impl.h linux-master/net/ipv4/udp_impl.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/udp_impl.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/udp_impl.h	2025-10-20 00:41:14.000000000 -0300
@@ -3,7 +3,6 @@
 #define _UDP4_IMPL_H
 #include <net/aligned_data.h>
 #include <net/udp.h>
-#include <net/udplite.h>
 #include <net/protocol.h>
 #include <net/inet_common.h>
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/udp_tunnel_core.c linux-master/net/ipv4/udp_tunnel_core.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv4/udp_tunnel_core.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv4/udp_tunnel_core.c	2025-10-20 00:41:14.000000000 -0300
@@ -44,7 +44,6 @@
 			goto error;
 	}
 
-	sock->sk->sk_no_check_tx = !cfg->use_udp_checksums;
 
 	*sockp = sock;
 	return 0;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/af_inet6.c linux-master/net/ipv6/af_inet6.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/af_inet6.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/af_inet6.c	2025-10-20 00:41:14.000000000 -0300
@@ -43,7 +43,6 @@
 #include <net/ip.h>
 #include <net/ipv6.h>
 #include <net/udp.h>
-#include <net/udplite.h>
 #include <net/tcp.h>
 #include <net/ping.h>
 #include <net/protocol.h>
@@ -907,9 +906,6 @@
 	net->mib.udp_stats_in6 = alloc_percpu(struct udp_mib);
 	if (!net->mib.udp_stats_in6)
 		return -ENOMEM;
-	net->mib.udplite_stats_in6 = alloc_percpu(struct udp_mib);
-	if (!net->mib.udplite_stats_in6)
-		goto err_udplite_mib;
 	net->mib.ipv6_statistics = alloc_percpu(struct ipstats_mib);
 	if (!net->mib.ipv6_statistics)
 		goto err_ip_mib;
@@ -935,8 +931,6 @@
 err_icmp_mib:
 	free_percpu(net->mib.ipv6_statistics);
 err_ip_mib:
-	free_percpu(net->mib.udplite_stats_in6);
-err_udplite_mib:
 	free_percpu(net->mib.udp_stats_in6);
 	return -ENOMEM;
 }
@@ -944,7 +938,6 @@
 static void ipv6_cleanup_mibs(struct net *net)
 {
 	free_percpu(net->mib.udp_stats_in6);
-	free_percpu(net->mib.udplite_stats_in6);
 	free_percpu(net->mib.ipv6_statistics);
 	free_percpu(net->mib.icmpv6_statistics);
 	kfree(net->mib.icmpv6msg_statistics);
@@ -955,11 +948,6 @@
 	int err = 0;
 
 	net->ipv6.sysctl.bindv6only = 0;
-	net->ipv6.sysctl.icmpv6_time = 1*HZ;
-	net->ipv6.sysctl.icmpv6_echo_ignore_all = 0;
-	net->ipv6.sysctl.icmpv6_echo_ignore_multicast = 0;
-	net->ipv6.sysctl.icmpv6_echo_ignore_anycast = 0;
-	net->ipv6.sysctl.icmpv6_error_anycast_as_unicast = 0;
 
 	/* By default, rate limit error messages.
 	 * Except for pmtu discovery, it would break it.
@@ -1096,13 +1084,9 @@
 	if (err)
 		goto out_unregister_tcp_proto;
 
-	err = proto_register(&udplitev6_prot, 1);
-	if (err)
-		goto out_unregister_udp_proto;
-
 	err = proto_register(&rawv6_prot, 1);
 	if (err)
-		goto out_unregister_udplite_proto;
+		goto out_unregister_udp_proto;
 
 	err = proto_register(&pingv6_prot, 1);
 	if (err)
@@ -1153,8 +1137,6 @@
 	err = -ENOMEM;
 	if (raw6_proc_init())
 		goto proc_raw6_fail;
-	if (udplite6_proc_init())
-		goto proc_udplite6_fail;
 	if (ipv6_misc_proc_init())
 		goto proc_misc6_fail;
 	if (if6_proc_init())
@@ -1190,9 +1172,6 @@
 	if (err)
 		goto udpv6_fail;
 
-	err = udplitev6_init();
-	if (err)
-		goto udplitev6_fail;
 
 	err = udpv6_offload_init();
 	if (err)
@@ -1264,8 +1243,6 @@
 tcpv6_fail:
 	udpv6_offload_exit();
 udpv6_offload_fail:
-	udplitev6_exit();
-udplitev6_fail:
 	udpv6_exit();
 udpv6_fail:
 	ipv6_frag_exit();
@@ -1287,8 +1264,6 @@
 proc_if6_fail:
 	ipv6_misc_proc_exit();
 proc_misc6_fail:
-	udplite6_proc_exit();
-proc_udplite6_fail:
 	raw6_proc_exit();
 proc_raw6_fail:
 #endif
@@ -1312,8 +1287,6 @@
 	proto_unregister(&pingv6_prot);
 out_unregister_raw_proto:
 	proto_unregister(&rawv6_prot);
-out_unregister_udplite_proto:
-	proto_unregister(&udplitev6_prot);
 out_unregister_udp_proto:
 	proto_unregister(&udpv6_prot);
 out_unregister_tcp_proto:
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/fou6.c linux-master/net/ipv6/fou6.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/fou6.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/fou6.c	2025-10-20 00:41:14.000000000 -0300
@@ -141,8 +141,7 @@
 	 * recursion. Besides, this kind of encapsulation can't even be
 	 * configured currently. Discard this.
 	 */
-	if (guehdr->proto_ctype == IPPROTO_UDP ||
-	    guehdr->proto_ctype == IPPROTO_UDPLITE)
+	if (guehdr->proto_ctype == IPPROTO_UDP)
 		return -EOPNOTSUPP;
 
 	skb_set_transport_header(skb, -(int)sizeof(struct icmp6hdr));
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/icmp.c linux-master/net/ipv6/icmp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/icmp.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/icmp.c	2025-10-20 00:41:14.000000000 -0300
@@ -218,7 +218,7 @@
 		res = true;
 	} else {
 		struct rt6_info *rt = dst_rt6_info(dst);
-		int tmo = net->ipv6.sysctl.icmpv6_time;
+		int tmo = CONFIG_SYSCTL_ICMPV6_TIME;
 		struct inet_peer *peer;
 
 		/* Give more bandwidth to wider prefixes. */
@@ -369,7 +369,7 @@
 	 * We won't send icmp if the destination is known
 	 * anycast unless we need to treat anycast as unicast.
 	 */
-	if (!READ_ONCE(net->ipv6.sysctl.icmpv6_error_anycast_as_unicast) &&
+	if (!CONFIG_SYSCTL_ICMPV6_ERROR_ANYCAST_AS_UNICAST &&
 	    ipv6_anycast_destination(dst, &fl6->daddr)) {
 		net_dbg_ratelimited("icmp6_send: acast source\n");
 		dst_release(dst);
@@ -740,13 +740,13 @@
 	u8 type;
 
 	if (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr) &&
-	    net->ipv6.sysctl.icmpv6_echo_ignore_multicast)
+	    CONFIG_SYSCTL_ICMPV6_ECHO_IGNORE_MULTICAST)
 		return reason;
 
 	saddr = &ipv6_hdr(skb)->daddr;
 
 	acast = ipv6_anycast_destination(skb_dst(skb), saddr);
-	if (acast && net->ipv6.sysctl.icmpv6_echo_ignore_anycast)
+	if (acast && CONFIG_SYSCTL_ICMPV6_ECHO_IGNORE_ANYCAST)
 		return reason;
 
 	if (!ipv6_unicast_destination(skb) &&
@@ -948,12 +948,12 @@
 
 	switch (type) {
 	case ICMPV6_ECHO_REQUEST:
-		if (!net->ipv6.sysctl.icmpv6_echo_ignore_all)
+		if (!CONFIG_SYSCTL_ICMPV6_ECHO_IGNORE_ALL)
 			reason = icmpv6_echo_reply(skb);
 		break;
 	case ICMPV6_EXT_ECHO_REQUEST:
-		if (!net->ipv6.sysctl.icmpv6_echo_ignore_all &&
-		    READ_ONCE(net->ipv4.sysctl_icmp_echo_enable_probe))
+		if (!CONFIG_SYSCTL_ICMPV6_ECHO_IGNORE_ALL &&
+		    CONFIG_SYSCTL_ICMP_ECHO_ENABLE_PROBE)
 			reason = icmpv6_echo_reply(skb);
 		break;
 
@@ -1173,49 +1173,12 @@
 #ifdef CONFIG_SYSCTL
 static struct ctl_table ipv6_icmp_table_template[] = {
 	{
-		.procname	= "ratelimit",
-		.data		= &init_net.ipv6.sysctl.icmpv6_time,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_ms_jiffies,
-	},
-	{
-		.procname	= "echo_ignore_all",
-		.data		= &init_net.ipv6.sysctl.icmpv6_echo_ignore_all,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler = proc_dou8vec_minmax,
-	},
-	{
-		.procname	= "echo_ignore_multicast",
-		.data		= &init_net.ipv6.sysctl.icmpv6_echo_ignore_multicast,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler = proc_dou8vec_minmax,
-	},
-	{
-		.procname	= "echo_ignore_anycast",
-		.data		= &init_net.ipv6.sysctl.icmpv6_echo_ignore_anycast,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler = proc_dou8vec_minmax,
-	},
-	{
 		.procname	= "ratemask",
 		.data		= &init_net.ipv6.sysctl.icmpv6_ratemask_ptr,
 		.maxlen		= ICMPV6_MSG_MAX + 1,
 		.mode		= 0644,
 		.proc_handler = proc_do_large_bitmap,
 	},
-	{
-		.procname	= "error_anycast_as_unicast",
-		.data		= &init_net.ipv6.sysctl.icmpv6_error_anycast_as_unicast,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler	= proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE,
-	},
 };
 
 struct ctl_table * __net_init ipv6_icmp_sysctl_init(struct net *net)
@@ -1227,12 +1190,7 @@
 			GFP_KERNEL);
 
 	if (table) {
-		table[0].data = &net->ipv6.sysctl.icmpv6_time;
-		table[1].data = &net->ipv6.sysctl.icmpv6_echo_ignore_all;
-		table[2].data = &net->ipv6.sysctl.icmpv6_echo_ignore_multicast;
-		table[3].data = &net->ipv6.sysctl.icmpv6_echo_ignore_anycast;
-		table[4].data = &net->ipv6.sysctl.icmpv6_ratemask_ptr;
-		table[5].data = &net->ipv6.sysctl.icmpv6_error_anycast_as_unicast;
+		table[0].data = &net->ipv6.sysctl.icmpv6_ratemask_ptr;
 	}
 	return table;
 }
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/ip6_checksum.c linux-master/net/ipv6/ip6_checksum.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/ip6_checksum.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/ip6_checksum.c	2025-10-20 00:41:14.000000000 -0300
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <net/ip.h>
 #include <net/udp.h>
-#include <net/udplite.h>
+#include <net/ip6_checksum.h>
 #include <asm/checksum.h>
 
 #ifndef _HAVE_ARCH_IPV6_CSUM
@@ -66,19 +66,8 @@
 {
 	int err;
 
-	UDP_SKB_CB(skb)->partial_cov = 0;
 	UDP_SKB_CB(skb)->cscov = skb->len;
 
-	if (proto == IPPROTO_UDPLITE) {
-		err = udplite_checksum_init(skb, uh);
-		if (err)
-			return err;
-
-		if (UDP_SKB_CB(skb)->partial_cov) {
-			skb->csum = ip6_compute_pseudo(skb, proto);
-			return 0;
-		}
-	}
 
 	/* To support RFC 6936 (allow zero checksum in UDP/IPV6 for tunnels)
 	 * we accept a checksum of zero here. When we find the socket
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/ipv6_sockglue.c linux-master/net/ipv6/ipv6_sockglue.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/ipv6_sockglue.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/ipv6_sockglue.c	2025-10-20 00:41:14.000000000 -0300
@@ -45,7 +45,6 @@
 #include <net/inet_common.h>
 #include <net/tcp.h>
 #include <net/udp.h>
-#include <net/udplite.h>
 #include <net/xfrm.h>
 #include <net/compat.h>
 #include <net/seg6.h>
@@ -563,8 +562,7 @@
 			if (sk->sk_type == SOCK_RAW)
 				break;
 
-			if (sk->sk_protocol == IPPROTO_UDP ||
-			    sk->sk_protocol == IPPROTO_UDPLITE) {
+			if (sk->sk_protocol == IPPROTO_UDP) {
 				struct udp_sock *up = udp_sk(sk);
 				if (up->pending == AF_INET6) {
 					retv = -EBUSY;
@@ -609,8 +607,6 @@
 			} else {
 				struct proto *prot = &udp_prot;
 
-				if (sk->sk_protocol == IPPROTO_UDPLITE)
-					prot = &udplite_prot;
 
 				sock_prot_inuse_add(net, sk->sk_prot, -1);
 				sock_prot_inuse_add(net, prot, 1);
@@ -1098,7 +1094,6 @@
 	switch (optname) {
 	case IPV6_ADDRFORM:
 		if (sk->sk_protocol != IPPROTO_UDP &&
-		    sk->sk_protocol != IPPROTO_UDPLITE &&
 		    sk->sk_protocol != IPPROTO_TCP)
 			return -ENOPROTOOPT;
 		if (sk->sk_state != TCP_ESTABLISHED)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/Makefile linux-master/net/ipv6/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -7,7 +7,7 @@
 
 ipv6-y :=	af_inet6.o anycast.o ip6_output.o ip6_input.o addrconf.o \
 		addrlabel.o \
-		route.o ip6_fib.o ipv6_sockglue.o ndisc.o udp.o udplite.o \
+		route.o ip6_fib.o ipv6_sockglue.o ndisc.o udp.o \
 		raw.o icmp.o mcast.o reassembly.o tcp_ipv6.o ping.o \
 		exthdrs.o datagram.o ip6_flowlabel.o inet6_connection_sock.o \
 		udp_offload.o seg6.o fib6_notifier.o rpl.o ioam6.o
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/proc.c linux-master/net/ipv6/proc.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/proc.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/proc.c	2025-10-20 00:41:14.000000000 -0300
@@ -39,8 +39,6 @@
 		       sock_prot_inuse_get(net, &tcpv6_prot));
 	seq_printf(seq, "UDP6: inuse %d\n",
 		       sock_prot_inuse_get(net, &udpv6_prot));
-	seq_printf(seq, "UDPLITE6: inuse %d\n",
-			sock_prot_inuse_get(net, &udplitev6_prot));
 	seq_printf(seq, "RAW6: inuse %d\n",
 		       sock_prot_inuse_get(net, &rawv6_prot));
 	seq_printf(seq, "FRAG6: inuse %u memory %lu\n",
@@ -110,17 +108,6 @@
 	SNMP_MIB_ITEM("Udp6MemErrors", UDP_MIB_MEMERRORS),
 };
 
-static const struct snmp_mib snmp6_udplite6_list[] = {
-	SNMP_MIB_ITEM("UdpLite6InDatagrams", UDP_MIB_INDATAGRAMS),
-	SNMP_MIB_ITEM("UdpLite6NoPorts", UDP_MIB_NOPORTS),
-	SNMP_MIB_ITEM("UdpLite6InErrors", UDP_MIB_INERRORS),
-	SNMP_MIB_ITEM("UdpLite6OutDatagrams", UDP_MIB_OUTDATAGRAMS),
-	SNMP_MIB_ITEM("UdpLite6RcvbufErrors", UDP_MIB_RCVBUFERRORS),
-	SNMP_MIB_ITEM("UdpLite6SndbufErrors", UDP_MIB_SNDBUFERRORS),
-	SNMP_MIB_ITEM("UdpLite6InCsumErrors", UDP_MIB_CSUMERRORS),
-	SNMP_MIB_ITEM("UdpLite6MemErrors", UDP_MIB_MEMERRORS),
-};
-
 static void snmp6_seq_show_icmpv6msg(struct seq_file *seq, atomic_long_t *smib)
 {
 	char name[32];
@@ -228,9 +215,6 @@
 	snmp6_seq_show_item(seq, net->mib.udp_stats_in6,
 			    NULL, snmp6_udp6_list,
 			    ARRAY_SIZE(snmp6_udp6_list));
-	snmp6_seq_show_item(seq, net->mib.udplite_stats_in6,
-			    NULL, snmp6_udplite6_list,
-			    ARRAY_SIZE(snmp6_udplite6_list));
 	return 0;
 }
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/syncookies.c linux-master/net/ipv6/syncookies.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/syncookies.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/syncookies.c	2025-10-20 00:41:14.000000000 -0300
@@ -148,7 +148,7 @@
 
 	/* check for timestamp cookie support */
 	memset(&tcp_opt, 0, sizeof(tcp_opt));
-	tcp_parse_options(net, skb, &tcp_opt, 0, NULL);
+	tcp_parse_options(net, skb, &tcp_opt, 0);
 
 	if (tcp_opt.saw_tstamp && tcp_opt.rcv_tsecr) {
 		tsoff = secure_tcpv6_ts_off(net,
@@ -180,7 +180,7 @@
 	int full_space;
 	SKB_DR(reason);
 
-	if (!READ_ONCE(net->ipv4.sysctl_tcp_syncookies) ||
+	if (!CONFIG_SYSCTL_TCP_SYNCOOKIES ||
 	    !th->ack || th->rst)
 		goto out;
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/tcp_ipv6.c linux-master/net/ipv6/tcp_ipv6.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/tcp_ipv6.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/tcp_ipv6.c	2025-10-20 00:41:14.000000000 -0300
@@ -232,8 +232,6 @@
 
 		/* Paired with READ_ONCE() in tcp_(get|set)sockopt() */
 		WRITE_ONCE(icsk->icsk_af_ops, &ipv6_mapped);
-		if (sk_is_mptcp(sk))
-			mptcpv6_handle_mapped(sk, true);
 		sk->sk_backlog_rcv = tcp_v4_do_rcv;
 #if defined(CONFIG_TCP_MD5SIG) || defined(CONFIG_TCP_AO)
 		tp->af_specific = &tcp_sock_ipv6_mapped_specific;
@@ -245,8 +243,6 @@
 			icsk->icsk_ext_hdr_len = exthdrlen;
 			/* Paired with READ_ONCE() in tcp_(get|set)sockopt() */
 			WRITE_ONCE(icsk->icsk_af_ops, &ipv6_specific);
-			if (sk_is_mptcp(sk))
-				mptcpv6_handle_mapped(sk, false);
 			sk->sk_backlog_rcv = tcp_v6_do_rcv;
 #if defined(CONFIG_TCP_MD5SIG) || defined(CONFIG_TCP_AO)
 			tp->af_specific = &tcp_sock_ipv6_specific;
@@ -329,8 +325,6 @@
 						   sk->sk_v6_daddr.s6_addr32);
 	}
 
-	if (tcp_fastopen_defer_connect(sk, &err))
-		return err;
 	if (err)
 		goto late_failure;
 
@@ -381,7 +375,6 @@
 	const struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;
 	const struct tcphdr *th = (struct tcphdr *)(skb->data+offset);
 	struct net *net = dev_net_rcu(skb->dev);
-	struct request_sock *fastopen;
 	struct ipv6_pinfo *np;
 	struct tcp_sock *tp;
 	__u32 seq, snd_una;
@@ -433,9 +426,7 @@
 	}
 
 	tp = tcp_sk(sk);
-	/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */
-	fastopen = rcu_dereference(tp->fastopen_rsk);
-	snd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;
+	snd_una = tp->snd_una;
 	if (sk->sk_state != TCP_LISTEN &&
 	    !between(seq, snd_una, tp->snd_nxt)) {
 		__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);
@@ -488,8 +479,6 @@
 		/* Only in fast or simultaneous open. If a fast open socket is
 		 * already accepted it is treated as a connected one below.
 		 */
-		if (fastopen && !fastopen->sk)
-			break;
 
 		ipv6_icmp_error(sk, skb, err, th->dest, ntohl(info), (u8 *)th);
 
@@ -504,7 +493,7 @@
 		/* check if this ICMP message allows revert of backoff.
 		 * (see RFC 6069)
 		 */
-		if (!fastopen && type == ICMPV6_DEST_UNREACH &&
+		if (!0 && type == ICMPV6_DEST_UNREACH &&
 		    code == ICMPV6_NOROUTE)
 			tcp_ld_RTO_revert(sk, seq);
 	}
@@ -525,7 +514,6 @@
 static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,
 			      struct flowi *fl,
 			      struct request_sock *req,
-			      struct tcp_fastopen_cookie *foc,
 			      enum tcp_synack_type synack_type,
 			      struct sk_buff *syn_skb)
 {
@@ -542,7 +530,7 @@
 					       IPPROTO_TCP)) == NULL)
 		goto done;
 
-	skb = tcp_make_synack(sk, dst, req, foc, synack_type, syn_skb);
+	skb = tcp_make_synack(sk, dst, req, synack_type, syn_skb);
 
 	if (skb) {
 		tcp_rsk(req)->syn_ect_snt = np->tclass & INET_ECN_MASK;
@@ -553,7 +541,7 @@
 		if (inet6_test_bit(REPFLOW, sk) && ireq->pktopts)
 			fl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));
 
-		tclass = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reflect_tos) ?
+		tclass = CONFIG_SYSCTL_TCP_REFLECT_TOS ?
 				(tcp_rsk(req)->syn_tos & ~INET_ECN_MASK) |
 				(np->tclass & INET_ECN_MASK) :
 				np->tclass;
@@ -887,14 +875,6 @@
 	if (tcp_key_is_ao(key))
 		tot_len += tcp_ao_len_aligned(key->ao_key);
 
-#ifdef CONFIG_MPTCP
-	if (rst && !tcp_key_is_md5(key)) {
-		mrst = mptcp_reset_option(skb);
-
-		if (mrst)
-			tot_len += sizeof(__be32);
-	}
-#endif
 
 	buff = alloc_skb(MAX_TCP_HEADER, GFP_ATOMIC);
 	if (!buff)
@@ -1396,8 +1376,6 @@
 		newnp->saddr = newsk->sk_v6_rcv_saddr;
 
 		inet_csk(newsk)->icsk_af_ops = &ipv6_mapped;
-		if (sk_is_mptcp(newsk))
-			mptcpv6_handle_mapped(newsk, true);
 		newsk->sk_backlog_rcv = tcp_v4_do_rcv;
 #if defined(CONFIG_TCP_MD5SIG) || defined(CONFIG_TCP_AO)
 		newtp->af_specific = &tcp_sock_ipv6_mapped_specific;
@@ -1488,7 +1466,7 @@
 	/* Set ToS of the new socket based upon the value of incoming SYN.
 	 * ECT bits are set later in tcp_init_transfer().
 	 */
-	if (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reflect_tos))
+	if (CONFIG_SYSCTL_TCP_REFLECT_TOS)
 		newnp->tclass = tcp_rsk(req)->syn_tos & ~INET_ECN_MASK;
 
 	/* Clone native IPv6 options from listening socket (if any)
@@ -1842,7 +1820,7 @@
 			th = (const struct tcphdr *)skb->data;
 			hdr = ipv6_hdr(skb);
 			tcp_v6_fill_cb(skb, hdr, th);
-			nsk = tcp_check_req(sk, skb, req, false, &req_stolen,
+			nsk = tcp_check_req(sk, skb, req, &req_stolen,
 					    &drop_reason);
 		}
 		if (!nsk) {
@@ -2193,7 +2171,6 @@
 	const struct inet_sock *inet = inet_sk(sp);
 	const struct tcp_sock *tp = tcp_sk(sp);
 	const struct inet_connection_sock *icsk = inet_csk(sp);
-	const struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;
 	u8 icsk_pending;
 	int rx_queue;
 	int state;
@@ -2253,7 +2230,7 @@
 		   (icsk->icsk_ack.quick << 1) | inet_csk_in_pingpong_mode(sp),
 		   tcp_snd_cwnd(tp),
 		   state == TCP_LISTEN ?
-			fastopenq->max_qlen :
+			0 :
 			(tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh)
 		   );
 }
@@ -2440,9 +2417,6 @@
 	if (ret)
 		goto out_tcpv6_protosw;
 
-	ret = mptcpv6_init();
-	if (ret)
-		goto out_tcpv6_pernet_subsys;
 
 out:
 	return ret;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/udp.c linux-master/net/ipv6/udp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/udp.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/udp.c	2025-10-20 00:41:14.000000000 -0300
@@ -472,7 +472,6 @@
 	struct sk_buff *skb;
 	unsigned int ulen, copied;
 	int off, err, peeking = flags & MSG_PEEK;
-	int is_udplite = IS_UDPLITE(sk);
 	struct udp_mib __percpu *mib;
 	bool checksum_valid = false;
 	int is_udp4;
@@ -506,7 +505,7 @@
 	 */
 
 	if (copied < ulen || peeking ||
-	    (is_udplite && UDP_SKB_CB(skb)->partial_cov)) {
+	    (0 && 0)) {
 		checksum_valid = udp_skb_csum_unnecessary(skb) ||
 				!__udp_lib_checksum_complete(skb);
 		if (!checksum_valid)
@@ -794,20 +793,17 @@
 
 	rc = __udp_enqueue_schedule_skb(sk, skb);
 	if (rc < 0) {
-		int is_udplite = IS_UDPLITE(sk);
 		enum skb_drop_reason drop_reason;
 
 		/* Note that an ENOMEM error is charged twice */
 		if (rc == -ENOMEM) {
-			UDP6_INC_STATS(sock_net(sk),
-					 UDP_MIB_RCVBUFERRORS, is_udplite);
+			UDP6_INC_STATS(sock_net(sk), UDP_MIB_RCVBUFERRORS);
 			drop_reason = SKB_DROP_REASON_SOCKET_RCVBUFF;
 		} else {
-			UDP6_INC_STATS(sock_net(sk),
-				       UDP_MIB_MEMERRORS, is_udplite);
+			UDP6_INC_STATS(sock_net(sk), UDP_MIB_MEMERRORS);
 			drop_reason = SKB_DROP_REASON_PROTO_MEM;
 		}
-		UDP6_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
+		UDP6_INC_STATS(sock_net(sk), UDP_MIB_INERRORS);
 		trace_udp_fail_queue_rcv_skb(rc, sk, skb);
 		sk_skb_reason_drop(sk, skb, drop_reason);
 		return -1;
@@ -828,7 +824,6 @@
 {
 	enum skb_drop_reason drop_reason = SKB_DROP_REASON_NOT_SPECIFIED;
 	struct udp_sock *up = udp_sk(sk);
-	int is_udplite = IS_UDPLITE(sk);
 
 	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb)) {
 		drop_reason = SKB_DROP_REASON_XFRM_POLICY;
@@ -863,8 +858,7 @@
 			ret = encap_rcv(sk, skb);
 			if (ret <= 0) {
 				__UDP6_INC_STATS(sock_net(sk),
-						 UDP_MIB_INDATAGRAMS,
-						 is_udplite);
+						 UDP_MIB_INDATAGRAMS);
 				return -ret;
 			}
 		}
@@ -872,23 +866,6 @@
 		/* FALLTHROUGH -- it's a UDP Packet */
 	}
 
-	/*
-	 * UDP-Lite specific tests, ignored on UDP sockets (see net/ipv4/udp.c).
-	 */
-	if (udp_test_bit(UDPLITE_RECV_CC, sk) && UDP_SKB_CB(skb)->partial_cov) {
-		u16 pcrlen = READ_ONCE(up->pcrlen);
-
-		if (pcrlen == 0) {          /* full coverage was set  */
-			net_dbg_ratelimited("UDPLITE6: partial coverage %d while full coverage %d requested\n",
-					    UDP_SKB_CB(skb)->cscov, skb->len);
-			goto drop;
-		}
-		if (UDP_SKB_CB(skb)->cscov < pcrlen) {
-			net_dbg_ratelimited("UDPLITE6: coverage %d too small, need min %d\n",
-					    UDP_SKB_CB(skb)->cscov, pcrlen);
-			goto drop;
-		}
-	}
 
 	prefetch(&sk->sk_rmem_alloc);
 	if (rcu_access_pointer(sk->sk_filter) &&
@@ -906,9 +883,9 @@
 
 csum_error:
 	drop_reason = SKB_DROP_REASON_UDP_CSUM;
-	__UDP6_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);
+	__UDP6_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS);
 drop:
-	__UDP6_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
+	__UDP6_INC_STATS(sock_net(sk), UDP_MIB_INERRORS);
 	udp_drops_inc(sk);
 	sk_skb_reason_drop(sk, skb, drop_reason);
 	return -1;
@@ -1015,10 +992,8 @@
 		nskb = skb_clone(skb, GFP_ATOMIC);
 		if (unlikely(!nskb)) {
 			udp_drops_inc(sk);
-			__UDP6_INC_STATS(net, UDP_MIB_RCVBUFERRORS,
-					 IS_UDPLITE(sk));
-			__UDP6_INC_STATS(net, UDP_MIB_INERRORS,
-					 IS_UDPLITE(sk));
+			__UDP6_INC_STATS(net, UDP_MIB_RCVBUFERRORS);
+			__UDP6_INC_STATS(net, UDP_MIB_INERRORS);
 			continue;
 		}
 
@@ -1037,8 +1012,7 @@
 			consume_skb(skb);
 	} else {
 		kfree_skb(skb);
-		__UDP6_INC_STATS(net, UDP_MIB_IGNOREDMULTI,
-				 proto == IPPROTO_UDPLITE);
+		__UDP6_INC_STATS(net, UDP_MIB_IGNOREDMULTI);
 	}
 	return 0;
 }
@@ -1057,7 +1031,7 @@
 {
 	int ret;
 
-	if (inet_get_convert_csum(sk) && uh->check && !IS_UDPLITE(sk))
+	if (inet_get_convert_csum(sk) && uh->check)
 		skb_checksum_try_convert(skb, IPPROTO_UDP, ip6_compute_pseudo);
 
 	ret = udpv6_queue_rcv_skb(sk, skb);
@@ -1164,7 +1138,7 @@
 	if (udp_lib_checksum_complete(skb))
 		goto csum_error;
 
-	__UDP6_INC_STATS(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);
+	__UDP6_INC_STATS(net, UDP_MIB_NOPORTS);
 	icmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);
 
 	sk_skb_reason_drop(sk, skb, reason);
@@ -1174,7 +1148,7 @@
 	if (reason == SKB_DROP_REASON_NOT_SPECIFIED)
 		reason = SKB_DROP_REASON_PKT_TOO_SMALL;
 	net_dbg_ratelimited("UDP%sv6: short packet: From [%pI6c]:%u %d/%d to [%pI6c]:%u\n",
-			    proto == IPPROTO_UDPLITE ? "-Lite" : "",
+			    "",
 			    saddr, ntohs(uh->source),
 			    ulen, skb->len,
 			    daddr, ntohs(uh->dest));
@@ -1185,9 +1159,9 @@
 csum_error:
 	if (reason == SKB_DROP_REASON_NOT_SPECIFIED)
 		reason = SKB_DROP_REASON_UDP_CSUM;
-	__UDP6_INC_STATS(net, UDP_MIB_CSUMERRORS, proto == IPPROTO_UDPLITE);
+	__UDP6_INC_STATS(net, UDP_MIB_CSUMERRORS);
 discard:
-	__UDP6_INC_STATS(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);
+	__UDP6_INC_STATS(net, UDP_MIB_INERRORS);
 	sk_skb_reason_drop(sk, skb, reason);
 	return 0;
 }
@@ -1371,7 +1345,6 @@
 	struct sock *sk = skb->sk;
 	struct udphdr *uh;
 	int err = 0;
-	int is_udplite = IS_UDPLITE(sk);
 	__wsum csum = 0;
 	int offset = skb_transport_offset(skb);
 	int len = skb->len - offset;
@@ -1402,7 +1375,7 @@
 			kfree_skb(skb);
 			return -EINVAL;
 		}
-		if (is_udplite || dst_xfrm(skb_dst(skb))) {
+		if (dst_xfrm(skb_dst(skb))) {
 			kfree_skb(skb);
 			return -EIO;
 		}
@@ -1418,9 +1391,7 @@
 		}
 	}
 
-	if (is_udplite)
-		csum = udplite_csum(skb);
-	else if (udp_get_no_check6_tx(sk)) {   /* UDP csum disabled */
+	if (udp_get_no_check6_tx(sk)) {   /* UDP csum disabled */
 		skb->ip_summed = CHECKSUM_NONE;
 		goto send;
 	} else if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */
@@ -1441,12 +1412,12 @@
 	if (err) {
 		if (err == -ENOBUFS && !inet6_test_bit(RECVERR6, sk)) {
 			UDP6_INC_STATS(sock_net(sk),
-				       UDP_MIB_SNDBUFERRORS, is_udplite);
+				       UDP_MIB_SNDBUFERRORS);
 			err = 0;
 		}
 	} else {
 		UDP6_INC_STATS(sock_net(sk),
-			       UDP_MIB_OUTDATAGRAMS, is_udplite);
+			       UDP_MIB_OUTDATAGRAMS);
 	}
 	return err;
 }
@@ -1492,7 +1463,6 @@
 	int ulen = len;
 	int corkreq = udp_test_bit(CORK, sk) || msg->msg_flags & MSG_MORE;
 	int err;
-	int is_udplite = IS_UDPLITE(sk);
 	int (*getfrag)(void *, char *, int, int, int, struct sk_buff *);
 
 	ipcm6_init_sk(&ipc6, sk);
@@ -1553,7 +1523,7 @@
 	if (len > INT_MAX - sizeof(struct udphdr))
 		return -EMSGSIZE;
 
-	getfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;
+	getfrag  =  ip_generic_getfrag;
 	if (READ_ONCE(up->pending)) {
 		if (READ_ONCE(up->pending) == AF_INET)
 			return udp_sendmsg(sk, msg, len);
@@ -1778,7 +1748,7 @@
 	 */
 	if (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {
 		UDP6_INC_STATS(sock_net(sk),
-			       UDP_MIB_SNDBUFERRORS, is_udplite);
+			       UDP_MIB_SNDBUFERRORS);
 	}
 	return err;
 
@@ -1837,7 +1807,7 @@
 int udpv6_setsockopt(struct sock *sk, int level, int optname, sockptr_t optval,
 		     unsigned int optlen)
 {
-	if (level == SOL_UDP  ||  level == SOL_UDPLITE || level == SOL_SOCKET)
+	if (level == SOL_UDP  ||  level == SOL_SOCKET)
 		return udp_lib_setsockopt(sk, level, optname,
 					  optval, optlen,
 					  udp_v6_push_pending_frames);
@@ -1847,7 +1817,7 @@
 int udpv6_getsockopt(struct sock *sk, int level, int optname,
 		     char __user *optval, int __user *optlen)
 {
-	if (level == SOL_UDP  ||  level == SOL_UDPLITE)
+	if (level == SOL_UDP)
 		return udp_lib_getsockopt(sk, level, optname, optval, optlen);
 	return ipv6_getsockopt(sk, level, optname, optval, optlen);
 }
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/udp_impl.h linux-master/net/ipv6/udp_impl.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/ipv6/udp_impl.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/ipv6/udp_impl.h	2025-10-20 00:41:14.000000000 -0300
@@ -3,7 +3,6 @@
 #define _UDP6_IMPL_H
 #include <net/aligned_data.h>
 #include <net/udp.h>
-#include <net/udplite.h>
 #include <net/protocol.h>
 #include <net/addrconf.h>
 #include <net/inet_common.h>
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/Kconfig linux-master/net/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -137,7 +137,6 @@
 source "net/ipv4/Kconfig"
 source "net/ipv6/Kconfig"
 source "net/netlabel/Kconfig"
-source "net/mptcp/Kconfig"
 
 endif # if INET
 
@@ -272,7 +271,6 @@
 source "net/dcb/Kconfig"
 source "net/dns_resolver/Kconfig"
 source "net/batman-adv/Kconfig"
-source "net/openvswitch/Kconfig"
 source "net/vmw_vsock/Kconfig"
 source "net/netlink/Kconfig"
 source "net/mpls/Kconfig"
@@ -324,7 +322,7 @@
 	bool
 
 config XPS
-	bool
+	bool "XPS"
 	depends on SMP
 	select SOCK_RX_QUEUE_MAPPING
 	default y
@@ -462,11 +460,11 @@
 	  lookup for incoming and outgoing packets.
 
 config DST_CACHE
-	bool
+	bool "DST_CACHE"
 	default n
 
 config GRO_CELLS
-	bool
+	bool "GRO_CELLS"
 	default n
 
 config SOCK_VALIDATE_XMIT
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/l2tp/l2tp_core.c linux-master/net/l2tp/l2tp_core.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/l2tp/l2tp_core.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/l2tp/l2tp_core.c	2025-10-20 00:41:14.000000000 -0300
@@ -1298,7 +1298,7 @@
 				      &sk->sk_v6_daddr, udp_len);
 		else
 #endif
-			udp_set_csum(sk->sk_no_check_tx, skb, inet->inet_saddr,
+			udp_set_csum(1, skb, inet->inet_saddr,
 				     inet->inet_daddr, udp_len);
 		break;
 
@@ -1477,7 +1477,6 @@
 			udp_conf.family = AF_INET;
 			udp_conf.local_ip = cfg->local_ip;
 			udp_conf.peer_ip = cfg->peer_ip;
-			udp_conf.use_udp_checksums = cfg->use_udp_checksums;
 		}
 
 		udp_conf.local_udp_port = htons(cfg->local_udp_port);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/l2tp/l2tp_core.h linux-master/net/l2tp/l2tp_core.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/l2tp/l2tp_core.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/l2tp/l2tp_core.h	2025-10-20 00:41:14.000000000 -0300
@@ -143,7 +143,7 @@
 #endif
 	u16			local_udp_port;
 	u16			peer_udp_port;
-	unsigned int		use_udp_checksums:1,
+	unsigned int		XXXXX:1,
 				udp6_zero_tx_checksums:1,
 				udp6_zero_rx_checksums:1;
 };
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/l2tp/l2tp_netlink.c linux-master/net/l2tp/l2tp_netlink.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/l2tp/l2tp_netlink.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/l2tp/l2tp_netlink.c	2025-10-20 00:41:14.000000000 -0300
@@ -162,7 +162,6 @@
 		cfg->local_udp_port = nla_get_u16(attrs[L2TP_ATTR_UDP_SPORT]);
 	if (attrs[L2TP_ATTR_UDP_DPORT])
 		cfg->peer_udp_port = nla_get_u16(attrs[L2TP_ATTR_UDP_DPORT]);
-	cfg->use_udp_checksums = nla_get_flag(attrs[L2TP_ATTR_UDP_CSUM]);
 
 	/* Must have either AF_INET or AF_INET6 address for source and destination */
 #if IS_ENABLED(CONFIG_IPV6)
@@ -350,7 +349,7 @@
 
 	switch (encap) {
 	case L2TP_ENCAPTYPE_UDP:
-		if (nla_put_u8(skb, L2TP_ATTR_UDP_CSUM, !sk->sk_no_check_tx) ||
+		if (nla_put_u8(skb, L2TP_ATTR_UDP_CSUM, !1) ||
 		    nla_put_u16(skb, L2TP_ATTR_UDP_SPORT, ntohs(inet->inet_sport)) ||
 		    nla_put_u16(skb, L2TP_ATTR_UDP_DPORT, ntohs(inet->inet_dport)))
 			return -1;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/Makefile linux-master/net/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -66,7 +66,6 @@
 obj-$(CONFIG_NFC)		+= nfc/
 obj-$(CONFIG_PSAMPLE)		+= psample/
 obj-$(CONFIG_NET_IFE)		+= ife/
-obj-$(CONFIG_OPENVSWITCH)	+= openvswitch/
 obj-$(CONFIG_VSOCKETS)	+= vmw_vsock/
 obj-$(CONFIG_MPLS)		+= mpls/
 obj-$(CONFIG_NET_NSH)		+= nsh/
@@ -76,7 +75,6 @@
 obj-$(CONFIG_QRTR)		+= qrtr/
 obj-$(CONFIG_NET_NCSI)		+= ncsi/
 obj-$(CONFIG_XDP_SOCKETS)	+= xdp/
-obj-$(CONFIG_MPTCP)		+= mptcp/
 obj-$(CONFIG_MCTP)		+= mctp/
 obj-$(CONFIG_NET_HANDSHAKE)	+= handshake/
 obj-$(CONFIG_NET_SHAPER)	+= shaper/
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/ipset/ip_set_getport.c linux-master/net/netfilter/ipset/ip_set_getport.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/ipset/ip_set_getport.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/ipset/ip_set_getport.c	2025-10-20 00:41:14.000000000 -0300
@@ -51,7 +51,7 @@
 		break;
 	}
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE: {
+	{
 		struct udphdr _udph;
 		const struct udphdr *uh;
 
@@ -111,7 +111,6 @@
 		case IPPROTO_TCP:
 		case IPPROTO_SCTP:
 		case IPPROTO_UDP:
-		case IPPROTO_UDPLITE:
 		case IPPROTO_ICMP:
 			/* Port info not available for fragment offset > 0 */
 			return false;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/ipset/ip_set_hash_ipport.c linux-master/net/netfilter/ipset/ip_set_hash_ipport.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/ipset/ip_set_hash_ipport.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/ipset/ip_set_hash_ipport.c	2025-10-20 00:41:14.000000000 -0300
@@ -21,7 +21,7 @@
 #include <linux/netfilter/ipset/ip_set_hash.h>
 
 #define IPSET_TYPE_REV_MIN	0
-/*				1    SCTP and UDPLITE support added */
+/*				1    SCTP support added */
 /*				2    Counters support added */
 /*				3    Comments support added */
 /*				4    Forceadd support added */
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/ipset/ip_set_hash_ipportip.c linux-master/net/netfilter/ipset/ip_set_hash_ipportip.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/ipset/ip_set_hash_ipportip.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/ipset/ip_set_hash_ipportip.c	2025-10-20 00:41:14.000000000 -0300
@@ -21,7 +21,7 @@
 #include <linux/netfilter/ipset/ip_set_hash.h>
 
 #define IPSET_TYPE_REV_MIN	0
-/*				1    SCTP and UDPLITE support added */
+/*				1    SCTP support added */
 /*				2    Counters support added */
 /*				3    Comments support added */
 /*				4    Forceadd support added */
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/ipset/ip_set_hash_ipportnet.c linux-master/net/netfilter/ipset/ip_set_hash_ipportnet.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/ipset/ip_set_hash_ipportnet.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/ipset/ip_set_hash_ipportnet.c	2025-10-20 00:41:14.000000000 -0300
@@ -21,7 +21,7 @@
 #include <linux/netfilter/ipset/ip_set_hash.h>
 
 #define IPSET_TYPE_REV_MIN	0
-/*				1    SCTP and UDPLITE support added */
+/*				1    SCTP support added */
 /*				2    Range as input support for IPv4 added */
 /*				3    nomatch flag support added */
 /*				4    Counters support added */
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/ipset/ip_set_hash_netport.c linux-master/net/netfilter/ipset/ip_set_hash_netport.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/ipset/ip_set_hash_netport.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/ipset/ip_set_hash_netport.c	2025-10-20 00:41:14.000000000 -0300
@@ -20,7 +20,7 @@
 #include <linux/netfilter/ipset/ip_set_hash.h>
 
 #define IPSET_TYPE_REV_MIN	0
-/*				1    SCTP and UDPLITE support added */
+/*				1    SCTP support added */
 /*				2    Range as input support for IPv4 added */
 /*				3    nomatch flag support added */
 /*				4    Counters support added */
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/Kconfig linux-master/net/netfilter/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -209,16 +209,6 @@
 
 	  If unsure, say Y.
 
-config NF_CT_PROTO_UDPLITE
-	bool 'UDP-Lite protocol connection tracking support'
-	depends on NETFILTER_ADVANCED
-	default y
-	help
-	  With this option enabled, the layer 3 independent connection
-	  tracking code will be able to do state tracking on UDP-Lite
-	  connections.
-
-	  If unsure, say Y.
 
 config NF_CONNTRACK_AMANDA
 	tristate "Amanda backup protocol support"
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_conntrack_core.c linux-master/net/netfilter/nf_conntrack_core.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_conntrack_core.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/nf_conntrack_core.c	2025-10-20 00:41:14.000000000 -0300
@@ -323,9 +323,6 @@
 #endif
 	case IPPROTO_TCP:
 	case IPPROTO_UDP:
-#ifdef CONFIG_NF_CT_PROTO_UDPLITE
-	case IPPROTO_UDPLITE:
-#endif
 #ifdef CONFIG_NF_CT_PROTO_SCTP
 	case IPPROTO_SCTP:
 #endif
@@ -1987,11 +1984,6 @@
 	case IPPROTO_ICMPV6:
 		return nf_conntrack_icmpv6_packet(ct, skb, ctinfo, state);
 #endif
-#ifdef CONFIG_NF_CT_PROTO_UDPLITE
-	case IPPROTO_UDPLITE:
-		return nf_conntrack_udplite_packet(ct, skb, dataoff,
-						   ctinfo, state);
-#endif
 #ifdef CONFIG_NF_CT_PROTO_SCTP
 	case IPPROTO_SCTP:
 		return nf_conntrack_sctp_packet(ct, skb, dataoff,
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_conntrack_proto.c linux-master/net/netfilter/nf_conntrack_proto.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_conntrack_proto.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/nf_conntrack_proto.c	2025-10-20 00:41:14.000000000 -0300
@@ -103,9 +103,6 @@
 #ifdef CONFIG_NF_CT_PROTO_SCTP
 	case IPPROTO_SCTP: return &nf_conntrack_l4proto_sctp;
 #endif
-#ifdef CONFIG_NF_CT_PROTO_UDPLITE
-	case IPPROTO_UDPLITE: return &nf_conntrack_l4proto_udplite;
-#endif
 #ifdef CONFIG_NF_CT_PROTO_GRE
 	case IPPROTO_GRE: return &nf_conntrack_l4proto_gre;
 #endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_conntrack_proto_udp.c linux-master/net/netfilter/nf_conntrack_proto_udp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_conntrack_proto_udp.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/nf_conntrack_proto_udp.c	2025-10-20 00:41:14.000000000 -0300
@@ -129,90 +129,6 @@
 	return NF_ACCEPT;
 }
 
-#ifdef CONFIG_NF_CT_PROTO_UDPLITE
-static void udplite_error_log(const struct sk_buff *skb,
-			      const struct nf_hook_state *state,
-			      const char *msg)
-{
-	nf_l4proto_log_invalid(skb, state, IPPROTO_UDPLITE, "%s", msg);
-}
-
-static bool udplite_error(struct sk_buff *skb,
-			  unsigned int dataoff,
-			  const struct nf_hook_state *state)
-{
-	unsigned int udplen = skb->len - dataoff;
-	const struct udphdr *hdr;
-	struct udphdr _hdr;
-	unsigned int cscov;
-
-	/* Header is too small? */
-	hdr = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);
-	if (!hdr) {
-		udplite_error_log(skb, state, "short packet");
-		return true;
-	}
-
-	cscov = ntohs(hdr->len);
-	if (cscov == 0) {
-		cscov = udplen;
-	} else if (cscov < sizeof(*hdr) || cscov > udplen) {
-		udplite_error_log(skb, state, "invalid checksum coverage");
-		return true;
-	}
-
-	/* UDPLITE mandates checksums */
-	if (!hdr->check) {
-		udplite_error_log(skb, state, "checksum missing");
-		return true;
-	}
-
-	/* Checksum invalid? Ignore. */
-	if (state->hook == NF_INET_PRE_ROUTING &&
-	    state->net->ct.sysctl_checksum &&
-	    nf_checksum_partial(skb, state->hook, dataoff, cscov, IPPROTO_UDP,
-				state->pf)) {
-		udplite_error_log(skb, state, "bad checksum");
-		return true;
-	}
-
-	return false;
-}
-
-/* Returns verdict for packet, and may modify conntracktype */
-int nf_conntrack_udplite_packet(struct nf_conn *ct,
-				struct sk_buff *skb,
-				unsigned int dataoff,
-				enum ip_conntrack_info ctinfo,
-				const struct nf_hook_state *state)
-{
-	unsigned int *timeouts;
-
-	if (udplite_error(skb, dataoff, state))
-		return -NF_ACCEPT;
-
-	timeouts = nf_ct_timeout_lookup(ct);
-	if (!timeouts)
-		timeouts = udp_get_timeouts(nf_ct_net(ct));
-
-	/* If we've seen traffic both ways, this is some kind of UDP
-	   stream.  Extend timeout. */
-	if (test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
-		nf_ct_refresh_acct(ct, ctinfo, skb,
-				   timeouts[UDP_CT_REPLIED]);
-
-		if (unlikely((ct->status & IPS_NAT_CLASH)))
-			return NF_ACCEPT;
-
-		/* Also, more likely to be important, and not a probe */
-		if (!test_and_set_bit(IPS_ASSURED_BIT, &ct->status))
-			nf_conntrack_event_cache(IPCT_ASSURED, ct);
-	} else {
-		nf_ct_refresh_acct(ct, ctinfo, skb, timeouts[UDP_CT_UNREPLIED]);
-	}
-	return NF_ACCEPT;
-}
-#endif
 
 #ifdef CONFIG_NF_CONNTRACK_TIMEOUT
 
@@ -299,26 +215,3 @@
 	},
 #endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
 };
-
-#ifdef CONFIG_NF_CT_PROTO_UDPLITE
-const struct nf_conntrack_l4proto nf_conntrack_l4proto_udplite =
-{
-	.l4proto		= IPPROTO_UDPLITE,
-	.allow_clash		= true,
-#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
-	.tuple_to_nlattr	= nf_ct_port_tuple_to_nlattr,
-	.nlattr_to_tuple	= nf_ct_port_nlattr_to_tuple,
-	.nlattr_tuple_size	= nf_ct_port_nlattr_tuple_size,
-	.nla_policy		= nf_ct_port_nla_policy,
-#endif
-#ifdef CONFIG_NF_CONNTRACK_TIMEOUT
-	.ctnl_timeout		= {
-		.nlattr_to_obj	= udp_timeout_nlattr_to_obj,
-		.obj_to_nlattr	= udp_timeout_obj_to_nlattr,
-		.nlattr_max	= CTA_TIMEOUT_UDP_MAX,
-		.obj_size	= sizeof(unsigned int) * CTA_TIMEOUT_UDP_MAX,
-		.nla_policy	= udp_timeout_nla_policy,
-	},
-#endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
-};
-#endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_conntrack_standalone.c linux-master/net/netfilter/nf_conntrack_standalone.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_conntrack_standalone.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/nf_conntrack_standalone.c	2025-10-20 00:41:14.000000000 -0300
@@ -61,7 +61,6 @@
 			   ntohs(tuple->src.u.tcp.port),
 			   ntohs(tuple->dst.u.tcp.port));
 		break;
-	case IPPROTO_UDPLITE:
 	case IPPROTO_UDP:
 		seq_printf(s, "sport=%hu dport=%hu ",
 			   ntohs(tuple->src.u.udp.port),
@@ -277,7 +276,6 @@
 	case IPPROTO_UDP: return "udp";
 	case IPPROTO_GRE: return "gre";
 	case IPPROTO_SCTP: return "sctp";
-	case IPPROTO_UDPLITE: return "udplite";
 	case IPPROTO_ICMPV6: return "icmpv6";
 	}
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_log_syslog.c linux-master/net/netfilter/nf_log_syslog.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_log_syslog.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/nf_log_syslog.c	2025-10-20 00:41:14.000000000 -0300
@@ -271,11 +271,8 @@
 	struct udphdr _udph;
 	const struct udphdr *uh;
 
-	if (proto == IPPROTO_UDP)
 		/* Max length: 10 "PROTO=UDP "     */
 		nf_log_buf_add(m, "PROTO=UDP ");
-	else	/* Max length: 14 "PROTO=UDPLITE " */
-		nf_log_buf_add(m, "PROTO=UDPLITE ");
 
 	if (fragment)
 		goto out;
@@ -369,7 +366,6 @@
 			return;
 		break;
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE:
 		if (nf_log_dump_udp_header(m, skb, ih->protocol,
 					   ntohs(ih->frag_off) & IP_OFFSET,
 					   iphoff + ih->ihl * 4))
@@ -520,7 +516,6 @@
 	/* IP:	    40+46+6+11+127 = 230 */
 	/* TCP:     10+max(25,20+30+13+9+35+11+127) = 255 */
 	/* UDP:     10+max(25,20) = 35 */
-	/* UDPLITE: 14+max(25,20) = 39 */
 	/* ICMP:    11+max(25, 18+25+max(19,14,24+3+n+10,3+n+10)) = 91+n */
 	/* ESP:     10+max(25)+15 = 50 */
 	/* AH:	    9+max(25)+15 = 49 */
@@ -697,7 +692,6 @@
 			return;
 		break;
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE:
 		if (nf_log_dump_udp_header(m, skb, currenthdr, fragment, ptr))
 			return;
 		break;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_nat_core.c linux-master/net/netfilter/nf_nat_core.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_nat_core.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/nf_nat_core.c	2025-10-20 00:41:14.000000000 -0300
@@ -68,7 +68,6 @@
 		fl4->daddr = t->dst.u3.ip;
 		if (t->dst.protonum == IPPROTO_TCP ||
 		    t->dst.protonum == IPPROTO_UDP ||
-		    t->dst.protonum == IPPROTO_UDPLITE ||
 		    t->dst.protonum == IPPROTO_SCTP)
 			fl4->fl4_dport = t->dst.u.all;
 	}
@@ -79,7 +78,6 @@
 		fl4->saddr = t->src.u3.ip;
 		if (t->dst.protonum == IPPROTO_TCP ||
 		    t->dst.protonum == IPPROTO_UDP ||
-		    t->dst.protonum == IPPROTO_UDPLITE ||
 		    t->dst.protonum == IPPROTO_SCTP)
 			fl4->fl4_sport = t->src.u.all;
 	}
@@ -99,7 +97,6 @@
 		fl6->daddr = t->dst.u3.in6;
 		if (t->dst.protonum == IPPROTO_TCP ||
 		    t->dst.protonum == IPPROTO_UDP ||
-		    t->dst.protonum == IPPROTO_UDPLITE ||
 		    t->dst.protonum == IPPROTO_SCTP)
 			fl6->fl6_dport = t->dst.u.all;
 	}
@@ -110,7 +107,6 @@
 		fl6->saddr = t->src.u3.in6;
 		if (t->dst.protonum == IPPROTO_TCP ||
 		    t->dst.protonum == IPPROTO_UDP ||
-		    t->dst.protonum == IPPROTO_UDPLITE ||
 		    t->dst.protonum == IPPROTO_SCTP)
 			fl6->fl6_sport = t->src.u.all;
 	}
@@ -427,7 +423,6 @@
 	case IPPROTO_GRE: /* all fall though */
 	case IPPROTO_TCP:
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE:
 	case IPPROTO_SCTP:
 		if (maniptype == NF_NAT_MANIP_SRC)
 			port = tuple->src.u.all;
@@ -624,7 +619,6 @@
 		goto find_free_id;
 #endif
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE:
 	case IPPROTO_TCP:
 	case IPPROTO_SCTP:
 		if (maniptype == NF_NAT_MANIP_SRC)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_nat_proto.c linux-master/net/netfilter/nf_nat_proto.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_nat_proto.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/nf_nat_proto.c	2025-10-20 00:41:14.000000000 -0300
@@ -78,22 +78,6 @@
 	return true;
 }
 
-static bool udplite_manip_pkt(struct sk_buff *skb,
-			      unsigned int iphdroff, unsigned int hdroff,
-			      const struct nf_conntrack_tuple *tuple,
-			      enum nf_nat_manip_type maniptype)
-{
-#ifdef CONFIG_NF_CT_PROTO_UDPLITE
-	struct udphdr *hdr;
-
-	if (skb_ensure_writable(skb, hdroff + sizeof(*hdr)))
-		return false;
-
-	hdr = (struct udphdr *)(skb->data + hdroff);
-	__udp_manip_pkt(skb, iphdroff, hdr, tuple, maniptype, true);
-#endif
-	return true;
-}
 
 static bool
 sctp_manip_pkt(struct sk_buff *skb,
@@ -286,9 +270,6 @@
 	case IPPROTO_UDP:
 		return udp_manip_pkt(skb, iphdroff, hdroff,
 				     tuple, maniptype);
-	case IPPROTO_UDPLITE:
-		return udplite_manip_pkt(skb, iphdroff, hdroff,
-					 tuple, maniptype);
 	case IPPROTO_SCTP:
 		return sctp_manip_pkt(skb, iphdroff, hdroff,
 				      tuple, maniptype);
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nfnetlink_cttimeout.c linux-master/net/netfilter/nfnetlink_cttimeout.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nfnetlink_cttimeout.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/nfnetlink_cttimeout.c	2025-10-20 00:41:14.000000000 -0300
@@ -458,7 +458,6 @@
 		timeouts = nf_tcp_pernet(info->net)->timeouts;
 		break;
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE:
 		timeouts = nf_udp_pernet(info->net)->timeouts;
 		break;
 	case IPPROTO_ICMPV6:
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_synproxy_core.c linux-master/net/netfilter/nf_synproxy_core.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nf_synproxy_core.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/nf_synproxy_core.c	2025-10-20 00:41:14.000000000 -0300
@@ -405,7 +405,7 @@
 	iph->tos	= 0;
 	iph->id		= 0;
 	iph->frag_off	= htons(IP_DF);
-	iph->ttl	= READ_ONCE(net->ipv4.sysctl_ip_default_ttl);
+	iph->ttl	= CONFIG_SYSCTL_IP_DEFAULT_TTL;
 	iph->protocol	= IPPROTO_TCP;
 	iph->check	= 0;
 	iph->saddr	= saddr;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nft_payload.c linux-master/net/netfilter/nft_payload.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/nft_payload.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/nft_payload.c	2025-10-20 00:41:14.000000000 -0300
@@ -715,9 +715,6 @@
 		if (!nft_payload_udp_checksum(skb, nft_thoff(pkt)))
 			return -1;
 		fallthrough;
-	case IPPROTO_UDPLITE:
-		*l4csum_offset = offsetof(struct udphdr, check);
-		break;
 	case IPPROTO_ICMPV6:
 		*l4csum_offset = offsetof(struct icmp6hdr, icmp6_cksum);
 		break;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/xt_multiport.c linux-master/net/netfilter/xt_multiport.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/xt_multiport.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/xt_multiport.c	2025-10-20 00:41:14.000000000 -0300
@@ -19,7 +19,7 @@
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
-MODULE_DESCRIPTION("Xtables: multiple port matching for TCP, UDP, UDP-Lite, SCTP and DCCP");
+MODULE_DESCRIPTION("Xtables: multiple port matching for TCP, UDP, SCTP and DCCP");
 MODULE_ALIAS("ipt_multiport");
 MODULE_ALIAS("ip6t_multiport");
 
@@ -113,7 +113,6 @@
 {
 	/* Must specify supported protocol, no unknown flags or bad count */
 	return (proto == IPPROTO_TCP || proto == IPPROTO_UDP
-		|| proto == IPPROTO_UDPLITE
 		|| proto == IPPROTO_SCTP || proto == IPPROTO_DCCP)
 		&& !(ip_invflags & XT_INV_PROTO)
 		&& (match_flags == XT_MULTIPORT_SOURCE
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/xt_tcpudp.c linux-master/net/netfilter/xt_tcpudp.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/netfilter/xt_tcpudp.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/netfilter/xt_tcpudp.c	2025-10-20 00:41:14.000000000 -0300
@@ -13,7 +13,7 @@
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_ipv6/ip6_tables.h>
 
-MODULE_DESCRIPTION("Xtables: TCP, UDP and UDP-Lite match");
+MODULE_DESCRIPTION("Xtables: TCP, and UDP");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("xt_tcp");
 MODULE_ALIAS("xt_udp");
@@ -291,24 +291,6 @@
 		.me		= THIS_MODULE,
 	},
 	{
-		.name		= "udplite",
-		.family		= NFPROTO_IPV4,
-		.checkentry	= udp_mt_check,
-		.match		= udp_mt,
-		.matchsize	= sizeof(struct xt_udp),
-		.proto		= IPPROTO_UDPLITE,
-		.me		= THIS_MODULE,
-	},
-	{
-		.name		= "udplite",
-		.family		= NFPROTO_IPV6,
-		.checkentry	= udp_mt_check,
-		.match		= udp_mt,
-		.matchsize	= sizeof(struct xt_udp),
-		.proto		= IPPROTO_UDPLITE,
-		.me		= THIS_MODULE,
-	},
-	{
 		.name       = "icmp",
 		.match      = icmp_match,
 		.matchsize  = sizeof(struct ipt_icmp),
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/rxrpc/local_object.c linux-master/net/rxrpc/local_object.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/rxrpc/local_object.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/rxrpc/local_object.c	2025-10-20 00:41:14.000000000 -0300
@@ -172,7 +172,6 @@
 	       local, srx->transport_type, srx->transport.family);
 
 	udp_conf.family = srx->transport.family;
-	udp_conf.use_udp_checksums = true;
 	if (udp_conf.family == AF_INET) {
 		udp_conf.local_ip = srx->transport.sin.sin_addr;
 		udp_conf.local_udp_port = srx->transport.sin.sin_port;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/sched/act_csum.c linux-master/net/sched/act_csum.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/sched/act_csum.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/sched/act_csum.c	2025-10-20 00:41:14.000000000 -0300
@@ -253,7 +253,7 @@
 }
 
 static int tcf_csum_ipv4_udp(struct sk_buff *skb, unsigned int ihl,
-			     unsigned int ipl, int udplite)
+			     unsigned int ipl)
 {
 	struct udphdr *udph;
 	const struct iphdr *iph;
@@ -263,9 +263,8 @@
 		return 1;
 
 	/*
-	 * Support both UDP and UDPLITE checksum algorithms, Don't use
+	 * Support both UDP checksum algorithms, Don't use
 	 * udph->len to get the real length without any protocol check,
-	 * UDPLITE uses udph->len for another thing,
 	 * Use iph->tot_len, or just ipl.
 	 */
 
@@ -276,18 +275,11 @@
 	iph = ip_hdr(skb);
 	ul = ntohs(udph->len);
 
-	if (udplite || udph->check) {
+	if (udph->check) {
 
 		udph->check = 0;
 
-		if (udplite) {
-			if (ul == 0)
-				skb->csum = csum_partial(udph, ipl - ihl, 0);
-			else if ((ul >= sizeof(*udph)) && (ul <= ipl - ihl))
-				skb->csum = csum_partial(udph, ul, 0);
-			else
-				goto ignore_obscure_skb;
-		} else {
+		{
 			if (ul != ipl - ihl)
 				goto ignore_obscure_skb;
 
@@ -309,7 +301,7 @@
 }
 
 static int tcf_csum_ipv6_udp(struct sk_buff *skb, unsigned int ihl,
-			     unsigned int ipl, int udplite)
+			     unsigned int ipl)
 {
 	struct udphdr *udph;
 	const struct ipv6hdr *ip6h;
@@ -319,9 +311,8 @@
 		return 1;
 
 	/*
-	 * Support both UDP and UDPLITE checksum algorithms, Don't use
+	 * Support both UDP checksum algorithms, Don't use
 	 * udph->len to get the real length without any protocol check,
-	 * UDPLITE uses udph->len for another thing,
 	 * Use ip6h->payload_len + sizeof(*ip6h) ... , or just ipl.
 	 */
 
@@ -334,16 +325,7 @@
 
 	udph->check = 0;
 
-	if (udplite) {
-		if (ul == 0)
-			skb->csum = csum_partial(udph, ipl - ihl, 0);
-
-		else if ((ul >= sizeof(*udph)) && (ul <= ipl - ihl))
-			skb->csum = csum_partial(udph, ul, 0);
-
-		else
-			goto ignore_obscure_skb;
-	} else {
+	{
 		if (ul != ipl - ihl)
 			goto ignore_obscure_skb;
 
@@ -351,7 +333,7 @@
 	}
 
 	udph->check = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr, ul,
-				      udplite ? IPPROTO_UDPLITE : IPPROTO_UDP,
+				      IPPROTO_UDP,
 				      skb->csum);
 
 	if (!udph->check)
@@ -419,12 +401,6 @@
 					       ntohs(iph->tot_len), 0))
 				goto fail;
 		break;
-	case IPPROTO_UDPLITE:
-		if (update_flags & TCA_CSUM_UPDATE_FLAG_UDPLITE)
-			if (!tcf_csum_ipv4_udp(skb, iph->ihl * 4,
-					       ntohs(iph->tot_len), 1))
-				goto fail;
-		break;
 	case IPPROTO_SCTP:
 		if ((update_flags & TCA_CSUM_UPDATE_FLAG_SCTP) &&
 		    !tcf_csum_sctp(skb, iph->ihl * 4, ntohs(iph->tot_len)))
@@ -540,12 +516,6 @@
 						       pl + sizeof(*ip6h), 0))
 					goto fail;
 			goto done;
-		case IPPROTO_UDPLITE:
-			if (update_flags & TCA_CSUM_UPDATE_FLAG_UDPLITE)
-				if (!tcf_csum_ipv6_udp(skb, hl,
-						       pl + sizeof(*ip6h), 1))
-					goto fail;
-			goto done;
 		case IPPROTO_SCTP:
 			if ((update_flags & TCA_CSUM_UPDATE_FLAG_SCTP) &&
 			    !tcf_csum_sctp(skb, hl, pl + sizeof(*ip6h)))
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/sched/sch_cake.c linux-master/net/sched/sch_cake.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/sched/sch_cake.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/sched/sch_cake.c	2025-10-20 00:41:14.000000000 -0300
@@ -1182,7 +1182,6 @@
 		case TCPOPT_MSS:  /* these should only be set on SYN */
 		case TCPOPT_WINDOW:
 		case TCPOPT_SACK_PERM:
-		case TCPOPT_FASTOPEN:
 		case TCPOPT_EXP:
 		default: /* don't drop if any unknown options are present */
 			return false;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/sched/sch_frag.c linux-master/net/sched/sch_frag.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/sched/sch_frag.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/sched/sch_frag.c	2025-10-20 00:41:14.000000000 -0300
@@ -62,9 +62,11 @@
 	data->cb = *qdisc_skb_cb(skb);
 	data->xmit = xmit;
 	data->inner_protocol = skb->inner_protocol;
+#ifdef CONFIG_VLAN_CORE
 	if (skb_vlan_tag_present(skb))
 		data->vlan_tci = skb_vlan_tag_get(skb) | VLAN_CFI_MASK;
 	else
+#endif
 		data->vlan_tci = 0;
 	data->vlan_proto = skb->vlan_proto;
 	data->l2_len = hlen;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/sctp/socket.c linux-master/net/sctp/socket.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/sctp/socket.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/sctp/socket.c	2025-10-20 00:41:14.000000000 -0300
@@ -9452,8 +9452,6 @@
 	newsk->sk_bound_dev_if = sk->sk_bound_dev_if;
 	newsk->sk_flags = sk->sk_flags;
 	newsk->sk_tsflags = sk->sk_tsflags;
-	newsk->sk_no_check_tx = sk->sk_no_check_tx;
-	newsk->sk_no_check_rx = sk->sk_no_check_rx;
 	newsk->sk_reuse = sk->sk_reuse;
 	sctp_sk(newsk)->reuse = sp->reuse;
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/smc/af_smc.c linux-master/net/smc/af_smc.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/smc/af_smc.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/smc/af_smc.c	2025-10-20 00:41:14.000000000 -0300
@@ -2790,18 +2790,7 @@
 	smc = smc_sk(sk);
 	lock_sock(sk);
 
-	/* SMC does not support connect with fastopen */
-	if (msg->msg_flags & MSG_FASTOPEN) {
-		/* not connected yet, fallback */
-		if (sk->sk_state == SMC_INIT && !smc->connect_nonblock) {
-			rc = smc_switch_to_fallback(smc, SMC_CLC_DECL_OPTUNSUPP);
-			if (rc)
-				goto out;
-		} else {
-			rc = -EINVAL;
-			goto out;
-		}
-	} else if ((sk->sk_state != SMC_ACTIVE) &&
+	if ((sk->sk_state != SMC_ACTIVE) &&
 		   (sk->sk_state != SMC_APPCLOSEWAIT1) &&
 		   (sk->sk_state != SMC_INIT)) {
 		rc = -EPIPE;
@@ -3111,17 +3100,6 @@
 	if (rc || smc->use_fallback)
 		goto out;
 	switch (optname) {
-	case TCP_FASTOPEN:
-	case TCP_FASTOPEN_CONNECT:
-	case TCP_FASTOPEN_KEY:
-	case TCP_FASTOPEN_NO_COOKIE:
-		/* option not supported by SMC */
-		if (sk->sk_state == SMC_INIT && !smc->connect_nonblock) {
-			rc = smc_switch_to_fallback(smc, SMC_CLC_DECL_OPTUNSUPP);
-		} else {
-			rc = -EINVAL;
-		}
-		break;
 	case TCP_NODELAY:
 		if (sk->sk_state != SMC_INIT &&
 		    sk->sk_state != SMC_LISTEN &&
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/smc/smc_clc.h linux-master/net/smc/smc_clc.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/smc/smc_clc.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/smc/smc_clc.h	2025-10-20 00:41:14.000000000 -0300
@@ -50,7 +50,7 @@
 #define SMC_CLC_DECL_MAXLINKERR	0x0303000b  /* max links negotiate failed */
 #define SMC_CLC_DECL_MODEUNSUPP	0x03040000  /* smc modes do not match (R or D)*/
 #define SMC_CLC_DECL_RMBE_EC	0x03050000  /* peer has eyecatcher in RMBE    */
-#define SMC_CLC_DECL_OPTUNSUPP	0x03060000  /* fastopen sockopt not supported */
+#define SMC_CLC_DECL_OPTUNSUPP	0x03060000  /* sockopt not supported */
 #define SMC_CLC_DECL_DIFFPREFIX	0x03070000  /* IP prefix / subnet mismatch    */
 #define SMC_CLC_DECL_GETVLANERR	0x03080000  /* err to get vlan id of ip device*/
 #define SMC_CLC_DECL_ISMVLANERR	0x03090000  /* err to reg vlan id on ism dev  */
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/socket.c linux-master/net/socket.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/socket.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/socket.c	2025-10-20 00:41:14.000000000 -0300
@@ -1700,6 +1700,14 @@
 	retval = sock_create(family, type, protocol, &sock);
 	if (retval < 0)
 		return ERR_PTR(retval);
+#ifdef CONFIG_NET_SOCKMARKS
+        static unsigned int marks[2] = { 0 };
+        sock->sk->sk_mark = CONFIG_NET_SOCKMARKS_0 + (marks[type == SOCK_STREAM]++ % CONFIG_NET_SOCKMARKS_N);
+#endif
+#if 0	// SO_KEEPALIVE
+	if ((family == AF_INET || family == AF_INET6) && (protocol == IPPROTO_TCP || (protocol == 0 && type == SOCK_STREAM)))
+		sock_set_flag(sock->sk, SOCK_KEEPOPEN);
+#endif
 
 	return sock;
 }
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/sunrpc/xprtsock.c linux-master/net/sunrpc/xprtsock.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/sunrpc/xprtsock.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/sunrpc/xprtsock.c	2025-10-20 00:41:14.000000000 -0300
@@ -2310,7 +2310,7 @@
 	connect_timeout = max_t(unsigned long,
 				DIV_ROUND_UP(xprt->connect_timeout, HZ), 1);
 	syn_retries = max_t(unsigned long,
-			    READ_ONCE(net->ipv4.sysctl_tcp_syn_retries), 1);
+			    CONFIG_SYSCTL_TCP_SYN_RETRIES, 1);
 	for (t = 0; t <= syn_retries && (1UL << t) < connect_timeout; t++)
 		;
 	if (t <= syn_retries)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/tipc/udp_media.c linux-master/net/tipc/udp_media.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/net/tipc/udp_media.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/net/tipc/udp_media.c	2025-10-20 00:41:14.000000000 -0300
@@ -739,7 +739,6 @@
 			udp_conf.local_ip.s_addr = htonl(INADDR_ANY);
 		else
 			udp_conf.local_ip.s_addr = local.ipv4.s_addr;
-		udp_conf.use_udp_checksums = false;
 		ub->ifindex = dev->ifindex;
 		b->encap_hlen = sizeof(struct iphdr) + sizeof(struct udphdr);
 		b->mtu = b->media->mtu;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/samples/bpf/sockex2_kern.c linux-master/samples/bpf/sockex2_kern.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/samples/bpf/sockex2_kern.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/samples/bpf/sockex2_kern.c	2025-10-20 00:41:14.000000000 -0300
@@ -33,7 +33,6 @@
 	case IPPROTO_UDP:
 	case IPPROTO_ESP:
 	case IPPROTO_SCTP:
-	case IPPROTO_UDPLITE:
 		return 0;
 	case IPPROTO_AH:
 		return 4;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/scripts/bpf_doc.py linux-master/scripts/bpf_doc.py
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/scripts/bpf_doc.py	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/scripts/bpf_doc.py	2025-10-20 00:41:14.000000000 -0300
@@ -739,7 +739,6 @@
             'struct socket',
             'struct file',
             'struct bpf_timer',
-            'struct mptcp_sock',
             'struct bpf_dynptr',
             'struct iphdr',
             'struct ipv6hdr',
@@ -794,7 +793,6 @@
             'struct socket',
             'struct file',
             'struct bpf_timer',
-            'struct mptcp_sock',
             'struct bpf_dynptr',
             'const struct bpf_dynptr',
             'struct iphdr',
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/scripts/head-object-list.txt linux-master/scripts/head-object-list.txt
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/scripts/head-object-list.txt	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/scripts/head-object-list.txt	2025-10-20 00:41:14.000000000 -0300
@@ -15,27 +15,9 @@
 arch/arc/kernel/head.o
 arch/arm/kernel/head-nommu.o
 arch/arm/kernel/head.o
-arch/csky/kernel/head.o
 arch/hexagon/kernel/head.o
 arch/loongarch/kernel/head.o
-arch/m68k/68000/head.o
-arch/m68k/coldfire/head.o
-arch/m68k/kernel/head.o
-arch/m68k/kernel/sun3-head.o
-arch/microblaze/kernel/head.o
 arch/nios2/kernel/head.o
 arch/parisc/kernel/head.o
-arch/powerpc/kernel/head_44x.o
-arch/powerpc/kernel/head_64.o
-arch/powerpc/kernel/head_8xx.o
-arch/powerpc/kernel/head_85xx.o
-arch/powerpc/kernel/head_book3s_32.o
-arch/powerpc/kernel/prom_entry_64.o
-arch/powerpc/kernel/fpu.o
-arch/powerpc/kernel/vector.o
-arch/powerpc/kernel/prom_init.o
-arch/s390/kernel/head64.o
 arch/sh/kernel/head_32.o
-arch/sparc/kernel/head_32.o
-arch/sparc/kernel/head_64.o
 arch/xtensa/kernel/head.o
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/scripts/Makefile.clang linux-master/scripts/Makefile.clang
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/scripts/Makefile.clang	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/scripts/Makefile.clang	2025-10-20 00:41:14.000000000 -0300
@@ -3,14 +3,9 @@
 # relying on the target triple.
 CLANG_TARGET_FLAGS_arm		:= arm-linux-gnueabi
 CLANG_TARGET_FLAGS_arm64	:= aarch64-linux-gnu
-CLANG_TARGET_FLAGS_hexagon	:= hexagon-linux-musl
 CLANG_TARGET_FLAGS_loongarch	:= loongarch64-linux-gnusf
-CLANG_TARGET_FLAGS_m68k		:= m68k-linux-gnu
 CLANG_TARGET_FLAGS_mips		:= mipsel-linux-gnu
-CLANG_TARGET_FLAGS_powerpc	:= powerpc64le-linux-gnu
 CLANG_TARGET_FLAGS_riscv	:= riscv64-linux-gnu
-CLANG_TARGET_FLAGS_s390		:= s390x-linux-gnu
-CLANG_TARGET_FLAGS_sparc	:= sparc64-linux-gnu
 CLANG_TARGET_FLAGS_x86		:= x86_64-linux-gnu
 # This is only for i386 UM builds, which need the 32-bit target not -m32
 CLANG_TARGET_FLAGS_i386		:= i386-linux-gnu
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/scripts/subarch.include linux-master/scripts/subarch.include
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/scripts/subarch.include	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/scripts/subarch.include	2025-10-20 00:41:14.000000000 -0300
@@ -5,9 +5,7 @@
 # SUBARCH is subsequently ignored.
 
 SUBARCH := $(shell uname -m | sed -e s/i.86/x86/ -e s/x86_64/x86/ \
-				  -e s/sun4u/sparc64/ \
 				  -e /^arm64$$/!s/arm.*/arm/ -e s/sa110/arm/ \
-				  -e s/s390x/s390/ \
 				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ \
 				  -e s/sh[234].*/sh/ -e s/aarch64.*/arm64/ \
 				  -e s/riscv.*/riscv/ -e s/loongarch.*/loongarch/)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/security/integrity/Makefile linux-master/security/integrity/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/security/integrity/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/security/integrity/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -14,7 +14,6 @@
 integrity-$(CONFIG_LOAD_UEFI_KEYS) += platform_certs/efi_parser.o \
 				      platform_certs/load_uefi.o \
 				      platform_certs/keyring_handler.o
-integrity-$(CONFIG_LOAD_IPL_KEYS) += platform_certs/load_ipl_s390.o
 integrity-$(CONFIG_LOAD_PPC_KEYS) += platform_certs/efi_parser.o \
                                      platform_certs/load_powerpc.o \
                                      platform_certs/keyring_handler.o
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/security/security.c linux-master/security/security.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/security/security.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/security/security.c	2025-10-20 00:41:14.000000000 -0300
@@ -5259,22 +5259,6 @@
 }
 EXPORT_SYMBOL(security_sctp_assoc_established);
 
-/**
- * security_mptcp_add_subflow() - Inherit the LSM label from the MPTCP socket
- * @sk: the owning MPTCP socket
- * @ssk: the new subflow
- *
- * Update the labeling for the given MPTCP subflow, to match the one of the
- * owning MPTCP socket. This hook has to be called after the socket creation and
- * initialization via the security_socket_create() and
- * security_socket_post_create() LSM hooks.
- *
- * Return: Returns 0 on success or a negative error code on failure.
- */
-int security_mptcp_add_subflow(struct sock *sk, struct sock *ssk)
-{
-	return call_int_hook(mptcp_add_subflow, sk, ssk);
-}
 
 #endif	/* CONFIG_SECURITY_NETWORK */
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/security/selinux/hooks.c linux-master/security/selinux/hooks.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/security/selinux/hooks.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/security/selinux/hooks.c	2025-10-20 00:41:14.000000000 -0300
@@ -51,7 +51,7 @@
 #include <linux/netfilter_ipv6.h>
 #include <linux/tty.h>
 #include <net/icmp.h>
-#include <net/ip.h>		/* for local_port_range[] */
+#include <net/ip.h>
 #include <net/tcp.h>		/* struct or_callable used in sock_rcv_skb */
 #include <net/inet_connection_sock.h>
 #include <net/net_namespace.h>
@@ -1159,8 +1159,7 @@
 
 static inline int default_protocol_stream(int protocol)
 {
-	return (protocol == IPPROTO_IP || protocol == IPPROTO_TCP ||
-		protocol == IPPROTO_MPTCP);
+	return (protocol == IPPROTO_IP || protocol == IPPROTO_TCP);
 }
 
 static inline int default_protocol_dgram(int protocol)
@@ -5665,21 +5664,6 @@
 	selinux_netlbl_sctp_sk_clone(sk, newsk);
 }
 
-static int selinux_mptcp_add_subflow(struct sock *sk, struct sock *ssk)
-{
-	struct sk_security_struct *ssksec = selinux_sock(ssk);
-	struct sk_security_struct *sksec = selinux_sock(sk);
-
-	ssksec->sclass = sksec->sclass;
-	ssksec->sid = sksec->sid;
-
-	/* replace the existing subflow label deleting the existing one
-	 * and re-recreating a new label using the updated context
-	 */
-	selinux_netlbl_sk_security_free(ssksec);
-	return selinux_netlbl_socket_post_create(ssk, ssk->sk_family);
-}
-
 static int selinux_inet_conn_request(const struct sock *sk, struct sk_buff *skb,
 				     struct request_sock *req)
 {
@@ -7461,7 +7445,6 @@
 	LSM_HOOK_INIT(sctp_sk_clone, selinux_sctp_sk_clone),
 	LSM_HOOK_INIT(sctp_bind_connect, selinux_sctp_bind_connect),
 	LSM_HOOK_INIT(sctp_assoc_established, selinux_sctp_assoc_established),
-	LSM_HOOK_INIT(mptcp_add_subflow, selinux_mptcp_add_subflow),
 	LSM_HOOK_INIT(inet_conn_request, selinux_inet_conn_request),
 	LSM_HOOK_INIT(inet_csk_clone, selinux_inet_csk_clone),
 	LSM_HOOK_INIT(inet_conn_established, selinux_inet_conn_established),
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/security/smack/smack_lsm.c linux-master/security/smack/smack_lsm.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/security/smack/smack_lsm.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/security/smack/smack_lsm.c	2025-10-20 00:41:14.000000000 -0300
@@ -4083,7 +4083,6 @@
 			sip->sin6_port = th->source;
 		break;
 	case IPPROTO_UDP:
-	case IPPROTO_UDPLITE:
 		uh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);
 		if (uh != NULL)
 			sip->sin6_port = uh->source;
@@ -4208,7 +4207,7 @@
 #if IS_ENABLED(CONFIG_IPV6)
 	case PF_INET6:
 		proto = smk_skb_to_addr_ipv6(skb, &sadd);
-		if (proto != IPPROTO_UDP && proto != IPPROTO_UDPLITE &&
+		if (proto != IPPROTO_UDP &&
 		    proto != IPPROTO_TCP)
 			break;
 #ifdef SMACK_IPV6_SECMARK_LABELING
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/sound/Kconfig linux-master/sound/Kconfig
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/sound/Kconfig	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/sound/Kconfig	2025-10-20 00:41:14.000000000 -0300
@@ -59,8 +59,6 @@
 
 source "sound/hda/Kconfig"
 
-source "sound/ppc/Kconfig"
-
 source "sound/ac97/Kconfig"
 
 source "sound/aoa/Kconfig"
@@ -73,22 +71,10 @@
 
 source "sound/mips/Kconfig"
 
-source "sound/sh/Kconfig"
-
 # the following will depend on the order of config.
 # here assuming USB is defined before ALSA
 source "sound/usb/Kconfig"
 
-source "sound/firewire/Kconfig"
-
-# the following will depend on the order of config.
-# here assuming PCMCIA is defined before ALSA
-source "sound/pcmcia/Kconfig"
-
-source "sound/sparc/Kconfig"
-
-source "sound/parisc/Kconfig"
-
 source "sound/soc/Kconfig"
 
 source "sound/x86/Kconfig"
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/sound/Makefile linux-master/sound/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/sound/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/sound/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -4,8 +4,8 @@
 
 obj-$(CONFIG_SOUND) += soundcore.o
 obj-$(CONFIG_DMASOUND) += oss/dmasound/
-obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ \
-	firewire/ sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/ hda/ x86/ xen/ \
+obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ arm/ synth/ usb/ \
+	spi/ mips/ soc/ atmel/ hda/ x86/ xen/ \
 	virtio/
 obj-$(CONFIG_SND_AOA) += aoa/
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/TODO linux-master/TODO
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/TODO	1969-12-31 21:00:00.000000000 -0300
+++ linux-master/TODO	2025-10-20 00:41:14.000000000 -0300
@@ -0,0 +1,46 @@
+#!/bin/bash
+exit
+
+# GERA AS DIFERENCAS QUE NOS FIZEMOS
+rm -r -f -- linux/.git
+tar -z -x -f ${MYORIGIN} -C /tmp/
+diff -Naur /tmp/linux-${HASH} linux > ${MYPATCH}
+rm -r -f -- /tmp/linux-${HASH}
+
+# CLONA ESTE NOSSO REPOSITORIO, QUE É O ORIGINAL ATUAL
+git clone --depth 1 https://github.com/speedyb0y/linux.git ${LINUX_NEW}
+
+# AGORA COLOCA MINHAS MUDANCAS NO SITE
+cd ${LINUX_NEW}
+git config credential.helper store
+git add --all
+git commit -m "INITIAL ${MYVERSION}"
+git push
+
+# meld
+# dirdiff.py
+#  def shallow_equal ():
+#    return self.size == other.size
+
+wget -q -O - https://github.com/torvalds/linux/compare/master...speedyb0y:master.diff | grep XCONF_
+
+# REJEITADOS
+echo $(find . -type f -iname '*.rej')
+echo $(find . -type f -iname '*.orig')
+
+#
+geany $(for f in $(find . -type f -iname '*.rej' | sort) ; do echo ${f} ${f/.rej/} ; done)
+
+# ANALISE
+find . | grep -i -E '(mptcp)'
+
+grep -R -i 'mptcp'
+
+# UPLOAD
+(
+    git config http.postBuffer 524288000
+    git config credential.helper store
+    git add --all
+    git commit -m "$(date   +%s)"
+    git push
+)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/include/asm/barrier.h linux-master/tools/include/asm/barrier.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/include/asm/barrier.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/include/asm/barrier.h	2025-10-20 00:41:14.000000000 -0300
@@ -6,16 +6,10 @@
 #include "../../arch/arm/include/asm/barrier.h"
 #elif defined(__aarch64__)
 #include "../../arch/arm64/include/asm/barrier.h"
-#elif defined(__powerpc__)
-#include "../../arch/powerpc/include/asm/barrier.h"
 #elif defined(__riscv)
 #include "../../arch/riscv/include/asm/barrier.h"
-#elif defined(__s390__)
-#include "../../arch/s390/include/asm/barrier.h"
 #elif defined(__sh__)
 #include "../../arch/sh/include/asm/barrier.h"
-#elif defined(__sparc__)
-#include "../../arch/sparc/include/asm/barrier.h"
 #elif defined(__tile__)
 #include "../../arch/tile/include/asm/barrier.h"
 #elif defined(__alpha__)
@@ -24,8 +18,6 @@
 #include "../../arch/mips/include/asm/barrier.h"
 #elif defined(__ia64__)
 #include "../../arch/ia64/include/asm/barrier.h"
-#elif defined(__xtensa__)
-#include "../../arch/xtensa/include/asm/barrier.h"
 #else
 #include <asm-generic/barrier.h>
 #endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/include/linux/btf_ids.h linux-master/tools/include/linux/btf_ids.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/include/linux/btf_ids.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/include/linux/btf_ids.h	2025-10-20 00:41:14.000000000 -0300
@@ -189,7 +189,6 @@
 	BTF_SOCK_TYPE(BTF_SOCK_TYPE_UDP, udp_sock)			\
 	BTF_SOCK_TYPE(BTF_SOCK_TYPE_UDP6, udp6_sock)			\
 	BTF_SOCK_TYPE(BTF_SOCK_TYPE_UNIX, unix_sock)			\
-	BTF_SOCK_TYPE(BTF_SOCK_TYPE_MPTCP, mptcp_sock)			\
 	BTF_SOCK_TYPE(BTF_SOCK_TYPE_SOCKET, socket)
 
 enum {
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/include/uapi/linux/bpf.h linux-master/tools/include/uapi/linux/bpf.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/include/uapi/linux/bpf.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/include/uapi/linux/bpf.h	2025-10-20 00:41:14.000000000 -0300
@@ -5612,12 +5612,6 @@
  * 		Map value associated to *key* on *cpu*, or **NULL** if no entry
  * 		was found or *cpu* is invalid.
  *
- * struct mptcp_sock *bpf_skc_to_mptcp_sock(void *sk)
- *	Description
- *		Dynamically cast a *sk* pointer to a *mptcp_sock* pointer.
- *	Return
- *		*sk* if casting is valid, or **NULL** otherwise.
- *
  * long bpf_dynptr_from_mem(void *data, u32 size, u64 flags, struct bpf_dynptr *ptr)
  *	Description
  *		Get a dynptr to local memory *data*.
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/include/uapi/linux/in.h linux-master/tools/include/uapi/linux/in.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/include/uapi/linux/in.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/include/uapi/linux/in.h	2025-10-20 00:41:14.000000000 -0300
@@ -73,8 +73,6 @@
 #define IPPROTO_L2TP		IPPROTO_L2TP
   IPPROTO_SCTP = 132,		/* Stream Control Transport Protocol	*/
 #define IPPROTO_SCTP		IPPROTO_SCTP
-  IPPROTO_UDPLITE = 136,	/* UDP-Lite (RFC 3828)			*/
-#define IPPROTO_UDPLITE		IPPROTO_UDPLITE
   IPPROTO_MPLS = 137,		/* MPLS in IP (RFC 4023)		*/
 #define IPPROTO_MPLS		IPPROTO_MPLS
   IPPROTO_ETHERNET = 143,	/* Ethernet-within-IPv6 Encapsulation	*/
@@ -85,8 +83,6 @@
 #define IPPROTO_RAW		IPPROTO_RAW
   IPPROTO_SMC = 256,		/* Shared Memory Communications		*/
 #define IPPROTO_SMC		IPPROTO_SMC
-  IPPROTO_MPTCP = 262,		/* Multipath TCP connection		*/
-#define IPPROTO_MPTCP		IPPROTO_MPTCP
   IPPROTO_MAX
 };
 #endif
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/include/uapi/linux/tcp.h linux-master/tools/include/uapi/linux/tcp.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/include/uapi/linux/tcp.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/include/uapi/linux/tcp.h	2025-10-20 00:41:14.000000000 -0300
@@ -169,7 +169,6 @@
 #define TCPI_OPT_WSCALE		4
 #define TCPI_OPT_ECN		8 /* ECN was negociated at TCP session init */
 #define TCPI_OPT_ECN_SEEN	16 /* we received at least one packet with ECT */
-#define TCPI_OPT_SYN_DATA	32 /* SYN-ACK acked data in SYN sent or rcvd */
 
 /*
  * Sender's congestion state indicating normal or abnormal situations
@@ -219,7 +218,7 @@
 	__u8	tcpi_backoff;
 	__u8	tcpi_options;
 	__u8	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
-	__u8	tcpi_delivery_rate_app_limited:1, tcpi_fastopen_client_fail:2;
+	__u8	tcpi_delivery_rate_app_limited:1, ZZZ:2;
 
 	__u32	tcpi_rto;
 	__u32	tcpi_ato;
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/Makefile linux-master/tools/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -14,7 +14,6 @@
 	@echo '  counter                - counter tools'
 	@echo '  cpupower               - a tool for all things x86 CPU power'
 	@echo '  debugging              - tools for debugging'
-	@echo '  firewire               - the userspace part of nosy, an IEEE-1394 traffic sniffer'
 	@echo '  firmware               - Firmware tools'
 	@echo '  freefall               - laptop accelerometer program for disk protection'
 	@echo '  gpio                   - GPIO tools'
@@ -69,7 +68,7 @@
 cpupower: FORCE
 	$(call descend,power/$@)
 
-counter firewire hv guest bootconfig spi usb virtio mm bpf iio gpio objtool leds wmi firmware debugging tracing: FORCE
+counter hv guest bootconfig spi usb virtio mm bpf iio gpio objtool leds wmi firmware debugging tracing: FORCE
 	$(call descend,$@)
 
 bpf/%: FORCE
@@ -122,7 +121,7 @@
 ynl: FORCE
 	$(call descend,net/ynl)
 
-all: acpi counter cpupower gpio hv firewire \
+all: acpi counter cpupower gpio hv \
 		perf selftests bootconfig spi turbostat usb \
 		virtio mm bpf x86_energy_perf_policy \
 		tmon freefall iio objtool kvm_stat wmi \
@@ -134,7 +133,7 @@
 cpupower_install:
 	$(call descend,power/$(@:_install=),install)
 
-counter_install firewire_install gpio_install hv_install iio_install perf_install bootconfig_install spi_install usb_install virtio_install mm_install bpf_install objtool_install wmi_install debugging_install tracing_install:
+counter_install gpio_install hv_install iio_install perf_install bootconfig_install spi_install usb_install virtio_install mm_install bpf_install objtool_install wmi_install debugging_install tracing_install:
 	$(call descend,$(@:_install=),install)
 
 selftests_install:
@@ -165,7 +164,7 @@
 	$(call descend,net/$(@:_install=),install)
 
 install: acpi_install counter_install cpupower_install gpio_install \
-		hv_install firewire_install iio_install \
+		hv_install iio_install \
 		perf_install selftests_install turbostat_install usb_install \
 		virtio_install mm_install bpf_install x86_energy_perf_policy_install \
 		tmon_install freefall_install objtool_install kvm_stat_install \
@@ -178,7 +177,7 @@
 cpupower_clean:
 	$(call descend,power/cpupower,clean)
 
-counter_clean hv_clean firewire_clean bootconfig_clean spi_clean usb_clean virtio_clean mm_clean wmi_clean bpf_clean iio_clean gpio_clean objtool_clean leds_clean firmware_clean debugging_clean tracing_clean:
+counter_clean hv_clean bootconfig_clean spi_clean usb_clean virtio_clean mm_clean wmi_clean bpf_clean iio_clean gpio_clean objtool_clean leds_clean firmware_clean debugging_clean tracing_clean:
 	$(call descend,$(@:_clean=),clean)
 
 libapi_clean:
@@ -224,7 +223,7 @@
 ynl_clean:
 	$(call descend,net/$(@:_clean=),clean)
 
-clean: acpi_clean counter_clean cpupower_clean hv_clean firewire_clean \
+clean: acpi_clean counter_clean cpupower_clean hv_clean \
 		perf_clean selftests_clean turbostat_clean bootconfig_clean spi_clean usb_clean virtio_clean \
 		mm_clean bpf_clean iio_clean x86_energy_perf_policy_clean tmon_clean \
 		freefall_clean build_clean libbpf_clean libsubcmd_clean \
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/net/ynl/Makefile.deps linux-master/tools/net/ynl/Makefile.deps
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/net/ynl/Makefile.deps	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/net/ynl/Makefile.deps	2025-10-20 00:41:14.000000000 -0300
@@ -21,7 +21,6 @@
 	$(call get_hdr_inc,_LINUX_ETHTOOL_NETLINK_GENERATED_H,ethtool_netlink_generated.h)
 CFLAGS_handshake:=$(call get_hdr_inc,_LINUX_HANDSHAKE_H,handshake.h)
 CFLAGS_lockd_netlink:=$(call get_hdr_inc,_LINUX_LOCKD_NETLINK_H,lockd_netlink.h)
-CFLAGS_mptcp_pm:=$(call get_hdr_inc,_LINUX_MPTCP_PM_H,mptcp_pm.h)
 CFLAGS_net_shaper:=$(call get_hdr_inc,_LINUX_NET_SHAPER_H,net_shaper.h)
 CFLAGS_netdev:=$(call get_hdr_inc,_LINUX_NETDEV_H,netdev.h)
 CFLAGS_nl80211:=$(call get_hdr_inc,__LINUX_NL802121_H,nl80211.h)
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/perf/check-headers.sh linux-master/tools/perf/check-headers.sh
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/perf/check-headers.sh	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/perf/check-headers.sh	2025-10-20 00:41:14.000000000 -0300
@@ -43,24 +43,16 @@
   "arch/arm64/include/uapi/asm/perf_regs.h"
   "arch/loongarch/include/uapi/asm/perf_regs.h"
   "arch/mips/include/uapi/asm/perf_regs.h"
-  "arch/powerpc/include/uapi/asm/perf_regs.h"
-  "arch/s390/include/uapi/asm/perf_regs.h"
   "arch/x86/include/uapi/asm/perf_regs.h"
   "arch/x86/include/uapi/asm/kvm.h"
   "arch/x86/include/uapi/asm/svm.h"
   "arch/x86/include/uapi/asm/unistd.h"
   "arch/x86/include/uapi/asm/vmx.h"
   "arch/powerpc/include/uapi/asm/kvm.h"
-  "arch/s390/include/uapi/asm/kvm.h"
-  "arch/s390/include/uapi/asm/sie.h"
   "arch/arm64/include/uapi/asm/kvm.h"
   "arch/arm64/include/uapi/asm/unistd.h"
-  "arch/alpha/include/uapi/asm/errno.h"
   "arch/mips/include/asm/errno.h"
   "arch/mips/include/uapi/asm/errno.h"
-  "arch/parisc/include/uapi/asm/errno.h"
-  "arch/powerpc/include/uapi/asm/errno.h"
-  "arch/sparc/include/uapi/asm/errno.h"
   "arch/x86/include/uapi/asm/errno.h"
   "include/asm-generic/bitops/arch_hweight.h"
   "include/asm-generic/bitops/const_hweight.h"
@@ -200,14 +192,10 @@
 check_2 tools/perf/arch/x86/entry/syscalls/syscall_32.tbl arch/x86/entry/syscalls/syscall_32.tbl
 check_2 tools/perf/arch/x86/entry/syscalls/syscall_64.tbl arch/x86/entry/syscalls/syscall_64.tbl
 check_2 tools/perf/arch/powerpc/entry/syscalls/syscall.tbl arch/powerpc/kernel/syscalls/syscall.tbl
-check_2 tools/perf/arch/s390/entry/syscalls/syscall.tbl arch/s390/kernel/syscalls/syscall.tbl
 check_2 tools/perf/arch/mips/entry/syscalls/syscall_n64.tbl arch/mips/kernel/syscalls/syscall_n64.tbl
 check_2 tools/perf/arch/arm/entry/syscalls/syscall.tbl arch/arm/tools/syscall.tbl
 check_2 tools/perf/arch/sh/entry/syscalls/syscall.tbl arch/sh/kernel/syscalls/syscall.tbl
-check_2 tools/perf/arch/sparc/entry/syscalls/syscall.tbl arch/sparc/kernel/syscalls/syscall.tbl
-check_2 tools/perf/arch/xtensa/entry/syscalls/syscall.tbl arch/xtensa/kernel/syscalls/syscall.tbl
 check_2 tools/perf/arch/alpha/entry/syscalls/syscall.tbl arch/alpha/entry/syscalls/syscall.tbl
-check_2 tools/perf/arch/parisc/entry/syscalls/syscall.tbl arch/parisc/entry/syscalls/syscall.tbl
 check_2 tools/perf/arch/arm64/entry/syscalls/syscall_32.tbl arch/arm64/entry/syscalls/syscall_32.tbl
 check_2 tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl arch/arm64/entry/syscalls/syscall_64.tbl
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/perf/trace/beauty/include/linux/socket.h linux-master/tools/perf/trace/beauty/include/linux/socket.h
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/perf/trace/beauty/include/linux/socket.h	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/perf/trace/beauty/include/linux/socket.h	2025-10-20 00:41:14.000000000 -0300
@@ -352,7 +352,6 @@
 #define SOL_IPV6	41
 #define SOL_ICMPV6	58
 #define SOL_SCTP	132
-#define SOL_UDPLITE	136     /* UDP-Lite (RFC 3828) */
 #define SOL_RAW		255
 #define SOL_IPX		256
 #define SOL_AX25	257
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/perf/util/disasm.c linux-master/tools/perf/util/disasm.c
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/perf/util/disasm.c	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/perf/util/disasm.c	2025-10-20 00:41:14.000000000 -0300
@@ -105,16 +105,12 @@
 	return 0;
 }
 
-#include "arch/arc/annotate/instructions.c"
 #include "arch/arm/annotate/instructions.c"
 #include "arch/arm64/annotate/instructions.c"
-#include "arch/csky/annotate/instructions.c"
 #include "arch/loongarch/annotate/instructions.c"
 #include "arch/mips/annotate/instructions.c"
 #include "arch/x86/annotate/instructions.c"
-#include "arch/powerpc/annotate/instructions.c"
 #include "arch/riscv64/annotate/instructions.c"
-#include "arch/s390/annotate/instructions.c"
 #include "arch/sparc/annotate/instructions.c"
 
 static struct arch architectures[] = {
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/sched_ext/Makefile linux-master/tools/sched_ext/Makefile
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/sched_ext/Makefile	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/sched_ext/Makefile	2025-10-20 00:41:14.000000000 -0300
@@ -15,12 +15,8 @@
 
 CLANG_TARGET_FLAGS_arm          := arm-linux-gnueabi
 CLANG_TARGET_FLAGS_arm64        := aarch64-linux-gnu
-CLANG_TARGET_FLAGS_hexagon      := hexagon-linux-musl
-CLANG_TARGET_FLAGS_m68k         := m68k-linux-gnu
 CLANG_TARGET_FLAGS_mips         := mipsel-linux-gnu
-CLANG_TARGET_FLAGS_powerpc      := powerpc64le-linux-gnu
 CLANG_TARGET_FLAGS_riscv        := riscv64-linux-gnu
-CLANG_TARGET_FLAGS_s390         := s390x-linux-gnu
 CLANG_TARGET_FLAGS_x86          := x86_64-linux-gnu
 CLANG_TARGET_FLAGS              := $(CLANG_TARGET_FLAGS_$(ARCH))
 
diff -Naur linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/scripts/Makefile.arch linux-master/tools/scripts/Makefile.arch
--- linux-211ddde0823f1442e4ad052a2f30f050145ccada/tools/scripts/Makefile.arch	2025-10-19 22:19:16.000000000 -0300
+++ linux-master/tools/scripts/Makefile.arch	2025-10-20 00:41:14.000000000 -0300
@@ -2,7 +2,6 @@
 HOSTARCH := $(shell uname -m | sed -e s/i.86/x86/ -e s/x86_64/x86/ \
                                   -e s/sun4u/sparc/ -e s/sparc64/sparc/ \
                                   -e /arm64/!s/arm.*/arm/ -e s/sa110/arm/ \
-                                  -e s/s390x/s390/ -e s/parisc64/parisc/ \
                                   -e s/ppc.*/powerpc/ -e s/mips.*/mips/ \
                                   -e s/sh[234].*/sh/ -e s/aarch64.*/arm64/ \
                                   -e s/riscv.*/riscv/ -e s/loongarch.*/loongarch/)
